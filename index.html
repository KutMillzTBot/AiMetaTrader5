<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>KutEA26 - EA Control Dashboard</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #111a2d;
      --panel-2: #16213a;
      --line: #27324b;
      --text: #dbe6ff;
      --muted: #8ea2cc;
      --brand: #35c6ff;
      --ok: #23d18b;
      --bad: #ff5f6d;
      --warn: #ffb454;
      --accent: #5aa8ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: radial-gradient(1200px 700px at 10% -10%, #132340 0%, var(--bg) 45%);
      color: var(--text);
    }
    .hidden { display: none !important; }
    .lock-screen {
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 24px;
      background:
        radial-gradient(860px 460px at 8% 10%, rgba(39, 127, 255, 0.14), transparent 62%),
        radial-gradient(880px 420px at 96% 88%, rgba(44, 192, 151, 0.12), transparent 66%),
        #070f1d;
    }
    .lock-shell {
      width: min(980px, 100%);
      display: grid;
      grid-template-columns: 1.05fr minmax(360px, 420px);
      gap: 18px;
      align-items: stretch;
    }
    .lock-brand {
      border: 1px solid #2b3958;
      border-radius: 18px;
      background: linear-gradient(165deg, rgba(18, 35, 66, 0.92) 0%, rgba(11, 23, 44, 0.92) 100%);
      box-shadow: inset 0 1px 0 rgba(170, 206, 255, 0.06);
      padding: 26px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 12px;
    }
    .lock-kicker {
      margin: 0;
      font-size: 0.75rem;
      letter-spacing: 0.15em;
      color: #7ca2db;
    }
    .lock-brand h2 {
      margin: 0;
      font-size: clamp(1.35rem, 2.2vw, 2rem);
      color: #e3eeff;
      line-height: 1.2;
    }
    .lock-brand p {
      margin: 0;
      color: #9eb5dc;
      line-height: 1.55;
      font-size: 0.95rem;
      max-width: 52ch;
    }
    .lock-pills {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }
    .lock-pills span {
      border: 1px solid #2b4169;
      background: #12233f;
      color: #b8d4ff;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.78rem;
    }
    .auth-card {
      width: 100%;
      background: linear-gradient(180deg, #13213b 0%, #0f192e 100%);
      border: 1px solid #2d3d5d;
      border-radius: 18px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.42);
      padding: 24px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .auth-mark {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #6bd3ff, #1f5cbf 65%);
      border: 1px solid #6caef7;
      box-shadow: 0 0 0 5px rgba(52, 135, 231, 0.16);
      margin-bottom: 12px;
    }
    .auth-title { margin: 0 0 8px; font-size: 1.55rem; color: #e5efff; }
    .auth-sub { margin: 0 0 18px; color: var(--muted); font-size: 0.95rem; line-height: 1.45; }
    .auth-note {
      margin-top: 10px;
      color: #83a4d6;
      font-size: 0.78rem;
      line-height: 1.35;
    }
    .field { margin-bottom: 14px; }
    .field label { display: block; margin-bottom: 6px; color: var(--muted); font-size: 0.86rem; }
    input, select, button {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: #0c1528;
      color: var(--text);
      padding: 10px 12px;
      outline: none;
    }
    input:focus, select:focus { border-color: var(--brand); box-shadow: 0 0 0 2px rgba(53, 198, 255, 0.16); }
    button { cursor: pointer; font-weight: 600; transition: 0.2s ease; }
    .btn-primary { background: linear-gradient(180deg, #4ec5ff, #1e99ff); color: #041022; border: none; }
    .btn-primary:hover { transform: translateY(-1px); }
    .error { color: var(--bad); min-height: 20px; font-size: 0.9rem; margin-top: 8px; }
    .app { display: grid; grid-template-columns: 240px 1fr; min-height: 100vh; }
    .sidebar {
      background: #0c1526;
      border-right: 1px solid var(--line);
      padding: 18px;
      position: sticky;
      top: 0;
      height: 100vh;
    }
    .brand { font-size: 1.1rem; font-weight: 700; margin-bottom: 18px; color: #b7d2ff; }
    .nav-link {
      display: block;
      color: var(--muted);
      text-decoration: none;
      padding: 10px 12px;
      border-radius: 8px;
      margin-bottom: 6px;
    }
    .nav-link:hover { background: #14213a; color: var(--text); }
    .nav-link.active {
      background: linear-gradient(180deg, #1a2f54, #152746);
      color: #dce9ff;
      border: 1px solid #27406a;
    }
    .contact-btn {
      margin-top: 10px;
      display: block;
      width: 100%;
      text-align: center;
      text-decoration: none;
      border-radius: 10px;
      border: 1px solid #2d5e4d;
      background: linear-gradient(180deg, #2c8f6c, #216b50);
      color: #eafff6;
      padding: 10px 12px;
      font-weight: 600;
    }
    .contact-btn:hover { filter: brightness(1.06); }
    .logout-btn { margin-top: 16px; background: #1a243b; color: #f0f5ff; }
    .content { padding: 20px; display: grid; gap: 14px; }
    .topbar { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; }
    .chip {
      border: 1px solid var(--line);
      padding: 6px 10px;
      border-radius: 999px;
      color: var(--muted);
      font-size: 0.85rem;
      background: #0f1a2f;
    }
    .chip.block-chip {
      max-width: min(560px, 95vw);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .chip.block-chip.has-reason {
      border-color: rgba(191, 92, 110, 0.72);
      color: #ffd5dd;
      background: linear-gradient(180deg, #2a1723, #23131d);
    }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 14px; }
    .card {
      grid-column: span 12;
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
    }
    .card h3 { margin: 0 0 10px; font-size: 1rem; }
    .section-panel {
      display: none;
      animation: panelFade 0.2s ease;
    }
    .section-panel.active { display: block; }
    .row { display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px; }
    .col-2 { grid-column: span 2; }
    .col-3 { grid-column: span 3; }
    .col-4 { grid-column: span 4; }
    .col-5 { grid-column: span 5; }
    .col-6 { grid-column: span 6; }
    .col-8 { grid-column: span 8; }
    .col-12 { grid-column: span 12; }
    .status {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: #0f1a2d;
      min-height: 42px;
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--bad);
      box-shadow: 0 0 10px rgba(255, 95, 109, 0.7);
    }
    .dot.ok { background: var(--ok); box-shadow: 0 0 10px rgba(35, 209, 139, 0.8); }
    .hint { color: var(--muted); font-size: 0.85rem; }
    .btn-row { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .btn-start { background: #0f8f60; border-color: #0f8f60; }
    .btn-stop { background: #a33a45; border-color: #a33a45; }
    .btn-restart { background: #2853b3; border-color: #2853b3; }
    .btn-disconnect { background: linear-gradient(180deg, #ba5061, #8b3343); border-color: #8b3343; color: #fff2f4; }
    .btn-backend-connect { background: #1c6bb7; border-color: #1c6bb7; margin-top: 8px; }
    .btn-backend-disconnect { background: #8a2f3f; border-color: #8a2f3f; margin-top: 8px; }
    .backend-state { margin-top: 8px; }
    table {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid var(--line);
      border-radius: 10px;
      overflow: hidden;
      font-size: 0.9rem;
    }
    th, td {
      border-bottom: 1px solid var(--line);
      padding: 10px;
      text-align: left;
      white-space: nowrap;
    }
    tr.clickable-row { cursor: pointer; }
    tr.clickable-row:hover {
      background: rgba(63, 118, 199, 0.14);
    }
    thead { background: #0f1a2f; }
    .pnl-pos { color: var(--ok); }
    .pnl-neg { color: var(--bad); }
    .log-box {
      background: #0a1324;
      border: 1px solid var(--line);
      border-radius: 10px;
      height: 220px;
      overflow: auto;
      padding: 10px;
      font-family: Consolas, monospace;
      font-size: 0.85rem;
    }
    .log-line { margin: 0 0 6px; color: #aecdff; }
    .log-line .t { color: #7aa8ff; }
    .trigger-flow-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .trigger-flow-count {
      font-size: 0.85rem;
      color: #8ea2cc;
    }
    .btn-secondary {
      background: #18325a;
      border-color: #274776;
      color: #dce9ff;
    }
    .trigger-flow-line {
      color: #b6f4db;
    }
    .trigger-flow-line .t {
      color: #52cfa0;
    }
    .trigger-flow-badge {
      display: inline-block;
      min-width: 62px;
      margin-right: 7px;
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 0.73rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      text-align: center;
      border: 1px solid transparent;
    }
    .trigger-flow-badge.pending {
      color: #ffe9a8;
      background: rgba(191, 136, 16, 0.26);
      border-color: rgba(233, 180, 62, 0.48);
    }
    .trigger-flow-badge.blocked {
      color: #ffd2d8;
      background: rgba(172, 48, 70, 0.28);
      border-color: rgba(223, 96, 118, 0.52);
    }
    .trigger-flow-badge.success {
      color: #cafbe4;
      background: rgba(20, 119, 85, 0.28);
      border-color: rgba(58, 200, 147, 0.52);
    }
    .trigger-flow-badge.error {
      color: #ffe6bf;
      background: rgba(153, 81, 24, 0.30);
      border-color: rgba(232, 140, 60, 0.52);
    }
    .trigger-flow-badge.info {
      color: #d5e7ff;
      background: rgba(37, 83, 153, 0.30);
      border-color: rgba(106, 160, 238, 0.52);
    }
    .trigger-flow-line.trigger-flow-pending { color: #ffeec2; }
    .trigger-flow-line.trigger-flow-blocked { color: #ffd8de; }
    .trigger-flow-line.trigger-flow-success { color: #c9fbe3; }
    .trigger-flow-line.trigger-flow-error { color: #ffe8c9; }
    .trigger-flow-line.trigger-flow-info { color: #d9e8ff; }
    .trade-modal {
      position: fixed;
      inset: 0;
      z-index: 1200;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(3, 8, 16, 0.74);
      padding: 18px;
    }
    .trade-modal.show { display: flex; }
    .trade-modal-card {
      width: min(780px, 100%);
      border: 1px solid #36507d;
      border-radius: 14px;
      background: linear-gradient(180deg, #10203a, #0d1a31);
      box-shadow: 0 22px 44px rgba(0, 0, 0, 0.45);
      overflow: hidden;
    }
    .trade-modal-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px 14px;
      border-bottom: 1px solid #2b4168;
      background: #122746;
    }
    .trade-modal-title {
      margin: 0;
      font-size: 1rem;
      color: #e4efff;
    }
    .trade-modal-close {
      width: auto;
      min-width: 42px;
      border-radius: 8px;
      border: 1px solid #3e5f95;
      background: #173258;
      color: #dce9ff;
      padding: 6px 10px;
      cursor: pointer;
    }
    .trade-modal-body {
      padding: 12px 14px 14px;
    }
    .trade-modal-actions {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .trade-modal-modify {
      width: auto;
      border-radius: 8px;
      border: 1px solid #3f6aa7;
      background: linear-gradient(180deg, #2a63b8, #214e92);
      color: #eff6ff;
      padding: 8px 12px;
      font-weight: 600;
      cursor: pointer;
    }
    .trade-modal-modify[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .trade-modal-danger {
      width: auto;
      border-radius: 8px;
      border: 1px solid #8d3f4b;
      background: linear-gradient(180deg, #bf5566, #9a3f4f);
      color: #fff3f5;
      padding: 8px 12px;
      font-weight: 600;
      cursor: pointer;
    }
    .trade-modal-danger[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .trade-detail-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }
    .trade-detail-item {
      border: 1px solid #294269;
      border-radius: 10px;
      background: #0f1d34;
      padding: 8px;
    }
    .trade-detail-item .k {
      color: #97b3df;
      font-size: 0.76rem;
      margin-bottom: 3px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .trade-detail-item .v {
      color: #e3efff;
      font-size: 0.92rem;
      word-break: break-word;
    }
    #reportPanel {
      background:
        radial-gradient(980px 380px at -6% -22%, rgba(42, 128, 255, 0.16), transparent 62%),
        radial-gradient(860px 300px at 100% 116%, rgba(39, 178, 142, 0.12), transparent 64%),
        linear-gradient(180deg, #0e1b33, #0d172d);
    }
    .report-hero {
      border: 1px solid #304c78;
      border-radius: 12px;
      background: linear-gradient(130deg, rgba(23, 47, 88, 0.78), rgba(18, 36, 67, 0.72));
      padding: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
      box-shadow: inset 0 1px 0 rgba(170, 206, 255, 0.08);
    }
    .report-hero-kicker {
      margin: 0 0 4px;
      color: #9fc3f9;
      font-size: 0.72rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }
    .report-hero-title {
      margin: 0 0 3px;
      color: #e6f0ff;
      font-size: 1.02rem;
      font-weight: 700;
    }
    .report-hero-sub {
      margin: 0;
      color: #abc2e9;
      font-size: 0.82rem;
    }
    .report-generated-chip {
      border: 1px solid #31517f;
      background: #10213d;
      color: #cfe2ff;
      border-radius: 999px;
      padding: 7px 11px;
      font-size: 0.78rem;
      white-space: nowrap;
    }
    .report-actions {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 10px;
      margin-bottom: 12px;
      border: 1px solid #2b436c;
      border-radius: 12px;
      background: rgba(14, 30, 56, 0.7);
      padding: 10px;
    }
    .report-btns {
      display: flex;
      flex-wrap: wrap;
      align-items: end;
      gap: 8px;
    }
    .report-kpis {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 10px;
      margin-bottom: 12px;
    }
    .report-kpi {
      border: 1px solid #2f4f80;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(21, 40, 72, 0.86), rgba(14, 29, 54, 0.9));
      padding: 11px;
      box-shadow: inset 0 1px 0 rgba(164, 201, 255, 0.08);
    }
    .report-kpi .label {
      font-size: 0.75rem;
      color: #9eb8e2;
      margin-bottom: 5px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .report-kpi .value {
      font-size: 1.08rem;
      font-weight: 800;
      color: #e8f1ff;
    }
    .report-grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 10px;
    }
    .report-card {
      grid-column: span 6;
      border: 1px solid #2a436c;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(14, 28, 51, 0.95), rgba(11, 22, 42, 0.95));
      padding: 10px;
    }
    .report-card h4 {
      margin: 0 0 8px;
      color: #e0ecff;
      font-size: 0.92rem;
      letter-spacing: 0.02em;
      padding-bottom: 7px;
      border-bottom: 1px solid rgba(88, 123, 179, 0.35);
    }
    .report-list {
      max-height: 210px;
      overflow: auto;
      border: 1px solid #253d63;
      border-radius: 10px;
      background: #0b162d;
      padding: 4px 8px;
    }
    .report-list .row {
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: minmax(0, 1fr);
      gap: 8px;
      font-size: 0.82rem;
      color: #bfd3f4;
      padding: 6px 0;
      border-bottom: 1px solid rgba(121, 152, 211, 0.2);
      align-items: center;
    }
    .report-list .row.header {
      color: #e3eeff;
      font-weight: 700;
      border-bottom: 1px solid rgba(121, 152, 211, 0.38);
      position: sticky;
      top: 0;
      background: #0f1f3c;
      z-index: 1;
    }
    .report-list .row:last-child {
      border-bottom: none;
    }
    .report-wide {
      grid-column: span 12;
    }
    .report-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 10px;
    }
    .report-tab-btn {
      width: auto;
      border: 1px solid #35588b;
      background: #122546;
      color: #bfd5f8;
      border-radius: 10px;
      padding: 7px 11px;
      font-size: 0.82rem;
    }
    .report-tab-btn.active {
      border-color: #5f94df;
      background: #1a3561;
      color: #eff6ff;
    }
    .report-tab-panel {
      display: none;
      animation: panelFade 180ms ease;
    }
    .report-tab-panel.active {
      display: block;
    }
    .report-chart-box {
      min-height: 180px;
      border: 1px solid #253d63;
      border-radius: 10px;
      background: #0b162d;
      padding: 10px;
    }
    .report-chart-box svg {
      width: 100%;
      height: 100%;
      display: block;
    }
    .chart-controls {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 10px;
      margin-bottom: 12px;
    }
    .market-allow-row {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 10px;
      margin-bottom: 12px;
    }
    .btn-apply-markets {
      background: #1c6bb7;
      border-color: #1c6bb7;
    }
    .chart-tool-row {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid #d7deec;
      background: linear-gradient(180deg, #f8faff, #edf2fb);
      margin-bottom: 10px;
    }
    .tool-btn {
      width: 34px;
      min-width: 34px;
      height: 30px;
      padding: 0;
      border-radius: 7px;
      border: 1px solid transparent;
      background: #ffffff;
      color: #2f3a4d;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .tool-btn:hover {
      border-color: #b7c6e2;
      background: #f7faff;
    }
    .tool-btn svg {
      width: 18px;
      height: 18px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.8;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    .tool-btn.active {
      border-color: #87a5db;
      background: #dfeafc;
      color: #20355f;
    }
    .tool-btn-clear {
      width: auto;
      min-width: 0;
      height: auto;
      padding: 7px 10px;
      margin-left: 10px;
      border: 1px solid #2f4b77;
      background: #142744;
      color: #cde2ff;
      font-size: 0.82rem;
      border-radius: 8px;
      vertical-align: top;
    }
    .view-btn-row {
      display: inline-flex;
      gap: 8px;
      margin-left: 8px;
      vertical-align: top;
    }
    .view-btn {
      width: auto;
      min-width: 36px;
      padding: 7px 10px;
      border-radius: 8px;
      border: 1px solid #2f4b77;
      background: #132341;
      color: #d2e7ff;
      font-size: 0.82rem;
    }
    .view-btn.active {
      border-color: #4b8bff;
      background: #1d3760;
      color: #f2f7ff;
    }
    .chart-wrap {
      border: 1px solid var(--line);
      background: #0a1324;
      border-radius: 10px;
      padding: 10px;
    }
    #marketChart {
      width: 100%;
      height: 520px;
      display: block;
      touch-action: none;
      cursor: crosshair;
      border-radius: 8px;
    }
    #chartMeta {
      margin-top: 8px;
      color: var(--muted);
      font-size: 0.88rem;
    }
    .chart-actions {
      margin-top: 12px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .manual-ticket {
      margin-top: 12px;
      border: 1px solid #2b3e60;
      border-radius: 10px;
      background: #0d1830;
      padding: 10px;
    }
    .manual-ticket-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    .manual-guard-pill {
      border: 1px solid #7a3540;
      background: #2a1620;
      color: #ffd4db;
      border-radius: 999px;
      padding: 4px 9px;
      font-size: 0.78rem;
      font-weight: 600;
    }
    .manual-guard-pill.ok {
      border-color: #1f6f50;
      background: #112a20;
      color: #b8f9da;
    }
    .manual-grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 10px;
      margin-bottom: 10px;
    }
    .manual-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .unit-field {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px;
    }
    .unit-field select {
      width: 104px;
      min-width: 104px;
    }
    .btn-buy {
      width: auto;
      border: 1px solid #1b7b54;
      background: linear-gradient(180deg, #16a36b, #117f54);
      color: #e9fff6;
      padding: 10px 14px;
      border-radius: 10px;
    }
    .btn-sell {
      width: auto;
      border: 1px solid #8a3343;
      background: linear-gradient(180deg, #be4c5f, #923a49);
      color: #fff2f4;
      padding: 10px 14px;
      border-radius: 10px;
    }
    .btn-buy:disabled, .btn-sell:disabled, .btn-close-trade:disabled {
      opacity: 0.48;
      cursor: not-allowed;
      filter: grayscale(0.1);
    }
    .field-hidden {
      display: none !important;
    }
    .insight-grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 10px;
      margin-top: 12px;
    }
    .insight-card {
      grid-column: span 6;
      border: 1px solid #2b3e60;
      border-radius: 10px;
      padding: 10px;
      background: #0e1a31;
    }
    .insight-title {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .insight-value {
      font-size: 1.2rem;
      font-weight: 700;
      line-height: 1.2;
      margin-bottom: 4px;
    }
    .insight-pos { color: var(--ok); }
    .insight-neg { color: var(--bad); }
    .insight-meta {
      font-size: 0.82rem;
      color: #b8cbef;
      line-height: 1.4;
      white-space: pre-line;
    }
    .tag-stats-card {
      grid-column: span 12;
      border: 1px solid #2b3e60;
      border-radius: 10px;
      padding: 10px;
      background: #0e1a31;
    }
    .analytics-card {
      grid-column: span 12;
      border: 1px solid #2b3e60;
      border-radius: 10px;
      padding: 10px;
      background: #0e1a31;
    }
    .analytics-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .analytics-top {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
      margin-bottom: 8px;
    }
    .analytics-mini {
      border: 1px solid #2a3a58;
      border-radius: 8px;
      padding: 8px;
      background: #12203a;
    }
    .analytics-mini .label {
      font-size: 0.74rem;
      color: #95aed8;
      margin-bottom: 3px;
    }
    .analytics-mini .value {
      font-size: 1rem;
      font-weight: 700;
      color: #e4efff;
    }
    .analytics-list {
      border: 1px solid #2b3e60;
      border-radius: 8px;
      max-height: 150px;
      overflow: auto;
    }
    .analytics-row {
      display: grid;
      grid-template-columns: 1.8fr 0.7fr 1fr;
      gap: 8px;
      padding: 7px 8px;
      border-bottom: 1px solid #233553;
      font-size: 0.8rem;
      color: #c7d9fb;
      align-items: center;
    }
    .analytics-row:last-child { border-bottom: none; }
    .analytics-row.header {
      background: #132542;
      color: #9fbce8;
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .watchdog-alert {
      margin-top: 8px;
      border: 1px solid #2e4369;
      border-radius: 8px;
      padding: 8px;
      background: #0f1d35;
      color: #c8dbff;
      font-size: 0.8rem;
      white-space: pre-line;
    }
    .watchdog-alert.bad {
      border-color: #7a3540;
      background: #271620;
      color: #ffd4db;
    }
    .tag-stats-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .tag-stats-head .hint {
      margin: 0;
      font-size: 0.78rem;
    }
    .tag-stats-table {
      max-height: 170px;
      overflow: auto;
      border: 1px solid #2b3e60;
      border-radius: 8px;
    }
    .tag-stats-row {
      display: grid;
      grid-template-columns: 1.8fr 0.6fr 0.6fr 0.6fr 1fr;
      gap: 8px;
      padding: 7px 8px;
      border-bottom: 1px solid #233553;
      font-size: 0.8rem;
      color: #c7d9fb;
      align-items: center;
    }
    .tag-stats-row:last-child { border-bottom: none; }
    .tag-stats-row.header {
      position: sticky;
      top: 0;
      z-index: 1;
      background: #132542;
      color: #9fbce8;
      font-weight: 600;
    }
    .tag-status {
      justify-self: start;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #32537e;
      font-size: 0.72rem;
      white-space: nowrap;
    }
    .tag-status.active {
      border-color: #1f6f50;
      color: #9effd3;
      background: rgba(35, 209, 139, 0.14);
    }
    .tag-status.paused {
      border-color: #7a4f24;
      color: #ffd8a6;
      background: rgba(255, 180, 84, 0.14);
    }
    .btn-close-trade {
      width: auto;
      padding: 10px 14px;
      border: 1px solid #7f3240;
      background: linear-gradient(180deg, #b14656, #8b3343);
      color: #ffeef1;
      border-radius: 10px;
    }
    .symbol-jump {
      width: auto;
      padding: 2px 6px;
      border: 1px solid #2f4f83;
      background: #132341;
      color: #a9d4ff;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.84rem;
    }
    .symbol-jump:hover {
      background: #173159;
      color: #dcefff;
    }
    @keyframes panelFade {
      from { opacity: 0; transform: translateY(3px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @media (max-width: 980px) {
      .app { grid-template-columns: 1fr; }
      .sidebar { position: static; height: auto; }
      .col-2, .col-3, .col-4, .col-5, .col-6, .col-8 { grid-column: span 12; }
      .btn-row { grid-template-columns: 1fr; }
      .insight-card { grid-column: span 12; }
      .report-kpis { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .report-card { grid-column: span 12; }
      .report-hero { flex-direction: column; align-items: flex-start; }
      #marketChart { height: min(60vh, 520px); }
      .lock-shell { grid-template-columns: 1fr; max-width: 520px; }
      .lock-brand { order: 2; }
      .auth-card { order: 1; }
      .trade-detail-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    @supports (-webkit-touch-callout: none) {
      body { -webkit-text-size-adjust: 100%; }
      .chart-wrap {
        border-radius: 12px;
        padding: 8px;
      }
      .chart-tool-row {
        width: 100%;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        white-space: nowrap;
      }
      #marketChart {
        height: min(64vh, 620px);
        cursor: default;
        -webkit-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
      }
      .view-btn, .tool-btn {
        min-height: 34px;
      }
      .trade-detail-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <section id="lockScreen" class="lock-screen">
    <div class="lock-shell">
      <div class="lock-brand">
        <p class="lock-kicker">EA CONTROL TERMINAL</p>
        <h2>ForceX + KutEA26 Dashboard</h2>
        <p>Secure access for broker operations, live execution telemetry, market-structure overlays, and trade control from one panel.</p>
        <div class="lock-pills">
          <span>Live MT5 Bridge</span>
          <span>Session P/L Tracking</span>
          <span>Structure + FVG Feed</span>
        </div>
      </div>
      <div class="auth-card">
        <div class="auth-mark"></div>
        <h1 class="auth-title">KutEA26 Access</h1>
        <p class="auth-sub">Authenticate to open your EA control dashboard.</p>
        <form id="loginForm" autocomplete="off">
          <div class="field">
            <label for="username">Username</label>
            <input id="username" type="text" required />
          </div>
          <div class="field">
            <label for="password">Password</label>
            <input id="password" type="password" required />
          </div>
          <button class="btn-primary" type="submit">Login</button>
        </form>
        <div id="authError" class="error"></div>
        <div class="auth-note">Session stays local to your browser and expires automatically.</div>
      </div>
    </div>
  </section>

  <main id="app" class="app hidden">
    <aside class="sidebar">
      <div class="brand">KutEA26 Dashboard</div>
      <a class="nav-link" href="#brokerPanel" data-target="brokerPanel">Broker Connection</a>
      <a class="nav-link" href="#uploadPanel" data-target="uploadPanel">Upload & Settings</a>
      <a class="nav-link" href="#controlPanel" data-target="controlPanel">EA Control</a>
      <a class="nav-link" href="#marketPanel" data-target="marketPanel">Market Chart</a>
      <a class="nav-link" href="#livePanel" data-target="livePanel">Live Transactions</a>
      <a class="nav-link" href="#historyPanel" data-target="historyPanel">History</a>
      <a class="nav-link" href="#reportPanel" data-target="reportPanel">Reports</a>
      <a class="nav-link" href="#logPanel" data-target="logPanel">System Log</a>
      <a class="nav-link" href="#triggerFlowPanel" data-target="triggerFlowPanel">Trigger Flow</a>
      <a id="contactAdminBtn" class="contact-btn" href="https://t.me/KutMilz876" target="_blank" rel="noopener noreferrer">Contact Admin</a>
      <button id="logoutBtn" class="logout-btn">Logout</button>
    </aside>

    <section class="content">
      <div class="topbar">
        <div class="chip">EA: KutEA26</div>
        <div class="chip" id="balanceChip">Balance: 0.00</div>
        <div class="chip" id="equityChip">Equity: 0.00</div>
        <div class="chip" id="sessionPnlChip">Session P/L: 0.00</div>
        <div class="chip" id="botModeChip">Bot: IDLE</div>
        <div class="chip" id="supervisorChip">Supervisor: --</div>
        <div class="chip block-chip" id="blockReasonChip" title="Last entry block reason">Last Block: --</div>
        <div class="chip" id="runStateChip">Engine: Idle</div>
      </div>

      <div class="grid">
        <article id="brokerPanel" class="card section-panel">
          <h3>Broker Connection Panel</h3>
          <div class="row">
            <div class="col-4">
              <label class="hint">Backend API URL</label>
              <input id="apiBase" type="text" value="http://127.0.0.1:8787" />
              <button id="backendApiBtn" class="btn-backend-connect" type="button">Connect Backend</button>
              <div id="backendApiStatus" class="hint backend-state">Backend: Disconnected</div>
            </div>
            <div class="col-4">
              <label class="hint">Select Broker</label>
              <select id="brokerSelect">
                <option value="">-- Select --</option>
                <option value="Deriv">Deriv</option>
                <option value="MetaTrader5">MetaTrader5</option>
              </select>
            </div>
            <div class="col-4">
              <label class="hint">Compatibility</label>
              <div id="compatibilityLabel" class="status">Broker accepted by MetaTrader5</div>
            </div>
            <div class="col-4">
              <label class="hint">Broker Account Login</label>
              <input id="brokerLogin" type="text" placeholder="e.g. 12345678" />
            </div>
            <div class="col-4">
              <label class="hint">Broker Password</label>
              <input id="brokerPassword" type="password" placeholder="Broker password" />
            </div>
            <div class="col-4">
              <label class="hint">Broker Server</label>
              <input id="brokerServer" type="text" placeholder="e.g. Deriv-Server" />
            </div>
            <div class="col-6">
              <label class="hint">MT5 Terminal Path (Optional)</label>
              <input id="brokerTerminalPath" type="text" placeholder="C:\\Program Files\\MetaTrader 5\\terminal64.exe" />
            </div>
            <div class="col-4">
              <label class="hint">Status</label>
              <div class="status"><span id="brokerDot" class="dot"></span><span id="brokerStatus">Disconnected</span></div>
            </div>
            <div class="col-4">
              <button id="connectBtn" class="btn-primary" type="button">Connect Broker</button>
            </div>
          </div>
        </article>

        <article id="uploadPanel" class="card section-panel">
          <h3>Upload EA (.ex5/.mq5) + Dynamic Settings</h3>
          <div class="row">
            <div class="col-6">
              <label class="hint">Upload File</label>
              <input id="mq5File" type="file" accept=".ex5,.mq5" />
            </div>
            <div class="col-6">
              <label class="hint">Loaded File</label>
              <div id="fileName" class="status">No file loaded</div>
            </div>
            <div class="col-6">
              <label class="hint">Upload .set (after EA file)</label>
              <input id="setFile" type="file" accept=".set" disabled />
            </div>
            <div class="col-6">
              <label class="hint">Loaded .set</label>
              <div id="setFileName" class="status">No .set loaded</div>
            </div>
            <div class="col-12 hint">Upload <code>.ex5</code> or <code>.mq5</code>. For full dynamic input parsing, upload <code>.mq5</code> at least once.</div>
          </div>
          <hr style="border-color: var(--line); opacity: .5"/>
          <div id="settingsPanel" class="row"></div>
        </article>

        <article id="controlPanel" class="card section-panel">
          <h3>EA Control Panel</h3>
          <div class="btn-row">
            <button id="startBtn" class="btn-start" type="button">Start EA</button>
            <button id="stopBtn" class="btn-stop" type="button">Stop EA</button>
            <button id="restartBtn" class="btn-restart" type="button">Restart EA</button>
          </div>
          <div class="insight-grid">
            <div class="insight-card">
              <div class="insight-title">Session P/L</div>
              <div id="sessionPnlValue" class="insight-value">0.00</div>
              <div id="sessionPnlMeta" class="insight-meta">Realized: 0.00 | Floating: 0.00 | Trades: 0</div>
            </div>
            <div class="insight-card">
              <div class="insight-title">Bot Activity</div>
              <div id="botThinkingValue" class="insight-value">Idle</div>
              <div id="botActivityMeta" class="insight-meta">Active: None
Waiting: Connect broker and start EA
Mode: IDLE</div>
            </div>
            <div class="analytics-card">
              <div class="analytics-head">
                <div class="insight-title" style="margin:0;">Analytics + Watchdog</div>
                <p id="analyticsUpdated" class="hint">No analytics yet</p>
              </div>
              <div class="analytics-top">
                <div class="analytics-mini">
                  <div class="label">Win Rate (7d)</div>
                  <div id="analyticsWinRateValue" class="value">0.00%</div>
                </div>
                <div class="analytics-mini">
                  <div class="label">Total P/L (7d)</div>
                  <div id="analyticsPnlValue" class="value">0.00</div>
                </div>
                <div class="analytics-mini">
                  <div class="label">Trades (7d)</div>
                  <div id="analyticsTradesValue" class="value">0</div>
                </div>
              </div>
              <div id="analyticsSymbols" class="analytics-list">
                <div class="analytics-row header"><span>Symbol</span><span>Trades</span><span>P/L</span></div>
                <div class="analytics-row"><span>Waiting for analytics...</span><span>0</span><span>0.00</span></div>
              </div>
              <div id="watchdogAlertBox" class="watchdog-alert">Watchdog: waiting for status...</div>
            </div>
            <div class="tag-stats-card">
              <div class="tag-stats-head">
                <div class="insight-title" style="margin:0;">Setup Tag Stats</div>
                <p id="tagStatsUpdated" class="hint">No telemetry yet</p>
                <p id="tagStatsSummary" class="hint">Active: 0 | Paused: 0</p>
              </div>
              <div id="tagStatsTable" class="tag-stats-table">
                <div class="tag-stats-row header">
                  <span>Tag</span>
                  <span>S</span>
                  <span>W</span>
                  <span>L</span>
                  <span>Status</span>
                </div>
              </div>
            </div>
          </div>
        </article>

        <article id="marketPanel" class="card section-panel">
          <h3>Market Chart</h3>
          <div class="chart-controls">
            <div class="col-6">
              <label class="hint">Selected Market Symbol</label>
              <select id="chartSymbol">
                <option value="">No symbols yet</option>
              </select>
            </div>
            <div class="col-3">
              <label class="hint">Timeframe</label>
              <select id="chartTf">
                <option value="M1">M1</option>
                <option value="M5">M5</option>
                <option value="M15">M15</option>
                <option value="M30">M30</option>
                <option value="H1">H1</option>
              </select>
            </div>
            <div class="col-3">
              <label class="hint">Data Source</label>
              <div class="status">MT5 candles since EA start</div>
            </div>
          </div>
          <div class="market-allow-row">
            <div class="col-4">
              <label class="hint">Allowed Market 1</label>
              <input id="allowedSymbol1" type="text" value="Volatility 75 Index" placeholder="e.g. Volatility 75 Index" />
            </div>
            <div class="col-4">
              <label class="hint">Allowed Market 2</label>
              <input id="allowedSymbol2" type="text" value="Volatility 75 (1s) Index" placeholder="e.g. Volatility 75 (1s) Index" />
            </div>
            <div class="col-4">
              <label class="hint">Apply Allowed Markets</label>
              <button id="applySymbolsBtn" class="btn-apply-markets" type="button">Apply Markets</button>
            </div>
          </div>
          <div class="chart-tool-row">
            <button id="toolRect" class="tool-btn" type="button" title="Rectangle">
              <svg viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16"/><circle cx="4" cy="4" r="1.5"/><circle cx="20" cy="4" r="1.5"/><circle cx="4" cy="20" r="1.5"/><circle cx="20" cy="20" r="1.5"/></svg>
            </button>
            <button id="toolTrend" class="tool-btn" type="button" title="Trend Line">
              <svg viewBox="0 0 24 24"><circle cx="5" cy="19" r="1.5"/><circle cx="19" cy="5" r="1.5"/><path d="M6.5 17.5L17.5 6.5"/></svg>
            </button>
            <button id="toolPoly" class="tool-btn" type="button" title="Polyline">
              <svg viewBox="0 0 24 24"><circle cx="4" cy="16" r="1.5"/><circle cx="11" cy="8" r="1.5"/><circle cx="20" cy="14" r="1.5"/><path d="M5.5 14.8L9.8 9.4L18.5 12.8"/></svg>
            </button>
            <button id="toolHLine" class="tool-btn" type="button" title="Horizontal Line">
              <svg viewBox="0 0 24 24"><path d="M4 12H20"/><circle cx="4" cy="12" r="1.5"/><circle cx="20" cy="12" r="1.5"/></svg>
            </button>
            <button id="toolLong" class="tool-btn" type="button" title="Long Position">
              <svg viewBox="0 0 24 24"><path d="M4 17H20M4 11H20M4 5H20"/><path d="M18 9l2 2-2 2"/><path d="M6 7l-2-2 2-2"/></svg>
            </button>
            <button id="toolShort" class="tool-btn" type="button" title="Short Position">
              <svg viewBox="0 0 24 24"><path d="M4 17H20M4 11H20M4 5H20"/><path d="M6 13l-2-2 2-2"/><path d="M18 15l2 2-2 2"/></svg>
            </button>
          </div>
          <button id="toolClear" class="tool-btn tool-btn-clear" type="button" title="Clear Drawings">Clear Drawings</button>
          <div class="view-btn-row">
            <button id="zoomInBtn" class="view-btn" type="button" title="Zoom In">+</button>
            <button id="zoomOutBtn" class="view-btn" type="button" title="Zoom Out">-</button>
            <button id="resetViewBtn" class="view-btn" type="button" title="Reset View">Reset</button>
            <button id="autoScaleBtn" class="view-btn" type="button" title="Auto-Scale to Current Price">Auto-Scale</button>
            <button id="freeMoveBtn" class="view-btn" type="button" title="Toggle Free Chart Movement">Free Move: Off</button>
          </div>
          <div class="chart-wrap">
            <canvas id="marketChart"></canvas>
            <div id="chartMeta">Waiting for market data...</div>
          </div>
          <div class="chart-actions">
            <button id="closeTradeBtn" class="btn-close-trade" type="button">Close Trade (Selected Symbol)</button>
            <button id="dispatchAutomationBtn" class="btn-secondary" type="button">Dispatch MT5 Auto-Attach Command</button>
          </div>
          <div class="manual-ticket">
            <div class="manual-ticket-head">
              <h4 style="margin:0;">Manual Order Ticket</h4>
              <div id="manualGuardPill" class="manual-guard-pill">Manual Trade: OFF</div>
            </div>
            <div class="manual-grid">
              <div class="col-3">
                <label class="hint">Trigger Flow Mode</label>
                <select id="triggerFlowMode">
                  <option value="BOTH">Both Sides</option>
                  <option value="AUTO">Auto Bias</option>
                  <option value="BUY_ONLY">Buy Only</option>
                  <option value="SELL_ONLY">Sell Only</option>
                </select>
              </div>
              <div class="col-3">
                <label class="hint">Manual Trade Mode</label>
                <select id="manualTradeMode">
                  <option value="off">Off</option>
                  <option value="on">On</option>
                </select>
              </div>
              <div class="col-3">
                <label class="hint">Order Type</label>
                <select id="manualOrderType">
                  <option value="MARKET_EXECUTION">Market Execution</option>
                  <option value="BUY_LIMIT">Buy Limit</option>
                  <option value="SELL_LIMIT">Sell Limit</option>
                  <option value="BUY_STOP">Buy Stop</option>
                  <option value="SELL_STOP">Sell Stop</option>
                  <option value="BUY_STOP_LIMIT">Buy Stop Limit</option>
                  <option value="SELL_STOP_LIMIT">Sell Stop Limit</option>
                </select>
              </div>
              <div class="col-3">
                <label class="hint">Lot Size</label>
                <input id="manualVolume" type="number" min="0.01" step="0.01" value="0.20" />
              </div>
              <div id="manualPriceWrap" class="col-3 field-hidden">
                <label class="hint">Entry Price (Required)</label>
                <input id="manualPrice" type="number" step="0.00001" placeholder="Order price" />
              </div>
              <div id="manualStopLimitWrap" class="col-3 field-hidden">
                <label class="hint">Stop Limit Price (Required)</label>
                <input id="manualStopLimitPrice" type="number" step="0.00001" placeholder="Stop limit trigger price" />
              </div>
              <div class="col-3">
                <label class="hint">Stop Loss (Optional)</label>
                <div class="unit-field">
                  <input id="manualSl" type="text" placeholder="e.g. $29 or 19 or 467283.90" />
                  <select id="manualSlMode">
                    <option value="PRICE">Price</option>
                    <option value="PIPS">Pips</option>
                    <option value="USD">USD</option>
                  </select>
                </div>
              </div>
              <div class="col-3">
                <label class="hint">Take Profit (Optional)</label>
                <div class="unit-field">
                  <input id="manualTp" type="text" placeholder="e.g. $29 or 19 or 467283.90" />
                  <select id="manualTpMode">
                    <option value="PRICE">Price</option>
                    <option value="PIPS">Pips</option>
                    <option value="USD">USD</option>
                  </select>
                </div>
              </div>
              <div class="col-3">
                <label class="hint">Comment</label>
                <input id="manualComment" type="text" maxlength="31" placeholder="KutEA26 manual" />
              </div>
            </div>
            <div class="manual-actions">
              <button id="manualBuyBtn" class="btn-buy" type="button" disabled>Buy</button>
              <button id="manualSellBtn" class="btn-sell" type="button" disabled>Sell</button>
              <span class="hint">Buttons stay locked until Manual Trade Mode is ON.</span>
            </div>
          </div>
        </article>

        <article id="livePanel" class="card section-panel">
          <h3>Live Transactions</h3>
          <div style="overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th>Trade ID</th>
                  <th>Symbol</th>
                  <th>Side</th>
                  <th>Lot Size</th>
                  <th>Entry Price</th>
                  <th>Current Price</th>
                  <th>SL</th>
                  <th>TP</th>
                  <th>Profit/Loss</th>
                  <th>Status</th>
                </tr>
              </thead>
              <tbody id="liveBody"></tbody>
            </table>
          </div>
        </article>

        <article id="historyPanel" class="card section-panel">
          <h3>Transaction History Log</h3>
          <div style="overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th>Trade ID</th>
                  <th>Pos ID</th>
                  <th>Symbol</th>
                  <th>Side</th>
                  <th>Lot</th>
                  <th>Entry</th>
                  <th>Exit</th>
                  <th>Profit/Loss</th>
                  <th>Reason</th>
                  <th>Close Time</th>
                </tr>
              </thead>
              <tbody id="historyBody"></tbody>
            </table>
          </div>
        </article>
        <article id="reportPanel" class="card section-panel">
          <h3>Reports</h3>
          <div class="report-hero">
            <div>
              <p class="report-hero-kicker">Analytics Console</p>
              <p class="report-hero-title">Performance Intelligence</p>
              <p class="report-hero-sub">Live strengths, weaknesses, and execution quality from your EA history.</p>
            </div>
            <div id="reportGenerated" class="report-generated-chip">No report yet</div>
          </div>
          <div class="report-actions">
            <div class="col-3">
              <label class="hint">Window (Days)</label>
              <input id="reportDays" type="number" min="1" max="3650" value="30" />
            </div>
            <div class="col-8 report-btns">
              <button id="refreshReportBtn" class="btn-secondary" type="button">Refresh Report</button>
              <button id="exportReportJsonBtn" class="btn-secondary" type="button">Export JSON</button>
              <button id="exportReportCsvBtn" class="btn-secondary" type="button">Export CSV</button>
            </div>
          </div>
          <div class="report-kpis">
            <div class="report-kpi"><div class="label">Total P/L</div><div id="reportTotalPnl" class="value">0.00</div></div>
            <div class="report-kpi"><div class="label">Win Rate</div><div id="reportWinRate" class="value">0.00%</div></div>
            <div class="report-kpi"><div class="label">Trades</div><div id="reportTrades" class="value">0</div></div>
            <div class="report-kpi"><div class="label">Latest Day P/L</div><div id="reportDailyPnl" class="value">0.00</div></div>
            <div class="report-kpi"><div class="label">Latest Week P/L</div><div id="reportWeeklyPnl" class="value">0.00</div></div>
          </div>
          <div class="report-tabs">
            <button class="report-tab-btn active" data-report-tab="summary" type="button">Summary</button>
            <button class="report-tab-btn" data-report-tab="pnl" type="button">Profit &amp; Loss</button>
            <button class="report-tab-btn" data-report-tab="sides" type="button">Long &amp; Short</button>
            <button class="report-tab-btn" data-report-tab="symbols" type="button">Symbols</button>
            <button class="report-tab-btn" data-report-tab="risks" type="button">Risks</button>
          </div>
          <div id="reportTabSummary" class="report-tab-panel active">
            <div class="report-grid">
              <div class="report-card report-wide">
                <h4>Balance/Equity Curve</h4>
                <div id="reportCurveSummary" class="report-chart-box"></div>
              </div>
              <div class="report-card">
                <h4>What Is Strong</h4>
                <div id="reportStrengths" class="report-list"></div>
              </div>
              <div class="report-card">
                <h4>What Is Weak</h4>
                <div id="reportWeaknesses" class="report-list"></div>
              </div>
              <div class="report-card">
                <h4>Daily Breakdown</h4>
                <div id="reportByDay" class="report-list"></div>
              </div>
              <div class="report-card">
                <h4>Weekly Breakdown</h4>
                <div id="reportByWeek" class="report-list"></div>
              </div>
              <div class="report-card report-wide">
                <h4>EA Closed Trades (Recent)</h4>
                <div id="reportEaTrades" class="report-list"></div>
              </div>
            </div>
          </div>
          <div id="reportTabPnl" class="report-tab-panel">
            <div class="report-grid">
              <div class="report-card report-wide">
                <h4>Daily P/L Histogram</h4>
                <div id="reportPnlBars" class="report-chart-box"></div>
              </div>
              <div class="report-card report-wide">
                <h4>Recent Deals (P/L)</h4>
                <div id="reportRecentDeals" class="report-list"></div>
              </div>
            </div>
          </div>
          <div id="reportTabSides" class="report-tab-panel">
            <div class="report-grid">
              <div class="report-card">
                <h4>Long vs Short Split</h4>
                <div id="reportLongShortSplit" class="report-chart-box"></div>
              </div>
              <div class="report-card">
                <h4>Side Quality</h4>
                <div id="reportSideQuality" class="report-list"></div>
              </div>
            </div>
          </div>
          <div id="reportTabSymbols" class="report-tab-panel">
            <div class="report-grid">
              <div class="report-card report-wide">
                <h4>Symbol Performance</h4>
                <div id="reportSymbolBars" class="report-chart-box"></div>
              </div>
            </div>
          </div>
          <div id="reportTabRisks" class="report-tab-panel">
            <div class="report-grid">
              <div class="report-card">
                <h4>Risk Metrics</h4>
                <div id="reportRiskStats" class="report-list"></div>
              </div>
              <div class="report-card">
                <h4>Drawdown Curve</h4>
                <div id="reportDrawdownCurve" class="report-chart-box"></div>
              </div>
            </div>
          </div>
        </article>

        <article id="logPanel" class="card section-panel">
          <h3>System Log Panel</h3>
          <div id="systemLog" class="log-box"></div>
        </article>
        <article id="triggerFlowPanel" class="card section-panel">
          <h3>Trigger Flow Panel</h3>
          <div class="trigger-flow-head">
            <div id="triggerFlowCount" class="trigger-flow-count">0 events</div>
            <button id="clearTriggerFlowBtn" class="btn-secondary" type="button">Clear Trigger Flow</button>
          </div>
          <div id="triggerFlowLog" class="log-box"></div>
        </article>
      </div>
    </section>
  </main>

  <div id="tradeDetailModal" class="trade-modal" aria-hidden="true">
    <div class="trade-modal-card">
      <div class="trade-modal-head">
        <h3 id="tradeDetailTitle" class="trade-modal-title">Trade Details</h3>
        <button id="tradeDetailCloseBtn" class="trade-modal-close" type="button">Close</button>
      </div>
      <div class="trade-modal-body">
        <div id="tradeDetailGrid" class="trade-detail-grid"></div>
        <div class="trade-modal-actions">
          <button id="tradeDetailModifyBtn" class="trade-modal-modify" type="button">Modify SL/TP On Chart</button>
          <button id="tradeDetailSetSlBtn" class="trade-modal-modify" type="button">Set/Adjust SL</button>
          <button id="tradeDetailSetTpBtn" class="trade-modal-modify" type="button">Set/Adjust TP</button>
          <button id="tradeDetailCloseTradeBtn" class="trade-modal-danger" type="button">Close Trade</button>
          <span id="tradeDetailModifyHint" class="hint">Choose an active trade to drag SL/TP handles on Market Chart.</span>
        </div>
      </div>
    </div>
  </div>

  <script src="./kutea26_memory.js"></script>
  <script>
    // Real-mode dashboard with backend bridge.
    const bus = new EventTarget();
    const state = {
      authenticated: false,
      connected: false,
      mq5Loaded: false,
      eaRunning: false,
      backendApiOnline: false,
      apiSessionToken: "",
      settings: {},
      parameters: [],
      trades: [],
      history: [],
      marketCandles: {},
      marketStructure: {},
      memoryLearning: {},
      chartTf: "M1",
      chartTool: "none",
      chartPendingPoint: null,
      chartPendingPoints: [],
      chartDrawings: {},
      chartViewport: null,
      chartDragStart: null,
      chartDragCurrent: null,
      chartHover: null,
      chartPointerDown: false,
      chartPointerId: null,
      chartVisibleCount: 150,
      chartPanBars: 0,
      chartYZoom: 1,
      chartYShift: 0,
      chartTotalCount: 0,
      chartPanMode: false,
      chartPanStartX: 0,
      chartPanStartY: 0,
      chartPanStartBars: 0,
      chartPanStartYShift: 0,
      chartScaleMode: false,
      chartScaleStartY: 0,
      chartScaleStartZoom: 1,
      chartPointerSamples: {},
      chartPinchMode: false,
      chartPinchStartDist: 0,
      chartPinchStartCenterX: 0,
      chartPinchStartCenterY: 0,
      chartPinchStartVisible: 150,
      chartPinchStartYZoom: 1,
      chartPinchStartPanBars: 0,
      chartPinchStartYShift: 0,
      chartPositionDraft: null,
      selectedDrawingIndex: -1,
      chartFreeMove: false,
      sessionInsight: {
        session: { realized: 0, floating: 0, total: 0, trades: 0, wins: 0, losses: 0 },
        bot_state: { mode: "IDLE", thinking: "Idle", waiting_for: "Connect broker and start EA", active: "None" },
        supervisor: null,
        tag_stats: [],
        tag_stats_updated_at: null
      },
      supervisorStatus: null,
      lastSupervisorSignature: "",
      preferredSymbol: "",
      selectedSymbol: "",
      allowedSymbols: [],
      activePanel: "brokerPanel",
      seenLogs: new Set(),
      poller: null,
      memoryPersistTimer: null,
      accountSnapshot: {},
      analyticsSummary: null,
      watchdogStatus: null,
      analyticsLastFetchMs: 0,
      reportSummary: null,
      reportLastFetchMs: 0,
      reportTab: "summary",
      manualTradeEnabled: false,
      triggerFlowMode: "BOTH",
      liveTradeEditDraft: null,
      tradeDetailModalOpen: false,
      liveTradeDragX: null,
      liveTradeDragY: null,
      quickModifyTicket: 0,
      tradeDetailContext: null,
      lastBlockReason: "",
      lastBlockAt: ""
    };

    const memory = (typeof window !== "undefined" && window.KutEA26Memory) ? window.KutEA26Memory : null;
    const MAX_LOCAL_BARS = memory && Number.isFinite(Number(memory.MAX_BARS)) ? Math.max(320, Number(memory.MAX_BARS)) : 12500;

    // Login logic.
    const USERNAME = "KutEA26";
    const PASS_HASH = "68a242c130a1c9254dbd2bb44ab18d787c40dc13eae775b103e086ccf17ce3a3"; // "$money"

    const el = {
      lockScreen: document.getElementById("lockScreen"),
      app: document.getElementById("app"),
      loginForm: document.getElementById("loginForm"),
      username: document.getElementById("username"),
      password: document.getElementById("password"),
      authError: document.getElementById("authError"),
      apiBase: document.getElementById("apiBase"),
      backendApiBtn: document.getElementById("backendApiBtn"),
      backendApiStatus: document.getElementById("backendApiStatus"),
      brokerSelect: document.getElementById("brokerSelect"),
      brokerLogin: document.getElementById("brokerLogin"),
      brokerPassword: document.getElementById("brokerPassword"),
      brokerServer: document.getElementById("brokerServer"),
      brokerTerminalPath: document.getElementById("brokerTerminalPath"),
      connectBtn: document.getElementById("connectBtn"),
      compatibilityLabel: document.getElementById("compatibilityLabel"),
      brokerDot: document.getElementById("brokerDot"),
      brokerStatus: document.getElementById("brokerStatus"),
      mq5File: document.getElementById("mq5File"),
      setFile: document.getElementById("setFile"),
      fileName: document.getElementById("fileName"),
      setFileName: document.getElementById("setFileName"),
      settingsPanel: document.getElementById("settingsPanel"),
      startBtn: document.getElementById("startBtn"),
      stopBtn: document.getElementById("stopBtn"),
      restartBtn: document.getElementById("restartBtn"),
      balanceChip: document.getElementById("balanceChip"),
      equityChip: document.getElementById("equityChip"),
      sessionPnlChip: document.getElementById("sessionPnlChip"),
      botModeChip: document.getElementById("botModeChip"),
      supervisorChip: document.getElementById("supervisorChip"),
      sessionPnlValue: document.getElementById("sessionPnlValue"),
      sessionPnlMeta: document.getElementById("sessionPnlMeta"),
      botThinkingValue: document.getElementById("botThinkingValue"),
      botActivityMeta: document.getElementById("botActivityMeta"),
      tagStatsUpdated: document.getElementById("tagStatsUpdated"),
      tagStatsSummary: document.getElementById("tagStatsSummary"),
      tagStatsTable: document.getElementById("tagStatsTable"),
      analyticsUpdated: document.getElementById("analyticsUpdated"),
      analyticsWinRateValue: document.getElementById("analyticsWinRateValue"),
      analyticsPnlValue: document.getElementById("analyticsPnlValue"),
      analyticsTradesValue: document.getElementById("analyticsTradesValue"),
      analyticsSymbols: document.getElementById("analyticsSymbols"),
      watchdogAlertBox: document.getElementById("watchdogAlertBox"),
      runStateChip: document.getElementById("runStateChip"),
      reportDays: document.getElementById("reportDays"),
      reportGenerated: document.getElementById("reportGenerated"),
      refreshReportBtn: document.getElementById("refreshReportBtn"),
      exportReportJsonBtn: document.getElementById("exportReportJsonBtn"),
      exportReportCsvBtn: document.getElementById("exportReportCsvBtn"),
      reportTotalPnl: document.getElementById("reportTotalPnl"),
      reportWinRate: document.getElementById("reportWinRate"),
      reportTrades: document.getElementById("reportTrades"),
      reportDailyPnl: document.getElementById("reportDailyPnl"),
      reportWeeklyPnl: document.getElementById("reportWeeklyPnl"),
      reportStrengths: document.getElementById("reportStrengths"),
      reportWeaknesses: document.getElementById("reportWeaknesses"),
      reportByDay: document.getElementById("reportByDay"),
      reportByWeek: document.getElementById("reportByWeek"),
      reportEaTrades: document.getElementById("reportEaTrades"),
      reportTabButtons: Array.from(document.querySelectorAll(".report-tab-btn[data-report-tab]")),
      reportTabSummary: document.getElementById("reportTabSummary"),
      reportTabPnl: document.getElementById("reportTabPnl"),
      reportTabSides: document.getElementById("reportTabSides"),
      reportTabSymbols: document.getElementById("reportTabSymbols"),
      reportTabRisks: document.getElementById("reportTabRisks"),
      reportCurveSummary: document.getElementById("reportCurveSummary"),
      reportPnlBars: document.getElementById("reportPnlBars"),
      reportRecentDeals: document.getElementById("reportRecentDeals"),
      reportLongShortSplit: document.getElementById("reportLongShortSplit"),
      reportSideQuality: document.getElementById("reportSideQuality"),
      reportSymbolBars: document.getElementById("reportSymbolBars"),
      reportRiskStats: document.getElementById("reportRiskStats"),
      reportDrawdownCurve: document.getElementById("reportDrawdownCurve"),
      triggerFlowCount: document.getElementById("triggerFlowCount"),
      triggerFlowLog: document.getElementById("triggerFlowLog"),
      clearTriggerFlowBtn: document.getElementById("clearTriggerFlowBtn"),
      navLinks: Array.from(document.querySelectorAll(".nav-link[data-target]")),
      panels: Array.from(document.querySelectorAll(".section-panel")),
      chartSymbol: document.getElementById("chartSymbol"),
      chartTf: document.getElementById("chartTf"),
      allowedSymbol1: document.getElementById("allowedSymbol1"),
      allowedSymbol2: document.getElementById("allowedSymbol2"),
      applySymbolsBtn: document.getElementById("applySymbolsBtn"),
      toolTrend: document.getElementById("toolTrend"),
      toolPoly: document.getElementById("toolPoly"),
      toolHLine: document.getElementById("toolHLine"),
      toolRect: document.getElementById("toolRect"),
      toolLong: document.getElementById("toolLong"),
      toolShort: document.getElementById("toolShort"),
      toolClear: document.getElementById("toolClear"),
      zoomInBtn: document.getElementById("zoomInBtn"),
      zoomOutBtn: document.getElementById("zoomOutBtn"),
      resetViewBtn: document.getElementById("resetViewBtn"),
      autoScaleBtn: document.getElementById("autoScaleBtn"),
      freeMoveBtn: document.getElementById("freeMoveBtn"),
      closeTradeBtn: document.getElementById("closeTradeBtn"),
      dispatchAutomationBtn: document.getElementById("dispatchAutomationBtn"),
      triggerFlowMode: document.getElementById("triggerFlowMode"),
      manualTradeMode: document.getElementById("manualTradeMode"),
      manualGuardPill: document.getElementById("manualGuardPill"),
      manualOrderType: document.getElementById("manualOrderType"),
      manualVolume: document.getElementById("manualVolume"),
      manualPriceWrap: document.getElementById("manualPriceWrap"),
      manualPrice: document.getElementById("manualPrice"),
      manualStopLimitWrap: document.getElementById("manualStopLimitWrap"),
      manualStopLimitPrice: document.getElementById("manualStopLimitPrice"),
      manualSl: document.getElementById("manualSl"),
      manualSlMode: document.getElementById("manualSlMode"),
      manualTp: document.getElementById("manualTp"),
      manualTpMode: document.getElementById("manualTpMode"),
      manualComment: document.getElementById("manualComment"),
      manualBuyBtn: document.getElementById("manualBuyBtn"),
      manualSellBtn: document.getElementById("manualSellBtn"),
      marketChart: document.getElementById("marketChart"),
      chartMeta: document.getElementById("chartMeta"),
      liveBody: document.getElementById("liveBody"),
      historyBody: document.getElementById("historyBody"),
      systemLog: document.getElementById("systemLog"),
      logoutBtn: document.getElementById("logoutBtn"),
      tradeDetailModal: document.getElementById("tradeDetailModal"),
      tradeDetailTitle: document.getElementById("tradeDetailTitle"),
      tradeDetailGrid: document.getElementById("tradeDetailGrid"),
      tradeDetailCloseBtn: document.getElementById("tradeDetailCloseBtn"),
      tradeDetailModifyBtn: document.getElementById("tradeDetailModifyBtn"),
      tradeDetailSetSlBtn: document.getElementById("tradeDetailSetSlBtn"),
      tradeDetailSetTpBtn: document.getElementById("tradeDetailSetTpBtn"),
      tradeDetailCloseTradeBtn: document.getElementById("tradeDetailCloseTradeBtn"),
      tradeDetailModifyHint: document.getElementById("tradeDetailModifyHint"),
      blockReasonChip: document.getElementById("blockReasonChip")
    };

    function nowTime() { return new Date().toLocaleTimeString(); }
    function apiBase() { return (el.apiBase.value || "").trim().replace(/\/$/, ""); }
    function isFileMode() { return window.location.protocol === "file:"; }
    function normalizeSymbol(value) { return String(value || "").trim(); }
    function normalizeTf(value) { return String(value || "M1").trim().toUpperCase(); }

    function learningHorizonForTf(tf) {
      const tag = normalizeTf(tf);
      if (tag === "M1") return 20;
      if (tag === "M5") return 16;
      if (tag === "M15") return 12;
      if (tag === "M30") return 10;
      if (tag === "H1") return 8;
      return 12;
    }

    function persistChartMemoryNow() {
      if (!memory) return;
      memory.saveChartPrefs({
        selectedSymbol: state.selectedSymbol,
        chartTf: state.chartTf,
        chartVisibleCount: state.chartVisibleCount,
        chartPanBars: state.chartPanBars,
        chartYZoom: state.chartYZoom,
        chartYShift: state.chartYShift,
        chartFreeMove: state.chartFreeMove,
        allowedSymbols: state.allowedSymbols,
        reportTab: state.reportTab,
        triggerFlowMode: state.triggerFlowMode,
        manualTradeEnabled: state.manualTradeEnabled
      });
    }

    function schedulePersistChartMemory() {
      if (!memory) return;
      if (state.memoryPersistTimer) clearTimeout(state.memoryPersistTimer);
      state.memoryPersistTimer = setTimeout(() => {
        persistChartMemoryNow();
        state.memoryPersistTimer = null;
      }, 400);
    }

    function restoreChartMemoryBootstrap() {
      if (!memory) return;
      const prefs = memory.loadChartPrefs();
      if (!prefs || typeof prefs !== "object") return;
      if (Array.isArray(prefs.allowedSymbols) && prefs.allowedSymbols.length) {
        el.allowedSymbol1.value = prefs.allowedSymbols[0] || el.allowedSymbol1.value;
        if (prefs.allowedSymbols[1]) el.allowedSymbol2.value = prefs.allowedSymbols[1];
      }
      const tf = normalizeTf(prefs.chartTf || "");
      if (tf) {
        state.chartTf = tf;
        el.chartTf.value = tf;
      }
      state.preferredSymbol = normalizeSymbol(prefs.selectedSymbol || "");
      state.chartVisibleCount = clampNumber(Math.round(Number(prefs.chartVisibleCount || state.chartVisibleCount || 150)), 40, MAX_LOCAL_BARS);
      state.chartPanBars = Math.round(Number(prefs.chartPanBars || 0));
      state.chartYZoom = clampNumber(Number(prefs.chartYZoom || 1), 0.5, 6);
      state.chartYShift = Number(prefs.chartYShift || 0);
      state.chartFreeMove = !!prefs.chartFreeMove;
      state.reportTab = String(prefs.reportTab || state.reportTab || "summary").toLowerCase();
      state.triggerFlowMode = normalizeTriggerFlowMode(prefs.triggerFlowMode || state.triggerFlowMode || "BOTH");
      state.manualTradeEnabled = !!prefs.manualTradeEnabled;
    }

    function restoreCachedCandlesFor(symbol, tf) {
      if (!memory) return false;
      const sym = normalizeSymbol(symbol);
      if (!sym) return false;
      const key = chartKey(sym, tf);
      const payload = memory.getCandles(sym, tf);
      const bars = Array.isArray(payload?.bars) ? payload.bars : [];
      if (!bars.length) return false;
      state.marketCandles[key] = bars.slice(-MAX_LOCAL_BARS);
      const learn = memory.getLearningSummary(sym, tf, learningHorizonForTf(tf), 0.0002);
      if (learn && typeof learn === "object") {
        state.memoryLearning[key] = learn;
      }
      return true;
    }

    function refreshLearningMemory(symbol, tf, candles) {
      if (!memory) return;
      const sym = normalizeSymbol(symbol);
      if (!sym || !Array.isArray(candles) || !candles.length) return;
      const horizon = learningHorizonForTf(tf);
      const learn = memory.ingestLearning(sym, tf, candles, { horizonBars: horizon, flatThresholdPct: 0.0002 });
      if (learn && typeof learn === "object") {
        const key = chartKey(sym, tf);
        state.memoryLearning[key] = learn;
      }
    }

    function isTriggerFlowMessage(message) {
      const raw = String(message || "");
      if (!raw) return false;
      if (raw.includes("[TriggerFlow]")) return true;
      const text = raw.toLowerCase();
      return (
        text.includes("entry accepted") ||
        text.includes("rescue entry accepted") ||
        text.includes("blocked entry") ||
        text.includes("trigger fired") ||
        text.includes("tag result:") ||
        text.includes("paused tag:") ||
        text.includes("resumed tag:")
      );
    }

    function classifyTriggerFlow(message) {
      const text = String(message || "").toLowerCase();
      if (text.includes("pending")) return { type: "pending", label: "Pending" };
      if (text.includes("blocked")) return { type: "blocked", label: "Blocked" };
      if (text.includes("order sent") || text.includes("entry accepted") || text.includes("trigger fired")) {
        return { type: "success", label: "Success" };
      }
      if (text.includes("error") || text.includes("failed") || text.includes("retcode")) {
        return { type: "error", label: "Error" };
      }
      return { type: "info", label: "Info" };
    }

    function updateTriggerFlowCount() {
      if (!el.triggerFlowCount || !el.triggerFlowLog) return;
      const count = Number(el.triggerFlowLog.childElementCount || 0);
      el.triggerFlowCount.textContent = `${count} event${count === 1 ? "" : "s"}`;
    }

    function appendTriggerFlow(message) {
      if (!el.triggerFlowLog || !isTriggerFlowMessage(message)) return;
      const level = classifyTriggerFlow(message);
      const stripped = String(message || "").replace(/^.*?\[TriggerFlow\]\s*/i, "").trim();
      const content = stripped || String(message || "");
      const p = document.createElement("p");
      p.className = `log-line trigger-flow-line trigger-flow-${level.type}`;
      p.innerHTML = `<span class="t">[${nowTime()}]</span> <span class="trigger-flow-badge ${level.type}">${level.label}</span> ${escHtml(content)}`;
      el.triggerFlowLog.appendChild(p);
      const maxKeep = 600;
      while (el.triggerFlowLog.childElementCount > maxKeep) {
        el.triggerFlowLog.removeChild(el.triggerFlowLog.firstElementChild);
      }
      el.triggerFlowLog.scrollTop = el.triggerFlowLog.scrollHeight;
      updateTriggerFlowCount();
    }

    function resetTriggerFlowPanel() {
      if (!el.triggerFlowLog) return;
      el.triggerFlowLog.innerHTML = "";
      updateTriggerFlowCount();
    }

    function normalizeBlockReasonText(text) {
      const raw = String(text || "").trim();
      if (!raw) return "";
      return raw.replace(/\s+/g, " ").trim();
    }

    function extractBlockReasonFromMessage(message) {
      const msg = String(message || "").trim();
      if (!msg) return "";
      const m = msg.toLowerCase();
      if (m.includes("blocked entry:")) {
        const idxReason = m.indexOf("reason=");
        if (idxReason >= 0) return normalizeBlockReasonText(msg.slice(idxReason + 7));
        const idx = m.indexOf("blocked entry:");
        return normalizeBlockReasonText(msg.slice(idx + "blocked entry:".length));
      }
      if (m.includes("trigger wait")) {
        const idx = msg.indexOf(":");
        return normalizeBlockReasonText(idx >= 0 ? msg.slice(idx + 1) : msg);
      }
      if (m.includes("entry blocked")) {
        const idx = msg.indexOf(":");
        return normalizeBlockReasonText(idx >= 0 ? msg.slice(idx + 1) : msg);
      }
      if (m.includes("phase2 arm blocked") || m.includes("phase4 arm blocked")) {
        const idx = msg.indexOf(":");
        return normalizeBlockReasonText(idx >= 0 ? msg.slice(idx + 1) : msg);
      }
      return "";
    }

    function renderLastBlockChip() {
      if (!el.blockReasonChip) return;
      const reason = normalizeBlockReasonText(state.lastBlockReason || "");
      if (!reason) {
        el.blockReasonChip.textContent = "Last Block: --";
        el.blockReasonChip.title = "Last entry block reason";
        el.blockReasonChip.classList.remove("has-reason");
        return;
      }
      const at = String(state.lastBlockAt || "").trim();
      const label = `Last Block: ${reason}${at ? ` (${at})` : ""}`;
      el.blockReasonChip.textContent = label;
      el.blockReasonChip.title = label;
      el.blockReasonChip.classList.add("has-reason");
    }

    function updateLastBlockReasonFromMessage(message) {
      const reason = extractBlockReasonFromMessage(message);
      if (!reason) return;
      state.lastBlockReason = reason;
      state.lastBlockAt = nowTime();
      renderLastBlockChip();
    }

    function log(message, remote = false) {
      const key = remote ? `r:${message}` : `l:${message}`;
      if (state.seenLogs.has(key)) return;
      state.seenLogs.add(key);
      const p = document.createElement("p");
      p.className = "log-line";
      p.innerHTML = `<span class="t">[${nowTime()}]</span> ${message}`;
      el.systemLog.appendChild(p);
      el.systemLog.scrollTop = el.systemLog.scrollHeight;
      appendTriggerFlow(message);
      updateLastBlockReasonFromMessage(message);
      bus.dispatchEvent(new CustomEvent("log", { detail: message }));
    }

    async function sha256(text) {
      const bytes = new TextEncoder().encode(text);
      const hash = await crypto.subtle.digest("SHA-256", bytes);
      return [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, "0")).join("");
    }

    async function fetchApiSessionToken(force = false) {
      if (state.apiSessionToken && !force) return state.apiSessionToken;
      const base = apiBase();
      if (!base) throw new Error("Backend API URL is empty");
      const res = await fetch(`${base}/api/session`, { method: "GET" });
      const data = await res.json().catch(() => ({}));
      if (!res.ok || data.ok === false || !data.token) {
        throw new Error(data.error || `Session init failed (${res.status})`);
      }
      state.apiSessionToken = String(data.token);
      return state.apiSessionToken;
    }

    async function api(path, options = {}) {
      const base = apiBase();
      if (!base) throw new Error("Backend API URL is empty");
      const url = `${base}${path}`;
      let triedRefresh = false;

      while (true) {
        const headers = { ...(options.headers || {}) };
        if (path !== "/api/session") {
          const token = await fetchApiSessionToken(triedRefresh);
          headers["X-KutEA-Session"] = token;
        }

        const fetchOpts = { method: options.method || "GET", headers };
        if (options.formData) {
          fetchOpts.body = options.formData;
        } else if (options.body !== undefined) {
          fetchOpts.headers["Content-Type"] = "application/json";
          fetchOpts.body = JSON.stringify(options.body);
        }

        const res = await fetch(url, fetchOpts);
        const data = await res.json().catch(() => ({}));

        if (res.status === 401 && !triedRefresh && path !== "/api/session") {
          state.apiSessionToken = "";
          triedRefresh = true;
          continue;
        }

        if (!res.ok || data.ok === false) {
          throw new Error(data.error || `Request failed (${res.status})`);
        }
        return data;
      }
    }

    function normalizeTriggerFlowMode(value) {
      const raw = String(value || "").trim().toUpperCase();
      if (raw === "BUY" || raw === "BUY_ONLY" || raw === "LONG") return "BUY_ONLY";
      if (raw === "SELL" || raw === "SELL_ONLY" || raw === "SHORT") return "SELL_ONLY";
      if (raw === "AUTO") return "AUTO";
      return "BOTH";
    }

    function normalizeManualOrderType(value) {
      return String(value || "MARKET_EXECUTION").trim().toUpperCase();
    }

    function orderTypeRequiredFields(orderType) {
      const t = normalizeManualOrderType(orderType);
      if (t === "BUY_STOP_LIMIT" || t === "SELL_STOP_LIMIT") return { price: true, stopLimit: true };
      if (t === "MARKET_EXECUTION") return { price: false, stopLimit: false };
      return { price: true, stopLimit: false };
    }

    function orderTypeFixedSide(orderType) {
      const t = normalizeManualOrderType(orderType);
      if (t.startsWith("BUY_")) return "BUY";
      if (t.startsWith("SELL_")) return "SELL";
      return "ANY";
    }

    function parseOptionalNumInput(ctrl) {
      if (!ctrl) return null;
      const raw = String(ctrl.value || "").trim();
      if (!raw) return null;
      const cleaned = raw.replace(/,/g, "").replace(/^\$/, "").trim();
      const n = Number(cleaned);
      if (!Number.isFinite(n)) return null;
      return n;
    }

    function parseFlexibleNumericInput(ctrl, allowCurrency = false) {
      if (!ctrl) return { ok: true, empty: true, value: null };
      const raw = String(ctrl.value || "").trim();
      if (!raw) return { ok: true, empty: true, value: null };
      let cleaned = raw.replace(/,/g, "").trim();
      if (allowCurrency && cleaned.startsWith("$")) cleaned = cleaned.slice(1).trim();
      const n = Number(cleaned);
      if (!Number.isFinite(n)) return { ok: false, empty: false, value: null };
      return { ok: true, empty: false, value: n };
    }

    function setManualTradeEnabled(enabled, origin = "ui") {
      state.manualTradeEnabled = !!enabled;
      if (el.manualTradeMode) el.manualTradeMode.value = state.manualTradeEnabled ? "on" : "off";
      if (el.manualGuardPill) {
        el.manualGuardPill.textContent = `Manual Trade: ${state.manualTradeEnabled ? "ON" : "OFF"}`;
        el.manualGuardPill.classList.toggle("ok", state.manualTradeEnabled);
      }
      updateManualOrderUi();
      if (origin === "backend") return;
      schedulePersistChartMemory();
    }

    function setTriggerFlowMode(mode, origin = "ui") {
      state.triggerFlowMode = normalizeTriggerFlowMode(mode);
      if (el.triggerFlowMode) el.triggerFlowMode.value = state.triggerFlowMode;
      if (origin === "backend") return;
      schedulePersistChartMemory();
    }

    function updateManualOrderUi() {
      const orderType = normalizeManualOrderType(el.manualOrderType?.value || "MARKET_EXECUTION");
      const req = orderTypeRequiredFields(orderType);
      const fixedSide = orderTypeFixedSide(orderType);

      if (el.manualPriceWrap) el.manualPriceWrap.classList.toggle("field-hidden", !req.price);
      if (el.manualStopLimitWrap) el.manualStopLimitWrap.classList.toggle("field-hidden", !req.stopLimit);

      const byTrigger = state.triggerFlowMode === "BOTH";
      const baseEnabled = state.manualTradeEnabled && state.backendApiOnline && state.connected && byTrigger;
      let allowBuy = baseEnabled;
      let allowSell = baseEnabled;
      if (fixedSide === "BUY") allowSell = false;
      if (fixedSide === "SELL") allowBuy = false;

      if (el.manualBuyBtn) el.manualBuyBtn.disabled = !allowBuy;
      if (el.manualSellBtn) el.manualSellBtn.disabled = !allowSell;
      if (el.manualGuardPill) {
        const connectedOk = state.backendApiOnline && state.connected;
        const text = !state.manualTradeEnabled
          ? "Manual Trade: OFF"
          : !connectedOk
            ? "Manual Trade: ON (Connect broker/backend)"
            : !byTrigger
              ? "Manual Trade: ON (Trigger must be Both Sides)"
              : "Manual Trade: ON";
        el.manualGuardPill.textContent = text;
        el.manualGuardPill.classList.toggle("ok", !!baseEnabled);
      }
    }

    async function syncManualConfig(manualLog = false) {
      if (!state.backendApiOnline) {
        updateManualOrderUi();
        return false;
      }
      try {
        const data = await api("/api/manual/config", {
          method: "POST",
          body: {
            manual_trade_enabled: state.manualTradeEnabled,
            trigger_flow_mode: state.triggerFlowMode
          }
        });
        setManualTradeEnabled(!!data.manual_trade_enabled, "backend");
        setTriggerFlowMode(data.trigger_flow_mode, "backend");
        if (manualLog) log(`Manual config saved (manual=${state.manualTradeEnabled ? "ON" : "OFF"}, trigger=${state.triggerFlowMode})`);
        return true;
      } catch (err) {
        if (manualLog) log(`Manual config sync error: ${err.message}`);
        updateManualOrderUi();
        return false;
      }
    }

    async function dispatchMt5AutomationCommand(manualLog = true) {
      if (!state.backendApiOnline) {
        if (manualLog) log("Error: Connect backend first");
        return false;
      }
      const payload = {
        action: "attach",
        symbol: state.selectedSymbol || "",
        tf: normalizeTf(state.chartTf),
        allowed_symbols: state.allowedSymbols || [],
        primary_symbol: state.selectedSymbol || "",
        trigger_flow_mode: state.triggerFlowMode,
        manual_trade_enabled: state.manualTradeEnabled,
        settings: collectSettings()
      };
      try {
        const res = await api("/api/automation/dispatch", { method: "POST", body: payload });
        if (manualLog) log(`MT5 automation command dispatched (${res.command_file || "ok"})`);
        return true;
      } catch (err) {
        if (manualLog) log(`Automation dispatch error: ${err.message}`);
        return false;
      }
    }

    async function placeManualOrder(side) {
      const wantedSide = String(side || "").toUpperCase();
      if (!state.backendApiOnline) {
        log("Error: Connect backend first");
        return;
      }
      if (!state.connected) {
        log("Error: Broker not connected");
        return;
      }
      if (!state.manualTradeEnabled) {
        log("Error: Manual trade mode is OFF");
        return;
      }
      const symbol = normalizeSymbol(state.selectedSymbol || el.chartSymbol.value);
      if (!symbol) {
        log("Error: Select a market symbol first");
        return;
      }
      const orderType = normalizeManualOrderType(el.manualOrderType.value || "MARKET_EXECUTION");
      const fixedSide = orderTypeFixedSide(orderType);
      if (fixedSide !== "ANY" && fixedSide !== wantedSide) {
        log(`Error: ${orderType.replace(/_/g, " ")} must use ${fixedSide} button`);
        return;
      }
      const volume = Number(el.manualVolume.value || 0);
      if (!Number.isFinite(volume) || volume <= 0) {
        log("Error: Lot size must be greater than 0");
        return;
      }
      const req = orderTypeRequiredFields(orderType);
      const priceParsed = parseFlexibleNumericInput(el.manualPrice, false);
      const stopLimitParsed = parseFlexibleNumericInput(el.manualStopLimitPrice, false);
      if (!priceParsed.ok) {
        log("Error: Entry price must be numeric");
        return;
      }
      if (!stopLimitParsed.ok) {
        log("Error: Stop limit price must be numeric");
        return;
      }
      const price = priceParsed.value;
      const stopLimit = stopLimitParsed.value;
      if (req.price && (!Number.isFinite(price) || Number(price) <= 0)) {
        log("Error: Entry price is required for this order type");
        return;
      }
      if (req.stopLimit && (!Number.isFinite(stopLimit) || Number(stopLimit) <= 0)) {
        log("Error: Stop limit price is required for this order type");
        return;
      }
      const slParsed = parseFlexibleNumericInput(el.manualSl, true);
      const tpParsed = parseFlexibleNumericInput(el.manualTp, true);
      if (!slParsed.ok) {
        log("Error: Stop Loss must be numeric (example: $29, 19, 467283.90)");
        return;
      }
      if (!tpParsed.ok) {
        log("Error: Take Profit must be numeric (example: $29, 19, 467283.90)");
        return;
      }
      const sl = slParsed.value;
      const tp = tpParsed.value;
      const slMode = String(el.manualSlMode?.value || "PRICE").toUpperCase();
      const tpMode = String(el.manualTpMode?.value || "PRICE").toUpperCase();
      const comment = String(el.manualComment.value || "").trim();
      try {
        const res = await api("/api/trades/manual", {
          method: "POST",
          body: {
            symbol,
            side: wantedSide,
            order_type: orderType,
            volume,
            price,
            stop_limit: stopLimit,
            sl,
            tp,
            sl_mode: slMode,
            tp_mode: tpMode,
            comment
          }
        });
        const out = res.result || {};
        const ticket = Number(out.order || out.deal || 0);
        log(`Manual ${wantedSide} ${orderType.replace(/_/g, " ")} sent on ${symbol}${ticket ? ` (#${ticket})` : ""}`);
        await pollBackend();
        await fetchMarketCandles(true);
      } catch (err) {
        log(`Manual order error: ${err.message}`);
      }
    }

    async function syncMarketContext(logErrors = false) {
      if (!state.backendApiOnline || !state.selectedSymbol) return false;
      try {
        await api("/api/market/select", {
          method: "POST",
          body: {
            symbol: state.selectedSymbol,
            tf: normalizeTf(state.chartTf)
          }
        });
        return true;
      } catch (err) {
        if (logErrors) log(`Market sync error: ${err.message}`);
        return false;
      }
    }

    async function handleLogin(evt) {
      evt.preventDefault();
      el.authError.textContent = "";
      const user = el.username.value.trim();
      const passHash = await sha256(el.password.value);
      if (user !== USERNAME || passHash !== PASS_HASH) {
        el.authError.textContent = "Invalid login credentials";
        return;
      }
      const session = { token: btoa(`${user}:${Date.now()}`), exp: Date.now() + 8 * 60 * 60 * 1000 };
      sessionStorage.setItem("kutea26_session", JSON.stringify(session));
      setAuthenticated(true);
      log("Authentication successful");
      log("Backend not connected. Set Backend API URL and click Connect Backend.");
    }

    function setAuthenticated(ok) {
      state.authenticated = ok;
      el.lockScreen.classList.toggle("hidden", ok);
      el.app.classList.toggle("hidden", !ok);
      // Prevent hidden login form from capturing implicit submit events after auth.
      const loginCtrls = el.loginForm ? Array.from(el.loginForm.querySelectorAll("input, button")) : [];
      loginCtrls.forEach(ctrl => {
        ctrl.disabled = !!ok;
      });
    }

    function loadSession() {
      try {
        const raw = sessionStorage.getItem("kutea26_session");
        if (!raw) return setAuthenticated(false);
        const sess = JSON.parse(raw);
        if (!sess?.exp || Date.now() > sess.exp) {
          sessionStorage.removeItem("kutea26_session");
          return setAuthenticated(false);
        }
        setAuthenticated(true);
        setBackendApiState(false, "Disconnected");
        stopPolling();
      } catch {
        setAuthenticated(false);
      }
    }

    function logout() {
      sessionStorage.removeItem("kutea26_session");
      disconnectBackendApi(false);
      closeTradeDetailModal();
      setAuthenticated(false);
    }

    function setBackendApiState(online, text = "") {
      state.backendApiOnline = !!online;
      el.backendApiStatus.textContent = `Backend: ${text || (online ? "Connected" : "Disconnected")}`;
      el.backendApiBtn.textContent = online ? "Disconnect Backend" : "Connect Backend";
      el.backendApiBtn.classList.toggle("btn-backend-connect", !online);
      el.backendApiBtn.classList.toggle("btn-backend-disconnect", online);
      updateManualOrderUi();
    }

    function disconnectBackendApi(logMessage = true) {
      if (state.backendApiOnline) {
        api("/api/ea/stop", { method: "POST" }).catch(() => {});
      }
      setEngineState(false);
      setManualTradeEnabled(false, "backend");
      setTriggerFlowMode("BOTH", "backend");
      stopPolling();
      state.apiSessionToken = "";
      setBackendApiState(false, "Disconnected");
      closeTradeDetailModal();
      state.marketStructure = {};
      state.accountSnapshot = {};
      state.supervisorStatus = null;
      state.lastSupervisorSignature = "";
      state.reportSummary = null;
      state.reportLastFetchMs = 0;
      renderAccount({});
      renderInsight(buildFallbackInsight());
      renderReport(buildFallbackReport());
      resetTriggerFlowPanel();
      if (logMessage) log("Backend API disconnected");
    }

    async function connectBackendApi(manual = false) {
      try {
        await fetchApiSessionToken(true);
        await api("/api/health");
        const cfg = await api("/api/manual/config").catch(() => null);
        if (cfg && typeof cfg === "object") {
          setManualTradeEnabled(!!cfg.manual_trade_enabled, "backend");
          setTriggerFlowMode(cfg.trigger_flow_mode || state.triggerFlowMode, "backend");
        }
        setBackendApiState(true, "Connected");
        startPolling();
        refreshReport(false);
        if (manual) log("Backend API connected");
        return true;
      } catch (err) {
        disconnectBackendApi(false);
        if (manual || !isFileMode()) log(`Backend connect error: ${err.message}`);
        return false;
      }
    }

    async function toggleBackendApi() {
      if (state.backendApiOnline) {
        disconnectBackendApi(true);
        return;
      }
      await connectBackendApi(true);
    }

    function showPanel(panelId, updateHash = true) {
      const exists = el.panels.some(p => p.id === panelId);
      const target = exists ? panelId : "brokerPanel";
      state.activePanel = target;
      el.panels.forEach(p => p.classList.toggle("active", p.id === target));
      el.navLinks.forEach(link => link.classList.toggle("active", link.dataset.target === target));
      if (updateHash && window.location.hash !== `#${target}`) {
        history.replaceState(null, "", `#${target}`);
      }
      if (target === "marketPanel") {
        requestAnimationFrame(drawMarketChart);
      }
    }

    function initPanels() {
      el.navLinks.forEach(link => {
        link.addEventListener("click", (evt) => {
          evt.preventDefault();
          showPanel(link.dataset.target || "brokerPanel");
        });
      });
      const fromHash = (window.location.hash || "").replace("#", "").trim();
      showPanel(fromHash || "brokerPanel", false);
      window.addEventListener("hashchange", () => {
        const target = (window.location.hash || "").replace("#", "").trim();
        if (target) showPanel(target, false);
      });
    }

    function setBrokerStatus(connected, text) {
      state.connected = !!connected;
      el.brokerStatus.textContent = connected ? (text || "Connected") : (text || "Disconnected");
      el.brokerDot.classList.toggle("ok", connected);
      el.connectBtn.textContent = connected ? "Disconnect Broker" : "Connect Broker";
      el.connectBtn.classList.toggle("btn-disconnect", connected);
      el.connectBtn.classList.toggle("btn-primary", !connected);
      updateManualOrderUi();
    }

    function prettyName(raw) {
      return raw.replace(/^Inp/, "").replace(/([a-z0-9])([A-Z])/g, "$1 $2").trim();
    }

    function cleanDefault(v) { return String(v ?? "").replace(/^"|"$/g, ""); }

    function makeField(param) {
      const wrap = document.createElement("div");
      wrap.className = "col-4";
      const label = document.createElement("label");
      label.className = "hint";
      label.textContent = prettyName(param.name);
      const t = String(param.type || "").toLowerCase();
      const id = `set_${param.name}`;
      let ctrl;

      if (t === "bool") {
        ctrl = document.createElement("select");
        ctrl.innerHTML = `<option value="true">true</option><option value="false">false</option>`;
        const d = cleanDefault(param.defaultValue).toLowerCase();
        ctrl.value = (d === "true" || d === "1") ? "true" : "false";
      } else if (t.includes("timeframes") || t.includes("enum_timeframes")) {
        ctrl = document.createElement("select");
        ["PERIOD_M1","PERIOD_M5","PERIOD_M15","PERIOD_H1","PERIOD_H4","PERIOD_D1"].forEach(v => {
          const o = document.createElement("option");
          o.value = v;
          o.textContent = v;
          ctrl.appendChild(o);
        });
        ctrl.value = cleanDefault(param.defaultValue);
      } else {
        ctrl = document.createElement("input");
        ctrl.type = "text";
        ctrl.value = cleanDefault(param.defaultValue);
      }
      ctrl.id = id;
      ctrl.dataset.param = param.name;
      ctrl.dataset.type = param.type;
      wrap.appendChild(label);
      wrap.appendChild(ctrl);
      return wrap;
    }

    function buildSettingsPanel(params) {
      el.settingsPanel.innerHTML = "";
      if (!params?.length) {
        const note = document.createElement("p");
        note.className = "hint";
        note.textContent = "No typed inputs available from this EA file. Upload a .set file to load settings values.";
        el.settingsPanel.appendChild(note);
        el.setFile.disabled = !state.mq5Loaded;
        return;
      }
      params.forEach(p => el.settingsPanel.appendChild(makeField(p)));
      el.setFile.disabled = false;
      log(`EA Loaded Successfully - ${params.length} inputs parsed`);
    }

    function buildSettingsPanelFromMap(values, silent = false) {
      const entries = Object.entries(values || {}).filter(([k]) => String(k || "").trim().length > 0);
      if (!entries.length) {
        buildSettingsPanel([]);
        return 0;
      }
      const params = entries.map(([k, v]) => ({
        type: "string",
        name: String(k),
        defaultValue: String(v ?? "")
      }));
      state.parameters = params;
      el.settingsPanel.innerHTML = "";
      params.forEach(p => el.settingsPanel.appendChild(makeField(p)));
      el.setFile.disabled = false;
      collectSettings();
      if (!silent) log(`Settings panel loaded from key/value map (${params.length} fields)`);
      return params.length;
    }

    function collectSettings() {
      const controls = el.settingsPanel.querySelectorAll("[data-param]");
      const out = {};
      controls.forEach(c => { out[c.dataset.param] = c.value; });
      const normalized = normalizeKutMilzSignalSettings(out);
      if (normalized.InpCrystalIndicatorPath !== out.InpCrystalIndicatorPath) {
        const pathCtrl = el.settingsPanel.querySelector("[data-param='InpCrystalIndicatorPath']");
        if (pathCtrl) pathCtrl.value = normalized.InpCrystalIndicatorPath;
      }
      if (normalized.InpUseCrystalHeikinSignal !== out.InpUseCrystalHeikinSignal) {
        const signalCtrl = el.settingsPanel.querySelector("[data-param='InpUseCrystalHeikinSignal']");
        if (signalCtrl) signalCtrl.value = normalized.InpUseCrystalHeikinSignal;
      }
      state.settings = normalized;
      return normalized;
    }

    function normalizeKutMilzSignalSettings(settings) {
      const out = { ...(settings || {}) };
      const rawPath = String(out.InpCrystalIndicatorPath || "").trim().replace(/\//g, "\\");
      const isOldCrystal = /Crystal\s+Heikin\s+Ashi/i.test(rawPath);
      if (!rawPath || isOldCrystal) out.InpCrystalIndicatorPath = "Market\\KUTMilz";
      if (out.InpUseCrystalHeikinSignal === undefined || out.InpUseCrystalHeikinSignal === "") {
        out.InpUseCrystalHeikinSignal = "true";
      }
      return out;
    }

    function parseSetContent(text) {
      const out = {};
      String(text || "").split(/\r?\n/).forEach(lineRaw => {
        const line = lineRaw.trim();
        if (!line) return;
        if (line.startsWith(";") || line.startsWith("#") || line.startsWith("//")) return;
        const eq = line.indexOf("=");
        if (eq <= 0) return;
        const key = line.slice(0, eq).trim();
        let val = line.slice(eq + 1).trim();
        if (!key) return;
        const sc = val.indexOf(";");
        if (sc > 0) val = val.slice(0, sc).trim();
        if ((val.startsWith("\"") && val.endsWith("\"")) || (val.startsWith("'") && val.endsWith("'"))) {
          val = val.slice(1, -1);
        }
        out[key] = val;
      });
      return out;
    }

    function applySetValues(values) {
      const controls = Array.from(el.settingsPanel.querySelectorAll("[data-param]"));
      if (!controls.length) {
        return buildSettingsPanelFromMap(values, true);
      }
      const lowerMap = {};
      Object.keys(values || {}).forEach(k => { lowerMap[String(k).toLowerCase()] = values[k]; });
      let applied = 0;
      controls.forEach(ctrl => {
        const key = String(ctrl.dataset.param || "");
        if (!key) return;
        let val = values[key];
        if (val === undefined) val = lowerMap[key.toLowerCase()];
        if (val === undefined) return;
        const type = String(ctrl.dataset.type || "").toLowerCase();
        if (ctrl.tagName === "SELECT") {
          if (type === "bool") {
            const b = String(val).trim().toLowerCase();
            ctrl.value = (b === "true" || b === "1" || b === "yes" || b === "on") ? "true" : "false";
          } else {
            const v = String(val).trim();
            const has = Array.from(ctrl.options).some(o => o.value === v);
            if (has) ctrl.value = v;
          }
        } else {
          ctrl.value = String(val);
        }
        applied += 1;
      });
      collectSettings();
      return applied;
    }

    async function handleSetUpload(evt) {
      const file = evt.target.files?.[0];
      if (!file) return;
      if (!state.mq5Loaded) {
        log("Error: Load EA file first, then upload .set");
        el.setFile.value = "";
        return;
      }
      if (!file.name.toLowerCase().endsWith(".set")) {
        log("Error: Only .set upload is allowed here");
        el.setFile.value = "";
        return;
      }
      try {
        const text = await file.text();
        const values = parseSetContent(text);
        const applied = applySetValues(values);
        el.setFileName.textContent = `${file.name} (${applied} values applied)`;
        log(`.set loaded: ${applied} setting(s) applied`);
      } catch (err) {
        log(`Error: Failed to load .set (${err.message})`);
      }
    }

    async function disconnectBroker() {
      try {
        await api("/api/broker/disconnect", { method: "POST" });
      } catch (err) {
        log(`Error: ${err.message}`);
      }
      setBrokerStatus(false, "Disconnected");
      setEngineState(false);
      setManualTradeEnabled(false, "backend");
      setTriggerFlowMode("BOTH", "backend");
      log("Broker Disconnected");
    }

    async function connectBroker() {
      if (state.connected) {
        await disconnectBroker();
        return;
      }
      const broker = el.brokerSelect.value;
      const login = el.brokerLogin.value.trim();
      const password = el.brokerPassword.value;
      const server = el.brokerServer.value.trim();
      const terminal_path = el.brokerTerminalPath.value.trim();

      if (!broker) { log("Error: Select a broker first"); return; }
      if (!login || !password || !server) {
        log("Error: Broker login, password, and server are required");
        return;
      }

      if (broker === "Deriv") el.compatibilityLabel.textContent = "Connected via MT5 bridge";
      else el.compatibilityLabel.textContent = "Direct MT5 Execution Mode";

      try {
        const res = await api("/api/broker/connect", {
          method: "POST",
          body: { broker, login, password, server, terminal_path }
        });
        setBrokerStatus(true, `Connected (${res.account?.login || login})`);
        el.brokerPassword.value = ""; // clear sensitive input from UI after connect
        log("Broker Connected");
      } catch (err) {
        setBrokerStatus(false, "Disconnected");
        setEngineState(false);
        log(`Error: ${err.message}`);
      }
    }

    async function handleFileUpload(evt) {
      const file = evt.target.files?.[0];
      if (!file) return;
      const lowerName = file.name.toLowerCase();
      if (!(lowerName.endsWith(".mq5") || lowerName.endsWith(".ex5"))) {
        el.fileName.textContent = "Invalid file type";
        el.setFile.disabled = true;
        el.setFile.value = "";
        el.setFileName.textContent = "No .set loaded";
        log("Error: Only .ex5 or .mq5 upload is allowed");
        state.mq5Loaded = false;
        return;
      }
      const fd = new FormData();
      fd.append("file", file);
      try {
        const res = await api("/api/ea/upload", { method: "POST", formData: fd });
        el.fileName.textContent = file.name;
        state.parameters = res.params || [];
        state.mq5Loaded = true;
        const serverSettings = (res && typeof res.settings === "object" && res.settings) ? res.settings : {};
        if (state.parameters.length) {
          buildSettingsPanel(state.parameters);
        } else if (Object.keys(serverSettings).length) {
          buildSettingsPanelFromMap(serverSettings, true);
          log("EA .ex5 loaded with existing settings map.");
        } else {
          buildSettingsPanel([]);
          if (String(res.file_type || "").toLowerCase() === "ex5") {
            log("EA .ex5 loaded. Upload a .set file to load settings (or upload .mq5 for typed input controls).");
          }
        }
        el.setFileName.textContent = "No .set loaded";
      } catch (err) {
        state.mq5Loaded = false;
        el.setFile.disabled = true;
        el.setFile.value = "";
        el.setFileName.textContent = "No .set loaded";
        log(`Error: ${err.message}`);
      }
    }

    function renderLive(rows = []) {
      const html = rows.slice(0, 100).map(t => {
        const pnl = Number(t.pnl || 0);
        const pnlClass = pnl >= 0 ? "pnl-pos" : "pnl-neg";
        const symbol = String(t.symbol ?? "-");
        const symbolSafe = symbol.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
        const symbolBtn = symbol && symbol !== "-" ?
          `<button type="button" class="symbol-jump" data-symbol="${symbolSafe}">${symbolSafe}</button>` :
          "-";
        const sl = Number(t.sl || 0);
        const tp = Number(t.tp || 0);
        const slText = (Number.isFinite(sl) && sl > 0) ? sl.toFixed(2) : "-";
        const tpText = (Number.isFinite(tp) && tp > 0) ? tp.toFixed(2) : "-";
        const ticket = String(t.id ?? "");
        return `<tr class="clickable-row" data-live-ticket="${escHtml(ticket)}">
          <td>${t.id ?? "-"}</td>
          <td>${symbolBtn}</td>
          <td>${t.side || "-"}</td>
          <td>${Number(t.lot || 0).toFixed(2)}</td>
          <td>${Number(t.entry || 0).toFixed(2)}</td>
          <td>${Number(t.current || 0).toFixed(2)}</td>
          <td>${slText}</td>
          <td>${tpText}</td>
          <td class="${pnlClass}">${pnl.toFixed(2)}</td>
          <td>${t.status || "Open"}</td>
        </tr>`;
      }).join("");
      el.liveBody.innerHTML = html || `<tr><td colspan="10" class="hint">No live transactions</td></tr>`;
    }

    function renderHistory(rows = []) {
      const html = rows.slice(0, 200).map(t => {
        const pnl = Number(t.pnl || 0);
        const pnlClass = pnl >= 0 ? "pnl-pos" : "pnl-neg";
        const ticket = String(t.id ?? "");
        return `<tr class="clickable-row" data-history-ticket="${escHtml(ticket)}">
          <td>${t.id ?? "-"}</td>
          <td>${t.position_id ?? "-"}</td>
          <td>${t.symbol ?? "-"}</td>
          <td>${t.side || "-"}</td>
          <td>${Number(t.lot || 0).toFixed(2)}</td>
          <td>${Number(t.entry || 0).toFixed(2)}</td>
          <td>${Number(t.exit || 0).toFixed(2)}</td>
          <td class="${pnlClass}">${pnl.toFixed(2)}</td>
          <td>${escHtml(String(t.reason_name || t.reason || "-"))}</td>
          <td>${t.close_time || "-"}</td>
        </tr>`;
      }).join("");
      el.historyBody.innerHTML = html || `<tr><td colspan="10" class="hint">No completed trades</td></tr>`;
    }

    function formatDetailValue(v, fallback = "-") {
      if (v === null || v === undefined || v === "") return fallback;
      return String(v);
    }

    function getLiveTradeByTicket(ticket) {
      const t = Number(ticket || 0);
      if (!(t > 0)) return null;
      return (state.trades || []).find(r => Number(r.id || 0) === t) || null;
    }

    function suggestLiveLevelPrice(trade, level, vp = null) {
      if (!trade) return NaN;
      const lvl = String(level || "").toLowerCase();
      if (lvl !== "sl" && lvl !== "tp") return NaN;
      const side = String(trade.side || "").toUpperCase();
      const entry = Number(trade.entry || 0);
      const current = Number(trade.current || 0);
      const base = current > 0 ? current : (entry > 0 ? entry : NaN);
      if (!Number.isFinite(base) || !(base > 0)) return NaN;
      const candles = state.selectedSymbol ? (state.marketCandles[chartKey(state.selectedSymbol, state.chartTf)] || []) : [];
      const digits = (vp && Number.isFinite(Number(vp.priceDigits)))
        ? Number(vp.priceDigits)
        : inferPriceDigits(candles.slice(-60));
      const step = Math.pow(10, -Math.max(2, Math.min(6, digits)));
      const span = (vp && Number.isFinite(Number(vp.hi)) && Number.isFinite(Number(vp.lo)))
        ? Math.max(Math.abs(Number(vp.hi) - Number(vp.lo)), step * 120)
        : Math.max(Math.abs(current - entry), step * 220);
      const delta = Math.max(span * 0.10, Math.abs(current - entry) * 1.2, step * 120);
      if (side === "SELL") {
        return lvl === "sl" ? (base + delta) : Math.max(step, base - delta);
      }
      return lvl === "sl" ? Math.max(step, base - delta) : (base + delta);
    }

    async function prepareTradeOnChart(ticket, symbol) {
      closeTradeDetailModal();
      showPanel("marketPanel");
      state.quickModifyTicket = Number(ticket || 0);
      focusMarketSymbol(symbol, false);
      state.chartTool = "none";
      try {
        await pollBackend();
        await fetchMarketCandles(true);
      } catch (_) {}
      autoScaleToCurrentPrice();
    }

    function startTradeLevelEdit(ticket, level, tradeRow = null) {
      const t = Number(ticket || 0);
      const lvl = String(level || "").toLowerCase();
      if (!(t > 0) || (lvl !== "sl" && lvl !== "tp")) return false;
      const row = tradeRow || getLiveTradeByTicket(t);
      if (!row) return false;
      const existing = Number(lvl === "sl" ? row.sl : row.tp);
      const initialPrice = (Number.isFinite(existing) && existing > 0)
        ? existing
        : suggestLiveLevelPrice(row, lvl, state.chartViewport);
      if (!(Number(initialPrice) > 0)) {
        log(`Trade #${t} ${lvl.toUpperCase()} edit failed: no valid price seed`);
        return false;
      }
      state.quickModifyTicket = t;
      state.liveTradeEditDraft = {
        ticket: t,
        level: lvl,
        originalPrice: Number(initialPrice),
        currentPrice: Number(initialPrice),
        entry: Number(row.entry || 0),
        yOffset: 0
      };
      const vp = state.chartViewport;
      if (vp) {
        state.liveTradeDragX = Number(vp.left + vp.plotW - 14);
        state.liveTradeDragY = Number(yForPrice(Number(initialPrice), vp));
      } else {
        state.liveTradeDragX = null;
        state.liveTradeDragY = null;
      }
      drawMarketChart();
      const seeded = !(Number.isFinite(existing) && existing > 0);
      log(`Trade #${t} ${lvl.toUpperCase()} ${seeded ? "seeded" : "ready"} on chart. Drag and release to apply.`);
      return true;
    }

    function openTradeDetailModal(row, source = "live") {
      if (!row || !el.tradeDetailModal || !el.tradeDetailGrid || !el.tradeDetailTitle) return;
      const r = row || {};
      const pnl = Number(r.pnl || 0);
      const isLive = source !== "history";
      const details = [
        ["Ticket", formatDetailValue(r.id)],
        ["Position ID", formatDetailValue(r.position_id)],
        ["Source", isLive ? "Live" : "History"],
        ["Symbol", formatDetailValue(r.symbol)],
        ["Side", formatDetailValue(r.side)],
        ["Lot", Number(r.lot || 0).toFixed(2)],
        ["Entry", Number(r.entry || 0).toFixed(5)],
        ["Current", source === "live" ? Number(r.current || 0).toFixed(5) : "-"],
        ["Exit", source === "history" ? Number(r.exit || 0).toFixed(5) : "-"],
        ["SL", (Number(r.sl || 0) > 0 ? Number(r.sl || 0).toFixed(5) : "-")],
        ["TP", (Number(r.tp || 0) > 0 ? Number(r.tp || 0).toFixed(5) : "-")],
        ["P/L", `${pnl >= 0 ? "+" : ""}${pnl.toFixed(2)}`],
        ["Status", formatDetailValue(r.status, source === "history" ? "Closed" : "Open")],
        ["Open Time", formatDetailValue(r.open_time_iso || (r.open_time ? new Date(Number(r.open_time) * 1000).toLocaleString() : "-"))],
        ["Close Time", formatDetailValue(r.close_time)],
        ["Reason", formatDetailValue(r.reason_name || r.reason)],
        ["Magic", formatDetailValue(r.magic)],
        ["Comment", formatDetailValue(r.comment)],
      ];
      el.tradeDetailTitle.textContent = `Trade Details - #${formatDetailValue(r.id)}`;
      el.tradeDetailGrid.innerHTML = details.map(([k, v]) => `
        <div class="trade-detail-item">
          <div class="k">${escHtml(k)}</div>
          <div class="v">${escHtml(v)}</div>
        </div>
      `).join("");
      state.tradeDetailContext = { ...r, __source: source };
      if (el.tradeDetailModifyBtn) {
        el.tradeDetailModifyBtn.disabled = !isLive;
      }
      if (el.tradeDetailSetSlBtn) {
        el.tradeDetailSetSlBtn.disabled = !isLive;
      }
      if (el.tradeDetailSetTpBtn) {
        el.tradeDetailSetTpBtn.disabled = !isLive;
      }
      if (el.tradeDetailCloseTradeBtn) {
        el.tradeDetailCloseTradeBtn.disabled = !isLive;
      }
      if (el.tradeDetailModifyHint) {
        el.tradeDetailModifyHint.textContent = isLive
          ? "Use Modify / Set SL / Set TP to edit levels on chart. Use Close Trade to close selected live trade."
          : "History trades are closed. Open a live trade to modify SL/TP or close it.";
      }
      el.tradeDetailModal.classList.add("show");
      el.tradeDetailModal.setAttribute("aria-hidden", "false");
      state.tradeDetailModalOpen = true;
    }

    function closeTradeDetailModal() {
      if (!el.tradeDetailModal) return;
      el.tradeDetailModal.classList.remove("show");
      el.tradeDetailModal.setAttribute("aria-hidden", "true");
      state.tradeDetailContext = null;
      state.tradeDetailModalOpen = false;
    }

    async function modifyTradeFromModal() {
      const ctx = state.tradeDetailContext || {};
      const source = String(ctx.__source || "live");
      if (source === "history") {
        log("History trade is closed. Select a live trade to modify.");
        return;
      }
      const ticket = Number(ctx.id || 0);
      const symbol = normalizeSymbol(ctx.symbol || "");
      if (!(ticket > 0) || !symbol) {
        log("Error: trade context missing");
        return;
      }
      await prepareTradeOnChart(ticket, symbol);
      const row = getLiveTradeByTicket(ticket) || ctx;
      const hasSl = Number(row.sl || 0) > 0;
      const hasTp = Number(row.tp || 0) > 0;
      if (!hasSl) {
        startTradeLevelEdit(ticket, "sl", row);
      } else if (!hasTp) {
        startTradeLevelEdit(ticket, "tp", row);
      } else {
        log(`Trade #${ticket} ready. Drag existing SL/TP handles on chart.`);
      }
    }

    async function startTradeLevelEditFromModal(level) {
      const ctx = state.tradeDetailContext || {};
      const source = String(ctx.__source || "live");
      if (source === "history") {
        log("History trade is closed. Select a live trade to modify.");
        return;
      }
      const ticket = Number(ctx.id || 0);
      const symbol = normalizeSymbol(ctx.symbol || "");
      if (!(ticket > 0) || !symbol) {
        log("Error: trade context missing");
        return;
      }
      await prepareTradeOnChart(ticket, symbol);
      const row = getLiveTradeByTicket(ticket) || ctx;
      startTradeLevelEdit(ticket, level, row);
    }

    async function closeTradeFromModal() {
      const ctx = state.tradeDetailContext || {};
      const source = String(ctx.__source || "live");
      if (source === "history") {
        log("History trade is already closed.");
        return;
      }
      const ticket = Number(ctx.id || 0);
      if (!(ticket > 0)) {
        log("Error: invalid live ticket");
        return;
      }
      try {
        const res = await api("/api/trades/close", { method: "POST", body: { ticket } });
        const closed = Number(res?.closed || 0);
        const failed = Array.isArray(res?.failed) ? res.failed : [];
        if (closed > 0) {
          log(`Trade #${ticket} closed.`);
        } else if (failed.length) {
          log(`Trade #${ticket} close failed: ${failed.join(", ")}`);
        } else {
          log(`Trade #${ticket} close request sent.`);
        }
        closeTradeDetailModal();
        await pollBackend();
        await fetchMarketCandles(true);
      } catch (err) {
        log(`Error: ${err.message}`);
      }
    }

    function chartKey(symbol, tf) {
      return `${symbol}|${tf}`;
    }

    function collectAllowedSymbolsFromInputs() {
      const raw = [normalizeSymbol(el.allowedSymbol1.value), normalizeSymbol(el.allowedSymbol2.value)];
      const out = [];
      raw.forEach(sym => {
        if (!sym) return;
        if (!out.includes(sym)) out.push(sym);
      });
      return out.slice(0, 2);
    }

    function syncAllowedSymbolInputs() {
      el.allowedSymbol1.value = state.allowedSymbols[0] || "";
      el.allowedSymbol2.value = state.allowedSymbols[1] || "";
    }

    function sameSymbolList(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i += 1) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }

    function setAllowedSymbols(symbols, syncInputs = true) {
      const out = [];
      (symbols || []).forEach(raw => {
        const sym = normalizeSymbol(raw);
        if (!sym) return;
        if (!out.includes(sym)) out.push(sym);
      });
      const next = out.slice(0, 2);
      if (sameSymbolList(state.allowedSymbols, next)) {
        if (syncInputs) syncAllowedSymbolInputs();
        return;
      }
      state.allowedSymbols = next;
      if (syncInputs) syncAllowedSymbolInputs();
      syncChartSymbolOptions();
    }

    function applyAllowedSymbols(logChange = true) {
      const symbols = collectAllowedSymbolsFromInputs();
      if (!symbols.length) {
        log("Error: Set at least one allowed market symbol");
        return false;
      }
      setAllowedSymbols(symbols, true);
      if (logChange) log(`Allowed markets set: ${symbols.join(", ")}`);
      schedulePersistChartMemory();
      return true;
    }

    function drawingKey() {
      if (!state.selectedSymbol) return "";
      return chartKey(state.selectedSymbol, state.chartTf);
    }

    function drawingsForCurrentChart() {
      const key = drawingKey();
      if (!key) return [];
      if (!state.chartDrawings[key]) state.chartDrawings[key] = [];
      return state.chartDrawings[key];
    }

    function setChartTool(tool) {
      state.chartTool = tool;
      state.chartPendingPoint = null;
      state.chartPendingPoints = [];
      state.chartDragStart = null;
      state.chartDragCurrent = null;
      state.chartPointerDown = false;
      state.chartPointerId = null;
      state.chartPanMode = false;
      state.chartScaleMode = false;
      state.chartPinchMode = false;
      state.chartPointerSamples = {};
      state.chartPositionDraft = null;
      if (tool !== "none") state.selectedDrawingIndex = -1;
      el.toolTrend.classList.toggle("active", tool === "trend");
      el.toolPoly.classList.toggle("active", tool === "poly");
      el.toolHLine.classList.toggle("active", tool === "hline");
      el.toolRect.classList.toggle("active", tool === "rect");
      el.toolLong.classList.toggle("active", tool === "long");
      el.toolShort.classList.toggle("active", tool === "short");
      drawMarketChart();
    }

    function syncChartSymbolOptions() {
      const observedSymbols = Array.from(new Set([
        ...state.trades.map(t => normalizeSymbol(t.symbol)).filter(Boolean),
        ...state.history.map(t => normalizeSymbol(t.symbol)).filter(Boolean),
      ])).sort();
      const symbols = state.allowedSymbols.length ? [...state.allowedSymbols] : observedSymbols;
      const prev = el.chartSymbol.value;
      el.chartSymbol.innerHTML = "";

      if (!symbols.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No symbols yet";
        el.chartSymbol.appendChild(opt);
        state.selectedSymbol = "";
        drawMarketChart();
        return;
      }

      symbols.forEach(sym => {
        const opt = document.createElement("option");
        opt.value = sym;
        opt.textContent = sym;
        el.chartSymbol.appendChild(opt);
      });

      const preferred = normalizeSymbol(state.preferredSymbol || "");
      const next = symbols.includes(prev) ? prev : (symbols.includes(state.selectedSymbol) ? state.selectedSymbol : (preferred && symbols.includes(preferred) ? preferred : symbols[0]));
      state.selectedSymbol = next;
      state.preferredSymbol = "";
      el.chartSymbol.value = next;
      restoreCachedCandlesFor(next, state.chartTf);
      fetchMarketCandles(false).catch(() => {});
    }

    async function fetchMarketCandles(force = false) {
      if (!state.selectedSymbol) return;
      const tf = el.chartTf.value || "M1";
      if (!force && state.chartTf !== tf) state.chartTf = tf;
      const sym = state.selectedSymbol;
      const key = chartKey(sym, state.chartTf);
      const cachedReady = restoreCachedCandlesFor(sym, state.chartTf);
      if (!state.backendApiOnline) {
        if (cachedReady) drawMarketChart();
        return;
      }
      try {
        const data = await api(`/api/market/candles?symbol=${encodeURIComponent(sym)}&tf=${encodeURIComponent(state.chartTf)}&count=320&since_running=0`);
        const incoming = Array.isArray(data.candles) ? data.candles : [];
        let mergedCandles = incoming;
        if (memory) {
          const payload = memory.upsertCandles(sym, state.chartTf, incoming, MAX_LOCAL_BARS);
          mergedCandles = Array.isArray(payload?.bars) ? payload.bars : incoming;
        }
        state.marketCandles[key] = mergedCandles.slice(-MAX_LOCAL_BARS);
        refreshLearningMemory(sym, state.chartTf, state.marketCandles[key]);
        if (data.warning && force) {
          log(`Chart feed warning: ${String(data.warning)}`);
        }
        const structure = data.structure || {};
        const incomingPoints = Array.isArray(structure.points) ? structure.points : [];
        const incomingFvg = Array.isArray(structure.fvg) ? structure.fvg : [];
        const prevStructure = state.marketStructure[key] || { points: [], fvg: [], updated_at: null, source: "none" };
        const hasIncoming = incomingPoints.length > 0 || incomingFvg.length > 0;
        if (hasIncoming) {
          state.marketStructure[key] = {
            points: incomingPoints,
            fvg: incomingFvg,
            updated_at: structure.updated_at || null,
            source: structure.source || "none"
          };
        } else {
          state.marketStructure[key] = {
            points: Array.isArray(prevStructure.points) ? prevStructure.points : [],
            fvg: Array.isArray(prevStructure.fvg) ? prevStructure.fvg : [],
            updated_at: prevStructure.updated_at || null,
            source: prevStructure.source || "cache"
          };
        }
        drawMarketChart();
        schedulePersistChartMemory();
      } catch (err) {
        const restored = restoreCachedCandlesFor(sym, state.chartTf);
        if (restored) drawMarketChart();
        if (force) log(`Chart data error: ${err.message}${restored ? " (loaded local cache)" : ""}`);
      }
    }

    function drawEmptyChart(ctx, w, h, message) {
      ctx.fillStyle = "#0b1528";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#8ea2cc";
      ctx.font = "14px Segoe UI";
      ctx.textAlign = "center";
      ctx.fillText(message, w / 2, h / 2);
      state.chartViewport = null;
    }

    function clampNumber(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function xForIndex(index, vp) {
      const rel = (Number(index) - vp.startIndex) + 0.5;
      return vp.left + (rel / Math.max(1, vp.count)) * vp.plotW;
    }

    function yForPrice(price, vp) {
      return vp.top + ((vp.hi - price) / Math.max(0.0000001, vp.hi - vp.lo)) * vp.plotH;
    }

    function indexFromX(x, vp) {
      const raw = ((x - vp.left) / Math.max(1, vp.plotW)) * vp.count - 0.5;
      return clampNumber(Math.round(vp.startIndex + raw), vp.startIndex, vp.endIndex - 1);
    }

    function priceFromY(y, vp) {
      const ratio = (y - vp.top) / Math.max(1, vp.plotH);
      return vp.hi - ratio * (vp.hi - vp.lo);
    }

    function inferPriceDigits(candles) {
      let digits = 2;
      candles.slice(-40).forEach(c => {
        const s = String(c.close ?? "");
        const idx = s.indexOf(".");
        if (idx >= 0) digits = Math.max(digits, s.length - idx - 1);
      });
      return Math.max(2, Math.min(6, digits));
    }

    function formatPrice(v, digits) {
      return Number(v || 0).toFixed(digits);
    }

    function formatSignedMoney(v, digits = 2) {
      const n = Number(v || 0);
      return `${n >= 0 ? "+" : ""}${n.toFixed(digits)}`;
    }

    function escHtml(v) {
      return String(v ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;");
    }

    function getReportDays() {
      const n = Number(el.reportDays?.value || 30);
      return clampNumber(Math.round(Number.isFinite(n) ? n : 30), 1, 3650);
    }

    function buildFallbackReport() {
      return {
        ok: true,
        generated_at: null,
        window_days: getReportDays(),
        account: {},
        totals: { trades: 0, wins: 0, losses: 0, win_rate_pct: 0, pnl: 0, avg_pnl: 0, best_trade: 0, worst_trade: 0 },
        snapshot: { latest_day: { day: "", trades: 0, pnl: 0 }, latest_week: { week: "", trades: 0, pnl: 0 } },
        strengths: [],
        weaknesses: [],
        by_day: [],
        by_week: [],
        ea_history_trades: [],
        recent_deals: [],
      };
    }

    function renderAccount(accountRaw = null) {
      const a = accountRaw && typeof accountRaw === "object" ? accountRaw : {};
      const bal = Number(a.balance);
      const eq = Number(a.equity);
      if (!state.connected || !Number.isFinite(bal) || !Number.isFinite(eq)) {
        el.balanceChip.textContent = "Balance: --";
        el.equityChip.textContent = "Equity: --";
        return;
      }
      el.balanceChip.textContent = `Balance: ${bal.toFixed(2)}`;
      el.equityChip.textContent = `Equity: ${eq.toFixed(2)}`;
    }

    function renderReportRows(targetEl, headers, rows, emptyText) {
      if (!targetEl) return;
      const head = `<div class="row header"><span>${escHtml(headers[0] || "")}</span><span>${escHtml(headers[1] || "")}</span><span>${escHtml(headers[2] || "")}</span></div>`;
      if (!Array.isArray(rows) || rows.length === 0) {
        targetEl.innerHTML = `${head}<div class="row"><span>${escHtml(emptyText || "No data")}</span><span>-</span><span>-</span></div>`;
        return;
      }
      targetEl.innerHTML = head + rows.map(r => `<div class="row"><span>${escHtml(r[0])}</span><span>${escHtml(r[1])}</span><span>${escHtml(r[2])}</span></div>`).join("");
    }

    function setReportTab(tab, persist = true) {
      const key = String(tab || "summary").toLowerCase();
      const valid = ["summary", "pnl", "sides", "symbols", "risks"];
      state.reportTab = valid.includes(key) ? key : "summary";
      if (persist) schedulePersistChartMemory();
      el.reportTabButtons.forEach(btn => btn.classList.toggle("active", String(btn.dataset.reportTab || "") === state.reportTab));
      if (el.reportTabSummary) el.reportTabSummary.classList.toggle("active", state.reportTab === "summary");
      if (el.reportTabPnl) el.reportTabPnl.classList.toggle("active", state.reportTab === "pnl");
      if (el.reportTabSides) el.reportTabSides.classList.toggle("active", state.reportTab === "sides");
      if (el.reportTabSymbols) el.reportTabSymbols.classList.toggle("active", state.reportTab === "symbols");
      if (el.reportTabRisks) el.reportTabRisks.classList.toggle("active", state.reportTab === "risks");
    }

    function svgLine(values, stroke = "#5ca6ff", fill = "rgba(70,136,230,0.16)") {
      const nums = (values || []).map(v => Number(v)).filter(v => Number.isFinite(v));
      if (nums.length < 2) return `<div class="hint">Not enough data</div>`;
      const w = 900;
      const h = 220;
      const padX = 18;
      const padY = 14;
      const minV = Math.min(...nums);
      const maxV = Math.max(...nums);
      const span = Math.max(0.000001, maxV - minV);
      const xStep = (w - padX * 2) / Math.max(1, nums.length - 1);
      const points = nums.map((v, i) => {
        const x = padX + i * xStep;
        const y = h - padY - ((v - minV) / span) * (h - padY * 2);
        return `${x.toFixed(2)},${y.toFixed(2)}`;
      });
      const area = [`${padX},${h - padY}`, ...points, `${(w - padX).toFixed(2)},${h - padY}`].join(" ");
      return `
        <svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none">
          <rect x="0" y="0" width="${w}" height="${h}" fill="transparent"></rect>
          <polyline points="${area}" fill="${fill}" stroke="none"></polyline>
          <polyline points="${points.join(" ")}" fill="none" stroke="${stroke}" stroke-width="2.2"></polyline>
        </svg>
      `;
    }

    function svgBars(values) {
      const nums = (values || []).map(v => Number(v)).filter(v => Number.isFinite(v));
      if (!nums.length) return `<div class="hint">Not enough data</div>`;
      const w = 900;
      const h = 220;
      const padX = 16;
      const padY = 14;
      const minV = Math.min(0, ...nums);
      const maxV = Math.max(0, ...nums);
      const span = Math.max(0.000001, maxV - minV);
      const baseline = h - padY - ((0 - minV) / span) * (h - padY * 2);
      const colW = Math.max(2, (w - padX * 2) / Math.max(1, nums.length) * 0.78);
      const step = (w - padX * 2) / Math.max(1, nums.length);
      const bars = nums.map((v, i) => {
        const x = padX + i * step + (step - colW) * 0.5;
        const y = h - padY - ((v - minV) / span) * (h - padY * 2);
        const top = Math.min(y, baseline);
        const barH = Math.max(1, Math.abs(y - baseline));
        const color = v >= 0 ? "#22c986" : "#e76478";
        return `<rect x="${x.toFixed(2)}" y="${top.toFixed(2)}" width="${colW.toFixed(2)}" height="${barH.toFixed(2)}" fill="${color}"></rect>`;
      }).join("");
      return `
        <svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none">
          <line x1="${padX}" y1="${baseline.toFixed(2)}" x2="${(w - padX).toFixed(2)}" y2="${baseline.toFixed(2)}" stroke="rgba(150,173,210,0.55)" stroke-width="1"></line>
          ${bars}
        </svg>
      `;
    }

    function renderReportAdvanced(reportRaw = null) {
      const report = reportRaw && typeof reportRaw === "object" ? reportRaw : buildFallbackReport();
      const byDayDesc = Array.isArray(report.by_day) ? report.by_day.slice() : [];
      const byDayAsc = byDayDesc.slice().reverse();
      const dayPnls = byDayAsc.map(r => Number(r.pnl || 0));
      const totals = report.totals || {};
      const startBalance = Number((report.account || {}).balance || 0) - Number(totals.pnl || 0);
      const curve = [];
      let bal = Number.isFinite(startBalance) ? startBalance : 0;
      dayPnls.forEach(p => {
        bal += Number(p || 0);
        curve.push(bal);
      });
      const drawdown = [];
      let peak = -Infinity;
      curve.forEach(v => {
        peak = Math.max(peak, v);
        const ddPct = peak > 0 ? ((peak - v) / peak) * 100 : 0;
        drawdown.push(ddPct);
      });

      if (el.reportCurveSummary) el.reportCurveSummary.innerHTML = svgLine(curve.length ? curve : [0, 0], "#66a9ff", "rgba(58,121,214,0.18)");
      if (el.reportPnlBars) el.reportPnlBars.innerHTML = svgBars(dayPnls.slice(-120));
      if (el.reportDrawdownCurve) el.reportDrawdownCurve.innerHTML = svgLine(drawdown.length ? drawdown : [0, 0], "#ff8b5e", "rgba(225,111,68,0.16)");

      const deals = Array.isArray(report.recent_deals) ? report.recent_deals.slice() : [];
      let longCount = 0;
      let shortCount = 0;
      let longPnl = 0;
      let shortPnl = 0;
      deals.forEach(d => {
        const side = String(d.side || "").toUpperCase();
        const pnl = Number(d.pnl || 0);
        if (side === "BUY") {
          longCount += 1;
          longPnl += pnl;
        } else if (side === "SELL") {
          shortCount += 1;
          shortPnl += pnl;
        }
      });
      const totalSides = Math.max(1, longCount + shortCount);
      const longPct = (longCount / totalSides) * 100;
      const shortPct = 100 - longPct;
      if (el.reportLongShortSplit) {
        el.reportLongShortSplit.innerHTML = `
          <div style="display:grid;grid-template-columns:170px 1fr;gap:12px;align-items:center;">
            <div style="width:150px;height:150px;border-radius:50%;background:conic-gradient(#63a9ff 0 ${longPct.toFixed(2)}%, #ff8a63 ${longPct.toFixed(2)}% 100%);margin:0 auto;"></div>
            <div style="font-size:0.9rem;color:#cde0ff;line-height:1.7;">
              <div>Long Trades: <b>${longCount}</b> (${longPct.toFixed(2)}%)</div>
              <div>Short Trades: <b>${shortCount}</b> (${shortPct.toFixed(2)}%)</div>
              <div>Long P/L: <b style="color:${longPnl >= 0 ? "var(--ok)" : "var(--bad)"}">${formatSignedMoney(longPnl, 2)}</b></div>
              <div>Short P/L: <b style="color:${shortPnl >= 0 ? "var(--ok)" : "var(--bad)"}">${formatSignedMoney(shortPnl, 2)}</b></div>
            </div>
          </div>
        `;
      }

      renderReportRows(
        el.reportSideQuality,
        ["Side", "Trades", "P/L"],
        [
          ["LONG", String(longCount), formatSignedMoney(longPnl, 2)],
          ["SHORT", String(shortCount), formatSignedMoney(shortPnl, 2)],
        ],
        "No side data"
      );

      const bySymbol = Array.isArray(report.by_symbol) ? report.by_symbol.slice(0, 14) : [];
      if (el.reportSymbolBars) {
        if (!bySymbol.length) {
          el.reportSymbolBars.innerHTML = `<div class="hint">No symbol data yet</div>`;
        } else {
          const maxAbs = Math.max(1, ...bySymbol.map(r => Math.abs(Number(r.pnl || 0))));
          el.reportSymbolBars.innerHTML = bySymbol.map(r => {
            const sym = escHtml(String(r.symbol || "-"));
            const pnl = Number(r.pnl || 0);
            const width = Math.max(2, Math.round((Math.abs(pnl) / maxAbs) * 88));
            const color = pnl >= 0 ? "#1fbc82" : "#e76478";
            return `<div style="display:grid;grid-template-columns:180px 1fr 90px;gap:8px;align-items:center;margin-bottom:8px;">
              <span style="color:#d8e8ff;font-size:0.84rem;">${sym}</span>
              <div style="height:10px;border-radius:999px;background:#11213d;overflow:hidden;">
                <div style="height:100%;width:${width}%;background:${color};"></div>
              </div>
              <span style="text-align:right;color:${pnl >= 0 ? "var(--ok)" : "var(--bad)"};font-size:0.84rem;">${formatSignedMoney(pnl, 2)}</span>
            </div>`;
          }).join("");
        }
      }

      const absDeals = deals.slice().sort((a, b) => Number(a.close_ts || 0) - Number(b.close_ts || 0));
      let consecWins = 0;
      let consecLoss = 0;
      let maxWins = 0;
      let maxLoss = 0;
      let grossWin = 0;
      let grossLoss = 0;
      absDeals.forEach(d => {
        const pnl = Number(d.pnl || 0);
        if (pnl >= 0) {
          consecWins += 1;
          consecLoss = 0;
          grossWin += pnl;
        } else {
          consecLoss += 1;
          consecWins = 0;
          grossLoss += Math.abs(pnl);
        }
        maxWins = Math.max(maxWins, consecWins);
        maxLoss = Math.max(maxLoss, consecLoss);
      });
      const pf = grossLoss > 0 ? (grossWin / grossLoss) : (grossWin > 0 ? 999 : 0);
      renderReportRows(
        el.reportRiskStats,
        ["Metric", "Value", "Detail"],
        [
          ["Max Drawdown", `${(drawdown.length ? Math.max(...drawdown) : 0).toFixed(2)}%`, "From report window"],
          ["Profit Factor", pf.toFixed(2), "Gross Win / Gross Loss"],
          ["Max Consec Wins", String(maxWins), "Streak quality"],
          ["Max Consec Losses", String(maxLoss), "Risk pressure"],
          ["Best Trade", formatSignedMoney(Number(totals.best_trade || 0), 2), "Single deal"],
          ["Worst Trade", formatSignedMoney(Number(totals.worst_trade || 0), 2), "Single deal"],
        ],
        "No risk data"
      );

      renderReportRows(
        el.reportRecentDeals,
        ["Symbol", "Close", "P/L"],
        deals.slice(0, 120).map(r => [
          `${String(r.symbol || "-")} (${String(r.deal_id || "-")})`,
          String(r.close_time || "-"),
          formatSignedMoney(Number(r.pnl || 0), 2),
        ]),
        "No recent deals"
      );
    }

    function renderReport(reportRaw = null) {
      const report = reportRaw && typeof reportRaw === "object" ? reportRaw : buildFallbackReport();
      const totals = report?.totals && typeof report.totals === "object" ? report.totals : {};
      const latestDay = report?.snapshot?.latest_day || {};
      const latestWeek = report?.snapshot?.latest_week || {};

      const totalPnl = Number(totals.pnl || 0);
      el.reportTotalPnl.textContent = formatSignedMoney(totalPnl, 2);
      el.reportTotalPnl.classList.toggle("insight-pos", totalPnl >= 0);
      el.reportTotalPnl.classList.toggle("insight-neg", totalPnl < 0);
      el.reportWinRate.textContent = `${Number(totals.win_rate_pct || 0).toFixed(2)}%`;
      el.reportTrades.textContent = `${Number(totals.trades || 0)}`;

      const dayPnl = Number(latestDay?.pnl || 0);
      const weekPnl = Number(latestWeek?.pnl || 0);
      el.reportDailyPnl.textContent = `${formatSignedMoney(dayPnl, 2)}${latestDay?.day ? ` (${latestDay.day})` : ""}`;
      el.reportWeeklyPnl.textContent = `${formatSignedMoney(weekPnl, 2)}${latestWeek?.week ? ` (${latestWeek.week})` : ""}`;
      el.reportDailyPnl.classList.toggle("insight-pos", dayPnl >= 0);
      el.reportDailyPnl.classList.toggle("insight-neg", dayPnl < 0);
      el.reportWeeklyPnl.classList.toggle("insight-pos", weekPnl >= 0);
      el.reportWeeklyPnl.classList.toggle("insight-neg", weekPnl < 0);

      const generated = String(report.generated_at || "").trim();
      el.reportGenerated.textContent = generated || "No report yet";

      const strengths = Array.isArray(report.strengths) ? report.strengths : [];
      const weaknesses = Array.isArray(report.weaknesses) ? report.weaknesses : [];
      const byDay = Array.isArray(report.by_day) ? report.by_day.slice(0, 20) : [];
      const byWeek = Array.isArray(report.by_week) ? report.by_week.slice(0, 20) : [];
      const eaTrades = Array.isArray(report.ea_history_trades) ? report.ea_history_trades.slice(0, 60) : [];

      renderReportRows(
        el.reportStrengths,
        ["Symbol", "Trades", "P/L | WR"],
        strengths.map(r => [
          String(r.symbol || "-"),
          String(Number(r.trades || 0)),
          `${formatSignedMoney(Number(r.pnl || 0), 2)} | ${Number(r.win_rate_pct || 0).toFixed(1)}%`,
        ]),
        "No strong areas yet"
      );

      renderReportRows(
        el.reportWeaknesses,
        ["Symbol", "Trades", "P/L | WR"],
        weaknesses.map(r => [
          String(r.symbol || "-"),
          String(Number(r.trades || 0)),
          `${formatSignedMoney(Number(r.pnl || 0), 2)} | ${Number(r.win_rate_pct || 0).toFixed(1)}%`,
        ]),
        "No weak areas yet"
      );

      renderReportRows(
        el.reportByDay,
        ["Day", "Trades", "P/L"],
        byDay.map(r => [String(r.day || "-"), String(Number(r.trades || 0)), formatSignedMoney(Number(r.pnl || 0), 2)]),
        "No daily data yet"
      );

      renderReportRows(
        el.reportByWeek,
        ["Week", "Trades", "P/L"],
        byWeek.map(r => [String(r.week || "-"), String(Number(r.trades || 0)), formatSignedMoney(Number(r.pnl || 0), 2)]),
        "No weekly data yet"
      );

      renderReportRows(
        el.reportEaTrades,
        ["Symbol", "Close", "P/L"],
        eaTrades.map(r => [
          `${String(r.symbol || "-")} (${String(r.id || r.deal_id || "-")})`,
          String(r.close_time || "-"),
          formatSignedMoney(Number(r.pnl || 0), 2),
        ]),
        "No EA closed trades yet"
      );

      renderReportAdvanced(report);
    }

    function downloadTextFile(filename, text, mime = "text/plain;charset=utf-8") {
      const blob = new Blob([text], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1200);
    }

    function toCsvCell(value) {
      const s = String(value ?? "");
      if (/["\n,]/.test(s)) return `"${s.replace(/"/g, "\"\"")}"`;
      return s;
    }

    function buildReportCsv(reportRaw = null) {
      const report = reportRaw && typeof reportRaw === "object" ? reportRaw : buildFallbackReport();
      const lines = [];
      const totals = report.totals || {};
      lines.push("section,key,value");
      lines.push(`meta,generated_at,${toCsvCell(report.generated_at || "")}`);
      lines.push(`meta,window_days,${toCsvCell(report.window_days || "")}`);
      lines.push(`totals,trades,${toCsvCell(totals.trades || 0)}`);
      lines.push(`totals,wins,${toCsvCell(totals.wins || 0)}`);
      lines.push(`totals,losses,${toCsvCell(totals.losses || 0)}`);
      lines.push(`totals,win_rate_pct,${toCsvCell(totals.win_rate_pct || 0)}`);
      lines.push(`totals,pnl,${toCsvCell(totals.pnl || 0)}`);
      lines.push(`totals,avg_pnl,${toCsvCell(totals.avg_pnl || 0)}`);
      lines.push("");
      lines.push("strength_symbol,trades,win_rate_pct,pnl");
      (Array.isArray(report.strengths) ? report.strengths : []).forEach(r => {
        lines.push([toCsvCell(r.symbol || ""), toCsvCell(r.trades || 0), toCsvCell(r.win_rate_pct || 0), toCsvCell(r.pnl || 0)].join(","));
      });
      lines.push("");
      lines.push("weak_symbol,trades,win_rate_pct,pnl");
      (Array.isArray(report.weaknesses) ? report.weaknesses : []).forEach(r => {
        lines.push([toCsvCell(r.symbol || ""), toCsvCell(r.trades || 0), toCsvCell(r.win_rate_pct || 0), toCsvCell(r.pnl || 0)].join(","));
      });
      lines.push("");
      lines.push("day,trades,wins,losses,pnl");
      (Array.isArray(report.by_day) ? report.by_day : []).forEach(r => {
        lines.push([toCsvCell(r.day || ""), toCsvCell(r.trades || 0), toCsvCell(r.wins || 0), toCsvCell(r.losses || 0), toCsvCell(r.pnl || 0)].join(","));
      });
      lines.push("");
      lines.push("week,trades,wins,losses,pnl");
      (Array.isArray(report.by_week) ? report.by_week : []).forEach(r => {
        lines.push([toCsvCell(r.week || ""), toCsvCell(r.trades || 0), toCsvCell(r.wins || 0), toCsvCell(r.losses || 0), toCsvCell(r.pnl || 0)].join(","));
      });
      lines.push("");
      lines.push("ea_trade_id,symbol,close_time,pnl");
      (Array.isArray(report.ea_history_trades) ? report.ea_history_trades : []).forEach(r => {
        lines.push([toCsvCell(r.id || r.deal_id || ""), toCsvCell(r.symbol || ""), toCsvCell(r.close_time || ""), toCsvCell(r.pnl || 0)].join(","));
      });
      return lines.join("\n");
    }

    function exportReportJson() {
      const report = state.reportSummary && typeof state.reportSummary === "object" ? state.reportSummary : buildFallbackReport();
      const stamp = new Date().toISOString().replace(/[:.]/g, "-");
      downloadTextFile(`kutea26_report_${stamp}.json`, JSON.stringify(report, null, 2), "application/json;charset=utf-8");
      log("Report JSON exported");
    }

    function exportReportCsv() {
      const report = state.reportSummary && typeof state.reportSummary === "object" ? state.reportSummary : buildFallbackReport();
      const stamp = new Date().toISOString().replace(/[:.]/g, "-");
      downloadTextFile(`kutea26_report_${stamp}.csv`, buildReportCsv(report), "text/csv;charset=utf-8");
      log("Report CSV exported");
    }

    async function refreshReport(manual = false) {
      const days = getReportDays();
      try {
        const report = await api(`/api/reports/summary?days=${days}`);
        if (report && typeof report === "object" && report.ok !== false) {
          state.reportSummary = report;
          state.reportLastFetchMs = Date.now();
          renderReport(report);
          if (manual) log("Report refreshed");
        }
      } catch (err) {
        if (manual) log(`Report refresh error: ${err.message}`);
        renderReport(state.reportSummary || buildFallbackReport());
      }
    }

    function formatTimeLabel(unixTs) {
      return new Date(Number(unixTs) * 1000).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }

    function buildFallbackInsight() {
      const floating = (state.trades || [])
        .filter(t => String(t.status || "Open").toLowerCase() === "open")
        .reduce((acc, t) => acc + Number(t.pnl || 0), 0);
      let thinking = "Idle";
      let waiting = "Connect broker and start EA";
      let active = "None";
      let mode = "IDLE";
      if (state.connected && !state.eaRunning) {
        thinking = "Broker connected";
        waiting = "Start EA";
        active = "No open positions";
      } else if (state.connected && state.eaRunning && (state.trades || []).length === 0) {
        thinking = "Scanning markets";
        waiting = state.triggerFlowMode === "BUY_ONLY"
          ? "Buy-side entry conditions"
          : state.triggerFlowMode === "SELL_ONLY"
            ? "Sell-side entry conditions"
            : state.triggerFlowMode === "AUTO"
              ? "Auto bias entry conditions"
              : "Entry conditions";
        active = state.selectedSymbol || "Allowed symbols";
        mode = "RUNNING";
      } else if (state.connected && state.eaRunning && (state.trades || []).length > 0) {
        thinking = `Managing ${(state.trades || []).length} open trade(s)`;
        waiting = "SL/TP hit or close signal";
        active = Array.from(new Set((state.trades || []).map(t => String(t.symbol || "")).filter(Boolean))).join(", ") || "Open positions";
        mode = "RUNNING";
      }
      return {
        session: {
          realized: 0,
          floating,
          total: floating,
          trades: 0,
          wins: 0,
          losses: 0
        },
        bot_state: {
          mode,
          thinking,
          waiting_for: waiting,
          active
        },
        manual_trade_enabled: !!state.manualTradeEnabled,
        trigger_flow_mode: normalizeTriggerFlowMode(state.triggerFlowMode),
        supervisor: {
          enabled: false,
          loaded: false,
          active: {
            available: false,
            active_mode: "NO_TRADE",
            confidence: 0,
            preferred_timeframe: "M1",
            selected_symbol: state.selectedSymbol || ""
          }
        },
        tag_stats: [],
        tag_stats_updated_at: null
      };
    }

    function renderTagStats(insight) {
      const rowsRaw = Array.isArray(insight?.tag_stats) ? insight.tag_stats : [];
      const updated = insight?.tag_stats_updated_at ? String(insight.tag_stats_updated_at) : "";
      el.tagStatsUpdated.textContent = updated ? `Updated: ${updated}` : "No telemetry yet";
      let activeCount = 0;
      let pausedCount = 0;
      const rows = rowsRaw.slice().sort((a, b) => {
        const ap = String(a?.status || "").toLowerCase() === "paused" ? 0 : 1;
        const bp = String(b?.status || "").toLowerCase() === "paused" ? 0 : 1;
        if (ap !== bp) return ap - bp;
        return Number(b?.samples || 0) - Number(a?.samples || 0);
      }).slice(0, 40);

      const head = `<div class="tag-stats-row header"><span>Tag</span><span>S</span><span>W</span><span>L</span><span>Status</span></div>`;
      if (!rows.length) {
        el.tagStatsSummary.textContent = "Active: 0 | Paused: 0";
        el.tagStatsTable.innerHTML = `${head}<div class="tag-stats-row"><span>Waiting for tag data...</span><span>0</span><span>0</span><span>0</span><span class="tag-status active">Active</span></div>`;
        return;
      }

      const body = rows.map(r => {
        const tag = escHtml(r.tag || "-");
        const s = Number(r.samples || 0);
        const w = Number(r.wins || 0);
        const l = Number(r.losses || 0);
        const bars = Math.max(0, Number(r.bars_left || 0));
        const paused = String(r.status || "").toLowerCase() === "paused" || bars > 0;
        if (paused) pausedCount += 1;
        else activeCount += 1;
        const statusLabel = paused ? `Paused (${bars} bars)` : "Active";
        const statusClass = paused ? "paused" : "active";
        return `<div class="tag-stats-row"><span title="${tag}">${tag}</span><span>${s}</span><span>${w}</span><span>${l}</span><span class="tag-status ${statusClass}">${escHtml(statusLabel)}</span></div>`;
      }).join("");
      el.tagStatsSummary.textContent = `Active: ${activeCount} | Paused: ${pausedCount}`;
      el.tagStatsTable.innerHTML = head + body;
    }

    function buildFallbackAnalytics() {
      return {
        ok: true,
        window_days: 7,
        totals: { trades: 0, wins: 0, losses: 0, pnl: 0, win_rate_pct: 0 },
        by_symbol: []
      };
    }

    function buildFallbackWatchdog() {
      return {
        ok: true,
        watchdog: {
          enabled: false,
          recover_attempts: 0,
          recover_success: 0,
          last_alert: "",
          last_snapshot_ok_at: null
        }
      };
    }

    function renderAnalytics(analyticsRaw = null, watchdogRaw = null) {
      const analytics = analyticsRaw && typeof analyticsRaw === "object" ? analyticsRaw : buildFallbackAnalytics();
      const totals = analytics?.totals && typeof analytics.totals === "object" ? analytics.totals : {};
      const winRate = Number(totals.win_rate_pct || 0);
      const pnl = Number(totals.pnl || 0);
      const trades = Number(totals.trades || 0);
      const days = Number(analytics.window_days || 7);
      el.analyticsWinRateValue.textContent = `${winRate.toFixed(2)}%`;
      el.analyticsPnlValue.textContent = formatSignedMoney(pnl, 2);
      el.analyticsPnlValue.classList.toggle("insight-pos", pnl >= 0);
      el.analyticsPnlValue.classList.toggle("insight-neg", pnl < 0);
      el.analyticsTradesValue.textContent = `${trades}`;

      const rowsRaw = Array.isArray(analytics.by_symbol) ? analytics.by_symbol.slice(0, 10) : [];
      const head = `<div class="analytics-row header"><span>Symbol</span><span>Trades</span><span>P/L</span></div>`;
      if (!rowsRaw.length) {
        el.analyticsSymbols.innerHTML = `${head}<div class="analytics-row"><span>Waiting for analytics...</span><span>0</span><span>0.00</span></div>`;
      } else {
        const body = rowsRaw.map(row => {
          const sym = escHtml(String(row.symbol || "-"));
          const t = Number(row.trades || 0);
          const p = Number(row.pnl || 0);
          const pText = formatSignedMoney(p, 2);
          return `<div class="analytics-row"><span>${sym}</span><span>${t}</span><span style="color:${p >= 0 ? "var(--ok)" : "var(--bad)"}">${pText}</span></div>`;
        }).join("");
        el.analyticsSymbols.innerHTML = head + body;
      }

      const wdWrap = watchdogRaw && typeof watchdogRaw === "object" ? watchdogRaw : buildFallbackWatchdog();
      const wd = wdWrap?.watchdog && typeof wdWrap.watchdog === "object" ? wdWrap.watchdog : {};
      const wdEnabled = !!wd.enabled;
      const wdAttempts = Number(wd.recover_attempts || 0);
      const wdSuccess = Number(wd.recover_success || 0);
      const wdLastAlert = String(wd.last_alert || "").trim();
      const wdLastOk = String(wd.last_snapshot_ok_at || "").trim();
      const wdLine1 = `Watchdog: ${wdEnabled ? "On" : "Off"} | Recover: ${wdSuccess}/${wdAttempts} | Window: ${days}d`;
      const wdLine2 = wdLastAlert ? wdLastAlert : (wdLastOk ? `Last MT5 Snapshot: ${wdLastOk}` : "No watchdog alert");
      const wdBad = wdEnabled && wdLastAlert && /stale|failed|error|down|unauthorized/i.test(wdLastAlert);
      el.watchdogAlertBox.classList.toggle("bad", !!wdBad);
      el.watchdogAlertBox.textContent = `${wdLine1}\n${wdLine2}`;

      const updatedLabel = state.analyticsLastFetchMs > 0
        ? new Date(state.analyticsLastFetchMs).toLocaleTimeString()
        : "No analytics yet";
      el.analyticsUpdated.textContent = state.analyticsLastFetchMs > 0 ? `Updated: ${updatedLabel}` : updatedLabel;
    }

    function renderInsight(insightRaw = null) {
      const insight = insightRaw && typeof insightRaw === "object" ? insightRaw : buildFallbackInsight();
      state.sessionInsight = insight;
      state.supervisorStatus = (insight && typeof insight.supervisor === "object") ? insight.supervisor : null;
      setManualTradeEnabled(!!insight.manual_trade_enabled, "backend");
      setTriggerFlowMode(insight.trigger_flow_mode || state.triggerFlowMode, "backend");
      const session = insight.session || {};
      const bot = insight.bot_state || {};
      const supWrap = state.supervisorStatus && typeof state.supervisorStatus === "object" ? state.supervisorStatus : {};
      const sup = supWrap.active && typeof supWrap.active === "object" ? supWrap.active : {};
      const realized = Number(session.realized || 0);
      const floating = Number(session.floating || 0);
      const total = Number(session.total || (realized + floating));
      const trades = Number(session.trades || 0);
      const wins = Number(session.wins || 0);
      const losses = Number(session.losses || 0);
      const totalText = formatSignedMoney(total, 2);
      el.sessionPnlChip.textContent = `Session P/L: ${totalText}`;
      el.sessionPnlValue.textContent = totalText;
      el.sessionPnlValue.classList.toggle("insight-pos", total >= 0);
      el.sessionPnlValue.classList.toggle("insight-neg", total < 0);
      el.sessionPnlMeta.textContent = `Realized: ${formatSignedMoney(realized, 2)} | Floating: ${formatSignedMoney(floating, 2)} | Trades: ${trades} (W:${wins} L:${losses})`;
      const thinking = String(bot.thinking || "Idle");
      const waiting = String(bot.waiting_for || "Waiting");
      const active = String(bot.active || "None");
      const mode = String(bot.mode || "IDLE").toUpperCase();
      const supMode = String(sup.active_mode || "NO_TRADE").toUpperCase();
      const supConf = Number(sup.confidence || 0);
      const supTf = String(sup.preferred_timeframe || "M1").toUpperCase();
      const supSymbol = String(sup.selected_symbol || active || state.selectedSymbol || "");
      const supLoaded = !!supWrap.loaded;
      const supAvailable = !!sup.available;
      const supText = supAvailable
        ? `Supervisor: ${supMode} ${Math.round(supConf * 1000) / 10}% (${supTf})`
        : (supLoaded ? "Supervisor: No symbol profile" : "Supervisor: Profile not loaded");
      el.botModeChip.textContent = `Bot: ${mode}`;
      if (el.supervisorChip) el.supervisorChip.textContent = supText;
      el.botThinkingValue.textContent = thinking;
      el.botActivityMeta.textContent = `Active: ${active}\nWaiting: ${waiting}\nMode: ${mode}\nTrigger: ${state.triggerFlowMode}\nSupervisor: ${supMode} (${Math.round(supConf * 1000) / 10}%) ${supTf}${supSymbol ? ` | ${supSymbol}` : ""}`;
      renderLastBlockChip();
      const supSig = `${supMode}|${supTf}|${Math.round(supConf * 1000)}|${supSymbol}`;
      if (supAvailable && supSig !== state.lastSupervisorSignature) {
        state.lastSupervisorSignature = supSig;
        log(`[TriggerFlow] Supervisor mode ${supMode} (${(supConf * 100).toFixed(1)}%) ${supSymbol ? `on ${supSymbol}` : ""}`.trim());
      }
      renderTagStats(insight);
    }

    function findClosestCandleIndexByTime(candles, unixTs) {
      if (!Array.isArray(candles) || candles.length === 0 || !Number.isFinite(unixTs)) return null;
      let lo = 0;
      let hi = candles.length - 1;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        const t = Number(candles[mid].time || 0);
        if (t < unixTs) lo = mid + 1;
        else if (t > unixTs) hi = mid - 1;
        else return mid;
      }
      const i1 = clampNumber(lo, 0, candles.length - 1);
      const i0 = clampNumber(i1 - 1, 0, candles.length - 1);
      const d0 = Math.abs(Number(candles[i0].time || 0) - unixTs);
      const d1 = Math.abs(Number(candles[i1].time || 0) - unixTs);
      return d0 <= d1 ? i0 : i1;
    }

    function drawEAStructureOverlay(ctx, vp, candles, structure) {
      if (!structure || typeof structure !== "object") return;
      const points = Array.isArray(structure.points) ? structure.points.slice(-120) : [];
      const fvgs = Array.isArray(structure.fvg) ? structure.fvg.slice(-80) : [];
      const colorMap = {
        HH: "#53d6ff",
        HL: "#2ad28a",
        LH: "#ffb85e",
        LL: "#ff6f82",
      };

      fvgs.forEach(z => {
        const low = Number(z.low);
        const high = Number(z.high);
        if (!Number.isFinite(low) || !Number.isFinite(high)) return;
        const t1 = Number(z.t1);
        const t2 = Number(z.t2);
        let i1 = Number.isFinite(t1) ? findClosestCandleIndexByTime(candles, t1) : null;
        let i2 = Number.isFinite(t2) ? findClosestCandleIndexByTime(candles, t2) : null;
        if (!Number.isFinite(i1)) i1 = Math.max(0, candles.length - 24);
        if (!Number.isFinite(i2)) i2 = candles.length - 1;
        const abs1 = vp.startIndex + clampNumber(Number(i1), 0, vp.count - 1);
        const abs2 = vp.startIndex + clampNumber(Number(i2), 0, vp.count - 1);
        const x1 = xForIndex(Math.min(abs1, abs2), vp);
        const x2 = xForIndex(Math.max(abs1, abs2), vp);
        const y1 = yForPrice(high, vp);
        const y2 = yForPrice(low, vp);
        const top = Math.min(y1, y2);
        const h = Math.max(1, Math.abs(y2 - y1));
        const side = String(z.side || "").toLowerCase();
        const fill = side === "bear" ? "rgba(239,83,92,0.16)" : "rgba(27,181,129,0.16)";
        const stroke = side === "bear" ? "rgba(239,83,92,0.58)" : "rgba(27,181,129,0.58)";
        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;
        ctx.lineWidth = 1;
        ctx.fillRect(x1, top, Math.max(2, x2 - x1), h);
        ctx.strokeRect(x1, top, Math.max(2, x2 - x1), h);
      });

      ctx.font = "11px Segoe UI";
      points.forEach(p => {
        const typ = String(p.type || "").toUpperCase();
        if (!colorMap[typ]) return;
        const price = Number(p.price);
        if (!Number.isFinite(price)) return;
        const ts = Number(p.time);
        const relIdx = Number.isFinite(ts) ? findClosestCandleIndexByTime(candles, ts) : (candles.length - 1);
        if (!Number.isFinite(relIdx)) return;
        const absIndex = vp.startIndex + clampNumber(Number(relIdx), 0, vp.count - 1);
        const x = xForIndex(absIndex, vp);
        const y = yForPrice(price, vp);
        ctx.fillStyle = colorMap[typ];
        ctx.strokeStyle = "#0b1220";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(x, y, 3.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        drawPriceTag(ctx, x + 6, y - 10, typ, "#1b2f4f", "#dff0ff", vp.top, vp.top + vp.plotH);
      });
    }

    function chartPointFromEvent(evt) {
      if (!state.chartViewport) return null;
      const rect = el.marketChart.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      const vp = state.chartViewport;
      const inside = x >= vp.left && x <= (vp.left + vp.plotW) && y >= vp.top && y <= (vp.top + vp.plotH);
      const axis = x > (vp.left + vp.plotW) && x <= (vp.left + vp.plotW + vp.right) && y >= vp.top && y <= (vp.top + vp.plotH);
      if (!inside && !axis) return { x, y, inside: false, axis: false, vp };
      const px = clampNumber(x, vp.left, vp.left + vp.plotW);
      return {
        x,
        y,
        inside,
        axis,
        vp,
        i: indexFromX(px, vp),
        p: priceFromY(y, vp),
      };
    }

    function trackPointer(evt, pt = null) {
      if (evt.pointerId === undefined || evt.pointerId === null) return;
      const point = pt || chartPointFromEvent(evt);
      if (!point) return;
      state.chartPointerSamples[String(evt.pointerId)] = { x: point.x, y: point.y };
    }

    function untrackPointer(pointerId) {
      if (pointerId === undefined || pointerId === null) return;
      delete state.chartPointerSamples[String(pointerId)];
    }

    function pointerSamples() {
      const rows = Object.values(state.chartPointerSamples || {});
      return rows.filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
    }

    function beginPinch(vp) {
      const pts = pointerSamples();
      if (pts.length < 2) return false;
      const a = pts[0];
      const b = pts[1];
      state.chartPinchMode = true;
      state.chartPanMode = false;
      state.chartScaleMode = false;
      state.chartPinchStartDist = Math.max(8, Math.hypot(a.x - b.x, a.y - b.y));
      state.chartPinchStartCenterX = (a.x + b.x) / 2;
      state.chartPinchStartCenterY = (a.y + b.y) / 2;
      state.chartPinchStartVisible = state.chartVisibleCount || vp.count || 150;
      state.chartPinchStartYZoom = Number(state.chartYZoom || 1);
      state.chartPinchStartPanBars = Number(state.chartPanBars || 0);
      state.chartPinchStartYShift = Number(state.chartYShift || 0);
      return true;
    }

    function drawPriceTag(ctx, x, y, text, bg, fg = "#f2f7ff", minY = null, maxY = null) {
      const padX = 6;
      const h = 18;
      const w = ctx.measureText(text).width + padX * 2;
      const cy = (minY !== null && maxY !== null) ? clampNumber(y, minY + Math.floor(h / 2), maxY - Math.floor(h / 2)) : y;
      ctx.fillStyle = bg;
      ctx.fillRect(x, cy - Math.floor(h / 2), w, h);
      ctx.fillStyle = fg;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText(text, x + padX, cy);
    }

    function drawPositionProjection(ctx, vp, pos, digits, includeHandles = false) {
      const side = String(pos.side || "").toUpperCase() === "SHORT" ? "SHORT" : "LONG";
      const entry = Number(pos.entry);
      const stop = Number(pos.stop);
      const target = Number(pos.target);
      const hasStop = Number.isFinite(stop);
      const hasTarget = Number.isFinite(target);
      if (!Number.isFinite(entry)) return;

      const defaultStart = vp.endIndex - Math.max(10, Math.floor(vp.count * 0.30));
      const defaultEnd = vp.endIndex - 2;
      const idx1 = Number.isFinite(pos.i1) ? Number(pos.i1) : defaultStart;
      const idx2 = Number.isFinite(pos.i2) ? Number(pos.i2) : defaultEnd;
      let x1 = xForIndex(Math.min(idx1, idx2), vp);
      let x2 = xForIndex(Math.max(idx1, idx2), vp);
      x1 = clampNumber(x1, vp.left + 2, vp.left + vp.plotW - 2);
      x2 = clampNumber(x2, vp.left + 2, vp.left + vp.plotW - 2);
      if (Math.abs(x2 - x1) < 18) x2 = Math.min(vp.left + vp.plotW - 2, x1 + 18);

      const yEntry = yForPrice(entry, vp);
      const yStop = hasStop ? yForPrice(stop, vp) : null;
      const yTarget = hasTarget ? yForPrice(target, vp) : null;
      const entryOnly = !hasStop && !hasTarget;

      const red = "rgba(239,83,92,0.28)";
      const green = "rgba(27,181,129,0.28)";

      if (entryOnly) {
        ctx.setLineDash([3, 4]);
        ctx.strokeStyle = side === "SHORT" ? "rgba(239,83,92,0.85)" : "rgba(27,181,129,0.85)";
        ctx.beginPath();
        ctx.moveTo(vp.left, yEntry);
        ctx.lineTo(vp.left + vp.plotW, yEntry);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.font = "11px Segoe UI";
        drawPriceTag(ctx, x1 + 6, yEntry, `Entry: ${formatPrice(entry, digits)}`, "#22456f", "#f2f7ff", vp.top, vp.top + vp.plotH);
        if (includeHandles) {
          ctx.fillStyle = "#f8fdff";
          ctx.strokeStyle = "#4f86ff";
          [[x1, yEntry], [x2, yEntry]].forEach(([hx, hy]) => {
            ctx.beginPath();
            ctx.rect(hx - 4, hy - 4, 8, 8);
            ctx.fill();
            ctx.stroke();
          });
        }
        return;
      }

      if (hasStop && yStop !== null) {
        const rTop = Math.min(yEntry, yStop);
        const rBot = Math.max(yEntry, yStop);
        ctx.fillStyle = red;
        ctx.fillRect(x1, rTop, x2 - x1, Math.max(1, rBot - rTop));
      }
      if (hasTarget && yTarget !== null) {
        const gTop = Math.min(yEntry, yTarget);
        const gBot = Math.max(yEntry, yTarget);
        ctx.fillStyle = green;
        ctx.fillRect(x1, gTop, x2 - x1, Math.max(1, gBot - gTop));
      }

      const yVals = [yEntry];
      if (hasStop && yStop !== null) yVals.push(yStop);
      if (hasTarget && yTarget !== null) yVals.push(yTarget);
      const boxTop = Math.min(...yVals);
      const boxBot = Math.max(...yVals);
      ctx.strokeStyle = "rgba(170,190,230,0.75)";
      ctx.lineWidth = 1;
      ctx.strokeRect(x1, boxTop, Math.max(1, x2 - x1), Math.max(1, boxBot - boxTop));

      ctx.setLineDash([3, 4]);
      ctx.strokeStyle = "rgba(160,180,220,0.55)";
      ctx.beginPath();
      ctx.moveTo(vp.left, yEntry);
      ctx.lineTo(vp.left + vp.plotW, yEntry);
      ctx.stroke();
      ctx.setLineDash([]);

      const risk = hasStop ? Math.abs(entry - stop) : 0;
      const reward = hasTarget ? Math.abs(target - entry) : 0;
      const rr = (hasStop && hasTarget && risk > 0) ? (reward / risk) : null;
      const qty = Number(pos.qty || 0);
      const centerY = Math.max(vp.top + 10, Math.min(vp.top + vp.plotH - 10, (boxTop + boxBot) / 2));

      ctx.font = "11px Segoe UI";
      if (hasStop && yStop !== null) drawPriceTag(ctx, x1 + 6, yStop, `Stop: ${formatPrice(stop, digits)}`, "#d24b5a", "#f2f7ff", vp.top, vp.top + vp.plotH);
      if (hasTarget && yTarget !== null) drawPriceTag(ctx, x1 + 6, yTarget, `Target: ${formatPrice(target, digits)}`, "#0e9b73", "#f2f7ff", vp.top, vp.top + vp.plotH);
      const rrText = rr === null ? "RR -" : `RR ${rr.toFixed(2)}`;
      drawPriceTag(ctx, x1 + 6, centerY, `${side} | ${rrText}${qty > 0 ? ` | Qty ${qty}` : ""}`, "#165f92", "#f2f7ff", vp.top, vp.top + vp.plotH);

      if (includeHandles) {
        ctx.fillStyle = "#f8fdff";
        ctx.strokeStyle = "#4f86ff";
        const hs = [ [x1, yEntry], [x2, yEntry] ];
        if (hasStop && yStop !== null) hs.push([x1, yStop], [x2, yStop]);
        if (hasTarget && yTarget !== null) hs.push([x1, yTarget], [x2, yTarget]);
        hs.forEach(([hx, hy]) => {
          ctx.beginPath();
          ctx.rect(hx - 4, hy - 4, 8, 8);
          ctx.fill();
          ctx.stroke();
        });
      }
    }

    function positionGeometry(pos, vp) {
      if (!pos) return null;
      const entry = Number(pos.entry);
      const stop = Number(pos.stop);
      const target = Number(pos.target);
      if (!Number.isFinite(entry)) return null;
      const i1Raw = Number.isFinite(pos.i1) ? Number(pos.i1) : (vp.endIndex - Math.floor(vp.count * 0.30));
      const i2Raw = Number.isFinite(pos.i2) ? Number(pos.i2) : (vp.endIndex - 2);
      const i1 = Math.min(i1Raw, i2Raw);
      const i2 = Math.max(i1Raw, i2Raw);
      const x1 = clampNumber(xForIndex(i1, vp), vp.left + 2, vp.left + vp.plotW - 2);
      const x2 = clampNumber(xForIndex(i2, vp), vp.left + 2, vp.left + vp.plotW - 2);
      const yEntry = yForPrice(entry, vp);
      const yStop = Number.isFinite(stop) ? yForPrice(stop, vp) : null;
      const yTarget = Number.isFinite(target) ? yForPrice(target, vp) : null;
      const yVals = [yEntry];
      if (yStop !== null) yVals.push(yStop);
      if (yTarget !== null) yVals.push(yTarget);
      return {
        i1,
        i2,
        x1,
        x2,
        midX: (x1 + x2) / 2,
        yEntry,
        yStop,
        yTarget,
        top: Math.min(...yVals),
        bottom: Math.max(...yVals),
      };
    }

    function findPositionHandleAt(x, y, vp) {
      const drawings = drawingsForCurrentChart();
      const maxDist = 10;
      for (let idx = drawings.length - 1; idx >= 0; idx -= 1) {
        const d = drawings[idx];
        if (d.type !== "position") continue;
        const g = positionGeometry(d, vp);
        if (!g) continue;
        const handles = [
          { name: "leftEntry", x: g.x1, y: g.yEntry },
          { name: "rightEntry", x: g.x2, y: g.yEntry },
          ...(g.yStop === null ? [] : [{ name: "leftStop", x: g.x1, y: g.yStop }, { name: "rightStop", x: g.x2, y: g.yStop }]),
          ...(g.yTarget === null ? [] : [{ name: "leftTarget", x: g.x1, y: g.yTarget }, { name: "rightTarget", x: g.x2, y: g.yTarget }]),
        ];
        for (const h of handles) {
          const dx = x - h.x;
          const dy = y - h.y;
          if ((dx * dx + dy * dy) <= (maxDist * maxDist)) {
            return { index: idx, handle: h.name };
          }
        }
      }
      return null;
    }

    function normalizePositionDrawing(d, vp) {
      if (!d) return;
      const total = vp.totalCount || state.chartTotalCount || vp.count || 320;
      d.i1 = clampNumber(Math.round(Number(d.i1 || 0)), 0, Math.max(0, total - 2));
      d.i2 = clampNumber(Math.round(Number(d.i2 || d.i1 + 1)), 1, Math.max(1, total - 1));
      if (d.i2 <= d.i1) d.i2 = Math.min(total - 1, d.i1 + 1);

      d.entry = Number(d.entry);
      const stopNum = Number(d.stop);
      const targetNum = Number(d.target);
      d.stop = Number.isFinite(stopNum) ? stopNum : null;
      d.target = Number.isFinite(targetNum) ? targetNum : null;
      const minGap = Math.max((vp.hi - vp.lo) * 0.001, 0.00001);
      const isShort = String(d.side || "").toUpperCase() === "SHORT";
      if (isShort) {
        if (d.stop !== null && d.stop <= d.entry + minGap) d.stop = d.entry + minGap;
        if (d.target !== null && d.target >= d.entry - minGap) d.target = d.entry - minGap;
      } else {
        if (d.stop !== null && d.stop >= d.entry - minGap) d.stop = d.entry - minGap;
        if (d.target !== null && d.target <= d.entry + minGap) d.target = d.entry + minGap;
      }
    }

    function applyPositionHandleDrag(edit, i, p, vp) {
      const drawings = drawingsForCurrentChart();
      if (!edit || !Number.isFinite(i) || !Number.isFinite(p)) return false;
      const d = drawings[edit.index];
      if (!d || d.type !== "position") return false;

      const h = String(edit.handle || "");
      if (h.startsWith("left")) d.i1 = i;
      if (h.startsWith("right")) d.i2 = i;
      if (h.endsWith("Stop")) d.stop = p;
      if (h.endsWith("Entry")) d.entry = p;
      if (h.endsWith("Target")) d.target = p;
      if (h === "midStop") d.stop = p;
      if (h === "midEntry") d.entry = p;
      if (h === "midTarget") d.target = p;

      normalizePositionDrawing(d, vp);
      return true;
    }

    function distanceToSegment(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      if (dx === 0 && dy === 0) return Math.hypot(px - x1, py - y1);
      const t = clampNumber(((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy), 0, 1);
      const cx = x1 + t * dx;
      const cy = y1 + t * dy;
      return Math.hypot(px - cx, py - cy);
    }

    function findDrawingAt(x, y, vp) {
      const drawings = drawingsForCurrentChart();
      const tol = 8;
      for (let idx = drawings.length - 1; idx >= 0; idx -= 1) {
        const d = drawings[idx];
        if (d.type === "hline") {
          const yy = yForPrice(d.p, vp);
          if (Math.abs(y - yy) <= tol) return idx;
        } else if (d.type === "trend") {
          const x1 = xForIndex(d.i1, vp);
          const y1 = yForPrice(d.p1, vp);
          const x2 = xForIndex(d.i2, vp);
          const y2 = yForPrice(d.p2, vp);
          if (distanceToSegment(x, y, x1, y1, x2, y2) <= tol) return idx;
        } else if (d.type === "rect") {
          const x1 = xForIndex(Math.min(d.i1, d.i2), vp);
          const x2 = xForIndex(Math.max(d.i1, d.i2), vp);
          const y1 = yForPrice(d.p1, vp);
          const y2 = yForPrice(d.p2, vp);
          const left = Math.min(x1, x2), right = Math.max(x1, x2);
          const top = Math.min(y1, y2), bottom = Math.max(y1, y2);
          if (x >= left - tol && x <= right + tol && y >= top - tol && y <= bottom + tol) return idx;
        } else if (d.type === "poly") {
          const pts = Array.isArray(d.points) ? d.points : [];
          for (let i = 1; i < pts.length; i += 1) {
            const x1 = xForIndex(pts[i - 1].i, vp);
            const y1 = yForPrice(pts[i - 1].p, vp);
            const x2 = xForIndex(pts[i].i, vp);
            const y2 = yForPrice(pts[i].p, vp);
            if (distanceToSegment(x, y, x1, y1, x2, y2) <= tol) return idx;
          }
        } else if (d.type === "position") {
          const g = positionGeometry(d, vp);
          if (!g) continue;
          if (x >= Math.min(g.x1, g.x2) - tol && x <= Math.max(g.x1, g.x2) + tol && y >= g.top - tol && y <= g.bottom + tol) {
            return idx;
          }
        }
      }
      return -1;
    }

    function getOpenTradesForSelectedSymbol(maxRows = 6) {
      if (!Array.isArray(state.trades) || !state.selectedSymbol) return [];
      return state.trades
        .filter(t => String(t.symbol || "") === state.selectedSymbol)
        .filter(t => String(t.status || "Open").toLowerCase() === "open")
        .slice(0, Math.max(1, maxRows));
    }

    function drawLiveTradeLevelLine(ctx, vp, price, label, lineColor, tagBg, digits, dashed = false, yOffset = 0, active = false) {
      if (!Number.isFinite(price)) return;
      const yRaw = yForPrice(price, vp);
      const y = yRaw + yOffset;
      ctx.save();
      ctx.lineWidth = active ? 2.1 : 1.35;
      ctx.strokeStyle = lineColor;
      if (dashed) ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(vp.left, y);
      ctx.lineTo(vp.left + vp.plotW, y);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.font = "11px Segoe UI";
      drawPriceTag(
        ctx,
        vp.left + Math.max(8, vp.plotW - 170),
        y,
        `${label}: ${formatPrice(price, digits)}`,
        tagBg,
        "#f2f7ff",
        vp.top,
        vp.top + vp.plotH
      );
      ctx.restore();
    }

    function liveLevelHandleX(vp) {
      return vp.left + vp.plotW - 14;
    }

    function drawLiveLevelHandle(ctx, vp, price, yOffset, color, active = false) {
      if (!Number.isFinite(price)) return;
      const y = yForPrice(price, vp) + Number(yOffset || 0);
      const x = liveLevelHandleX(vp);
      const r = active ? 7 : 5.5;
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = active ? "#eef7ff" : color;
      ctx.strokeStyle = active ? color : "#dce8ff";
      ctx.lineWidth = active ? 2 : 1.3;
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function findLiveTradeLevelAt(x, y, vp, pointerType = "mouse") {
      if (!vp) return null;
      const rows = getOpenTradesForSelectedSymbol(6);
      const isTouchLike = pointerType === "touch" || pointerType === "pen";
      const handleTol = isTouchLike ? 24 : 14;
      const lineTol = isTouchLike ? 14 : 9;
      const hx = liveLevelHandleX(vp);
      let best = null;
      let bestPriority = 999;
      let bestDist = 999999;
      rows.forEach((t, idx) => {
        const yOffset = 0;
        const sl = Number(t.sl);
        const tp = Number(t.tp);
        if (Number.isFinite(sl) && sl > 0) {
          const yy = yForPrice(sl, vp) + yOffset;
          const dHandle = Math.hypot(x - hx, y - yy);
          if (dHandle <= handleTol && (0 < bestPriority || (bestPriority === 0 && dHandle < bestDist))) {
            bestPriority = 0;
            bestDist = dHandle;
            best = { ticket: Number(t.id || 0), level: "sl", y: yy, trade: t, price: sl, yOffset, hitType: "handle" };
          }
          const dist = Math.abs(y - yy);
          if (dist <= lineTol && (1 < bestPriority || (bestPriority === 1 && dist < bestDist))) {
            bestPriority = 1;
            bestDist = dist;
            best = { ticket: Number(t.id || 0), level: "sl", y: yy, trade: t, price: sl, yOffset, hitType: "line" };
          }
        }
        if (Number.isFinite(tp) && tp > 0) {
          const yy = yForPrice(tp, vp) + yOffset;
          const dHandle = Math.hypot(x - hx, y - yy);
          if (dHandle <= handleTol && (0 < bestPriority || (bestPriority === 0 && dHandle < bestDist))) {
            bestPriority = 0;
            bestDist = dHandle;
            best = { ticket: Number(t.id || 0), level: "tp", y: yy, trade: t, price: tp, yOffset, hitType: "handle" };
          }
          const dist = Math.abs(y - yy);
          if (dist <= lineTol && (1 < bestPriority || (bestPriority === 1 && dist < bestDist))) {
            bestPriority = 1;
            bestDist = dist;
            best = { ticket: Number(t.id || 0), level: "tp", y: yy, trade: t, price: tp, yOffset, hitType: "line" };
          }
        }
      });
      return best;
    }

    function drawLiveTradeEditDraft(ctx, vp, digits) {
      const d = state.liveTradeEditDraft;
      if (!d || !Number.isFinite(d.currentPrice)) return;
      const label = d.level === "sl" ? "SL (drag)" : "TP (drag)";
      const color = d.level === "sl" ? "rgba(255,192,192,1)" : "rgba(178,244,206,1)";
      drawLiveTradeLevelLine(ctx, vp, Number(d.currentPrice), label, color, "#6b5a2a", digits, false, Number(d.yOffset || 0), true);
      const entry = Number(d.entry || 0);
      const p = Number(d.currentPrice || 0);
      const delta = Number.isFinite(entry) && entry > 0 ? (p - entry) : 0;
      const side = String(d.level || "").toUpperCase();
      const text = `${side}: ${formatPrice(p, digits)} | d=${delta >= 0 ? "+" : ""}${formatPrice(delta, digits)}`;
      const px = Number.isFinite(state.liveTradeDragX) ? Number(state.liveTradeDragX) : liveLevelHandleX(vp);
      const py = Number.isFinite(state.liveTradeDragY) ? Number(state.liveTradeDragY) : (yForPrice(p, vp) + Number(d.yOffset || 0));
      const tipX = clampNumber(px + 14, vp.left + 6, vp.left + vp.plotW - 220);
      const tipY = clampNumber(py - 18, vp.top + 12, vp.top + vp.plotH - 12);
      ctx.save();
      ctx.font = "11px Segoe UI";
      drawPriceTag(ctx, tipX, tipY, text, "rgba(19,41,70,0.95)", "#ecf4ff", vp.top, vp.top + vp.plotH);
      drawPriceTag(ctx, tipX, tipY + 18, "Release to apply", "rgba(26,58,97,0.9)", "#d8e9ff", vp.top, vp.top + vp.plotH);
      ctx.restore();
    }

    function drawLivePositionOverlays(ctx, vp, digits) {
      const rows = getOpenTradesForSelectedSymbol(6);
      if (!rows.length) return;

      rows.forEach((t, idx) => {
        const entry = Number(t.entry);
        const sl = Number(t.sl);
        const tp = Number(t.tp);
        if (!Number.isFinite(entry)) return;
        const yOffset = 0;
        const draft = state.liveTradeEditDraft;
        const isQuickTarget = Number(state.quickModifyTicket || 0) === Number(t.id || 0);
        const slPx = (draft && Number(draft.ticket) === Number(t.id || 0) && draft.level === "sl" && Number.isFinite(draft.currentPrice))
          ? Number(draft.currentPrice)
          : sl;
        const tpPx = (draft && Number(draft.ticket) === Number(t.id || 0) && draft.level === "tp" && Number.isFinite(draft.currentPrice))
          ? Number(draft.currentPrice)
          : tp;
        drawLiveTradeLevelLine(ctx, vp, entry, "Entry", "rgba(190,198,213,0.96)", "#2a3446", digits, true, yOffset);
        if (Number.isFinite(slPx) && slPx > 0) {
          const active = !!((draft && Number(draft.ticket) === Number(t.id || 0) && draft.level === "sl") || isQuickTarget);
          drawLiveTradeLevelLine(ctx, vp, slPx, "SL", "rgba(255,145,145,0.96)", "#5a2f39", digits, false, yOffset, active);
          drawLiveLevelHandle(ctx, vp, slPx, yOffset, "rgba(255,145,145,0.96)", active);
        }
        if (Number.isFinite(tpPx) && tpPx > 0) {
          const active = !!((draft && Number(draft.ticket) === Number(t.id || 0) && draft.level === "tp") || isQuickTarget);
          drawLiveTradeLevelLine(ctx, vp, tpPx, "TP", "rgba(141,232,182,0.98)", "#21513f", digits, false, yOffset, active);
          drawLiveLevelHandle(ctx, vp, tpPx, yOffset, "rgba(141,232,182,0.98)", active);
        }
      });
      drawLiveTradeEditDraft(ctx, vp, digits);
    }

    function buildPositionDraft(side, points, vp, fallbackPoint = null) {
      if (!points || points.length < 2) return null;
      const p1 = points[0];
      const p2 = points[1];
      const p3 = points[2] || fallbackPoint;
      if (!p1 || !p2 || !p3) return null;
      const entry = Number(p1.p);
      let stop = Number(p2.p);
      let target = Number(p3.p);
      const rng = Math.max((vp.hi - vp.lo) * 0.04, 0.00001);
      if (String(side).toLowerCase() === "short") {
        if (stop <= entry) stop = entry + Math.max(Math.abs(entry - stop), rng);
        if (target >= entry) target = entry - Math.max(Math.abs(target - entry), rng);
      } else {
        if (stop >= entry) stop = entry - Math.max(Math.abs(stop - entry), rng);
        if (target <= entry) target = entry + Math.max(Math.abs(target - entry), rng);
      }
      return { side: String(side).toUpperCase(), entry, stop, target, i1: p1.i, i2: p3.i };
    }

    function drawChartDrawings(ctx, vp) {
      const drawings = drawingsForCurrentChart();
      ctx.save();
      drawings.forEach((d, idx) => {
        const selected = idx === state.selectedDrawingIndex;
        if (d.type === "hline") {
          const y = yForPrice(d.p, vp);
          ctx.strokeStyle = selected ? "#ffd88f" : "#e8c27d";
          ctx.lineWidth = selected ? 1.8 : 1.2;
          ctx.beginPath();
          ctx.moveTo(vp.left, y);
          ctx.lineTo(vp.left + vp.plotW, y);
          ctx.stroke();
        } else if (d.type === "trend") {
          const x1 = xForIndex(d.i1, vp);
          const y1 = yForPrice(d.p1, vp);
          const x2 = xForIndex(d.i2, vp);
          const y2 = yForPrice(d.p2, vp);
          ctx.strokeStyle = selected ? "#9ac8ff" : "#7eb5ff";
          ctx.lineWidth = selected ? 2.0 : 1.5;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        } else if (d.type === "rect") {
          const x1 = xForIndex(Math.min(d.i1, d.i2), vp);
          const x2 = xForIndex(Math.max(d.i1, d.i2), vp);
          const y1 = yForPrice(d.p1, vp);
          const y2 = yForPrice(d.p2, vp);
          const left = Math.min(x1, x2);
          const top = Math.min(y1, y2);
          const w = Math.max(2, Math.abs(x2 - x1));
          const h = Math.max(2, Math.abs(y2 - y1));
          ctx.fillStyle = selected ? "rgba(118,169,255,0.16)" : "rgba(118,169,255,0.10)";
          ctx.strokeStyle = selected ? "rgba(160,205,255,0.95)" : "rgba(118,169,255,0.90)";
          ctx.lineWidth = selected ? 1.8 : 1.2;
          ctx.fillRect(left, top, w, h);
          ctx.strokeRect(left, top, w, h);
        } else if (d.type === "poly") {
          const pts = Array.isArray(d.points) ? d.points : [
            { i: d.i1, p: d.p1 },
            { i: d.i2, p: d.p2 },
            { i: d.i3, p: d.p3 }
          ].filter(p => Number.isFinite(p.i) && Number.isFinite(p.p));
          if (pts.length < 2) return;
          ctx.strokeStyle = selected ? "#afd1ff" : "#90b6ff";
          ctx.lineWidth = selected ? 1.9 : 1.4;
          ctx.beginPath();
          ctx.moveTo(xForIndex(pts[0].i, vp), yForPrice(pts[0].p, vp));
          for (let k = 1; k < pts.length; k += 1) {
            ctx.lineTo(xForIndex(pts[k].i, vp), yForPrice(pts[k].p, vp));
          }
          ctx.stroke();
        } else if (d.type === "position") {
          drawPositionProjection(ctx, vp, d, vp.priceDigits || 5, idx === state.selectedDrawingIndex);
        }
      });

      if (state.chartPointerDown && state.chartDragStart && state.chartDragCurrent) {
        const sx = xForIndex(state.chartDragStart.i, vp);
        const sy = yForPrice(state.chartDragStart.p, vp);
        const ex = xForIndex(state.chartDragCurrent.i, vp);
        const ey = yForPrice(state.chartDragCurrent.p, vp);
        ctx.setLineDash([6, 4]);
        ctx.strokeStyle = "#9ec5ff";
        ctx.fillStyle = "rgba(118,169,255,0.10)";
        if (state.chartTool === "trend") {
          ctx.lineWidth = 1.3;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();
        } else if (state.chartTool === "rect") {
          const left = Math.min(sx, ex);
          const top = Math.min(sy, ey);
          const w = Math.max(2, Math.abs(ex - sx));
          const h = Math.max(2, Math.abs(ey - sy));
          ctx.fillRect(left, top, w, h);
          ctx.strokeRect(left, top, w, h);
        }
        ctx.setLineDash([]);
      }

      if (state.chartTool === "poly" && state.chartPendingPoints.length > 0) {
        ctx.strokeStyle = "#9ec5ff";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(xForIndex(state.chartPendingPoints[0].i, vp), yForPrice(state.chartPendingPoints[0].p, vp));
        for (let k = 1; k < state.chartPendingPoints.length; k += 1) {
          const pp = state.chartPendingPoints[k];
          ctx.lineTo(xForIndex(pp.i, vp), yForPrice(pp.p, vp));
        }
        if (state.chartHover) ctx.lineTo(xForIndex(state.chartHover.i, vp), yForPrice(state.chartHover.p, vp));
        ctx.stroke();
      }

      if ((state.chartTool === "long" || state.chartTool === "short") && state.chartPendingPoints.length >= 1) {
        const side = state.chartTool === "short" ? "SHORT" : "LONG";
        const draft = buildPositionDraft(side, state.chartPendingPoints, vp, state.chartHover);
        if (draft) {
          drawPositionProjection(ctx, vp, {
            ...draft,
            i2: Number.isFinite(draft.i2) ? draft.i2 : (draft.i1 + Math.floor(vp.count * 0.24)),
          }, vp.priceDigits || 5, true);
        }
      }
      ctx.restore();
    }

    function drawMarketChart() {
      const canvas = el.marketChart;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;

      const width = canvas.clientWidth || 760;
      const height = canvas.clientHeight || 320;
      const ratio = window.devicePixelRatio || 1;
      canvas.width = Math.floor(width * ratio);
      canvas.height = Math.floor(height * ratio);
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      ctx.clearRect(0, 0, width, height);

      const symbol = state.selectedSymbol || "";
      if (!symbol) {
        el.chartMeta.textContent = "Waiting for market data...";
        drawEmptyChart(ctx, width, height, "No symbol selected");
        return;
      }

      const key = chartKey(symbol, state.chartTf);
      const fullCandles = (state.marketCandles[key] || []).slice(-MAX_LOCAL_BARS);
      if (fullCandles.length < 2) {
        el.chartMeta.textContent = `${symbol} ${state.chartTf} - waiting for candles`;
        drawEmptyChart(ctx, width, height, "Not enough candle data");
        return;
      }

      state.chartTotalCount = fullCandles.length;
      const visible = clampNumber(
        Math.round(state.chartVisibleCount || Math.min(150, fullCandles.length)),
        40,
        fullCandles.length
      );
      state.chartVisibleCount = visible;
      const maxPan = Math.max(0, fullCandles.length - visible);
      const minPan = state.chartFreeMove ? -Math.max(30, Math.floor(visible * 2.0)) : 0;
      state.chartPanBars = clampNumber(Math.round(state.chartPanBars || 0), minPan, maxPan);
      const rightPadBars = state.chartPanBars < 0 ? Math.abs(state.chartPanBars) : 0;
      const panFromRight = Math.max(0, state.chartPanBars);
      const effectiveVisible = Math.max(20, visible - rightPadBars);
      const endIndex = fullCandles.length - panFromRight;
      const startIndex = Math.max(0, endIndex - effectiveVisible);
      const candles = fullCandles.slice(startIndex, endIndex);

      const digits = inferPriceDigits(candles);
      const highs = candles.map(c => Number(c.high));
      const lows = candles.map(c => Number(c.low));
      const hiRaw = Math.max(...highs);
      const loRaw = Math.min(...lows);
      const midRaw = (hiRaw + loRaw) / 2;
      const spanRaw = Math.max(hiRaw - loRaw, 0.00001);
      const yZoom = clampNumber(Number(state.chartYZoom || 1), 0.5, 6);
      state.chartYZoom = yZoom;
      const yShift = Number(state.chartYShift || 0);
      const mid = midRaw + yShift;
      const half = (spanRaw / 2) / yZoom;
      const pad = Math.max(half * 0.10, spanRaw * 0.02, 0.00001);
      const hi = mid + half + pad;
      const lo = mid - half - pad;

      const left = 14;
      const right = 92;
      const top = 12;
      const bottom = 30;
      const plotW = width - left - right;
      const plotH = height - top - bottom;
      const vp = {
        left, right, top, bottom, plotW, plotH, hi, lo,
        count: candles.length + rightPadBars,
        startIndex,
        endIndex: startIndex + candles.length + rightPadBars,
        candleEndIndex: startIndex + candles.length,
        totalCount: fullCandles.length,
        priceDigits: digits
      };
      state.chartViewport = vp;

      ctx.fillStyle = "#0a1222";
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = "#0b1528";
      ctx.fillRect(left, top, plotW, plotH);

      ctx.strokeStyle = "rgba(130,149,186,0.20)";
      ctx.lineWidth = 1;
      for (let i = 0; i <= 6; i += 1) {
        const y = top + (i / 6) * plotH;
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(left + plotW, y);
        ctx.stroke();
      }
      for (let i = 0; i <= 8; i += 1) {
        const x = left + (i / 8) * plotW;
        ctx.beginPath();
        ctx.moveTo(x, top);
        ctx.lineTo(x, top + plotH);
        ctx.stroke();
      }

      ctx.save();
      ctx.beginPath();
      ctx.rect(left, top, plotW, plotH);
      ctx.clip();

      const bodyW = Math.max(2, Math.floor((plotW / candles.length) * 0.62));
      candles.forEach((c, i) => {
        const absIndex = startIndex + i;
        const open = Number(c.open);
        const high = Number(c.high);
        const low = Number(c.low);
        const close = Number(c.close);
        const x = xForIndex(absIndex, vp);
        const yHigh = yForPrice(high, vp);
        const yLow = yForPrice(low, vp);
        const yOpen = yForPrice(open, vp);
        const yClose = yForPrice(close, vp);
        const bullish = close >= open;
        ctx.strokeStyle = bullish ? "#1cc688" : "#ea5d73";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, yHigh);
        ctx.lineTo(x, yLow);
        ctx.stroke();

        const topBody = Math.min(yOpen, yClose);
        const bodyH = Math.max(1, Math.abs(yClose - yOpen));
        ctx.fillStyle = bullish ? "#23d18b" : "#ff5f6d";
        ctx.fillRect(x - Math.floor(bodyW / 2), topBody, bodyW, bodyH);
      });

      const structure = state.marketStructure[key] || { points: [], fvg: [] };
      drawEAStructureOverlay(ctx, vp, candles, structure);
      drawLivePositionOverlays(ctx, vp, digits);
      drawChartDrawings(ctx, vp);
      ctx.restore();

      const axisX = left + plotW;
      ctx.fillStyle = "#0c162c";
      ctx.fillRect(axisX, top, right, plotH);
      ctx.strokeStyle = "rgba(130,149,186,0.25)";
      ctx.beginPath();
      ctx.moveTo(axisX, top);
      ctx.lineTo(axisX, top + plotH);
      ctx.stroke();

      ctx.fillStyle = "#9db5dd";
      ctx.font = "11px Segoe UI";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      for (let i = 0; i <= 6; i += 1) {
        const y = top + (i / 6) * plotH;
        const price = hi - (i / 6) * (hi - lo);
        ctx.fillText(formatPrice(price, digits), axisX + 8, y);
      }

      const tickStep = Math.max(1, Math.floor(candles.length / 6));
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      for (let i = 0; i < candles.length; i += tickStep) {
        const x = xForIndex(startIndex + i, vp);
        ctx.fillStyle = "#8ea2cc";
        ctx.fillText(formatTimeLabel(candles[i].time), x, top + plotH + 6);
      }

      const last = candles[candles.length - 1];
      const lastP = Number(last.close);
      const lastY = yForPrice(lastP, vp);
      const bullish = Number(last.close) >= Number(last.open);
      ctx.strokeStyle = bullish ? "rgba(35,209,139,0.85)" : "rgba(255,95,109,0.85)";
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(left, lastY);
      ctx.lineTo(left + plotW, lastY);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.font = "11px Segoe UI";
      drawPriceTag(ctx, axisX + 6, lastY, formatPrice(lastP, digits), bullish ? "#23d18b" : "#ff5f6d", "#07111f", top, top + plotH);

      if (state.chartHover && state.chartHover.i >= vp.startIndex && state.chartHover.i < vp.endIndex) {
        const hx = xForIndex(state.chartHover.i, vp);
        const hy = yForPrice(state.chartHover.p, vp);
        ctx.strokeStyle = "rgba(173,197,241,0.48)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(left, hy);
        ctx.lineTo(left + plotW, hy);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(hx, top);
        ctx.lineTo(hx, top + plotH);
        ctx.stroke();

        drawPriceTag(ctx, axisX + 6, hy, formatPrice(state.chartHover.p, digits), "#193258", "#f2f7ff", top, top + plotH);
      }

      const first = candles[0];
      const delta = Number(last.close) - Number(first.open);
      const sign = delta >= 0 ? "+" : "";
      const t0 = formatTimeLabel(candles[0].time);
      const t1 = formatTimeLabel(last.time);
      const structCount = Array.isArray(structure.points) ? structure.points.length : 0;
      const fvgCount = Array.isArray(structure.fvg) ? structure.fvg.length : 0;
      const learn = state.memoryLearning[key] || null;
      const learnSamples = Math.max(0, Number(learn?.samples || 0));
      const learnBias = learnSamples > 0 ? String(learn.bias || "neutral").toUpperCase() : "";
      const memMeta = learnSamples > 0 ? ` | MEM ${learnBias} S:${learnSamples}` : "";
      el.chartMeta.textContent = `${symbol} ${state.chartTf} | O ${formatPrice(last.open, digits)} H ${formatPrice(last.high, digits)} L ${formatPrice(last.low, digits)} C ${formatPrice(last.close, digits)} | ${sign}${formatPrice(delta, digits)} | ${t0} - ${t1} | ${candles.length}/${fullCandles.length} bars | HH/HL/LH/LL: ${structCount} | FVG: ${fvgCount} | Yx${state.chartYZoom.toFixed(2)}${memMeta}`;
      schedulePersistChartMemory();
    }

    function applyChartZoom(direction, anchorX = null) {
      const vp = state.chartViewport;
      if (!vp) return;
      const total = vp.totalCount || state.chartTotalCount || vp.count;
      const curr = state.chartVisibleCount || vp.count;
      const factor = direction > 0 ? 0.88 : 1.12;
      const next = clampNumber(Math.round(curr * factor), 40, total);
      const ratio = anchorX === null ? 1 : clampNumber((anchorX - vp.left) / Math.max(1, vp.plotW), 0, 1);
      const focus = anchorX === null ? (vp.endIndex - 1) : indexFromX(anchorX, vp);
      const nextStart = clampNumber(Math.round(focus - ratio * next), 0, Math.max(0, total - next));
      state.chartVisibleCount = next;
      state.chartPanBars = total - (nextStart + next);
      drawMarketChart();
    }

    function resetChartView() {
      state.chartVisibleCount = Math.min(150, Math.max(60, state.chartTotalCount || 150));
      state.chartPanBars = 0;
      state.chartYZoom = 1;
      state.chartYShift = 0;
      state.chartPanMode = false;
      state.chartScaleMode = false;
      state.chartPinchMode = false;
      state.chartPointerSamples = {};
      drawMarketChart();
    }

    function autoScaleToCurrentPrice() {
      state.chartPanBars = 0;
      state.chartYZoom = 1;
      state.chartYShift = 0;
      state.chartScaleMode = false;
      state.chartPinchMode = false;
      state.chartPointerSamples = {};
      drawMarketChart();
    }

    function setFreeMove(enabled) {
      const wasOn = !!state.chartFreeMove;
      state.chartFreeMove = !!enabled;
      el.freeMoveBtn.textContent = `Free Move: ${state.chartFreeMove ? "On" : "Off"}`;
      el.freeMoveBtn.classList.toggle("active", state.chartFreeMove);
      if (!state.chartFreeMove) {
        state.chartPanMode = false;
        state.chartPinchMode = false;
        state.chartPointerSamples = {};
      }
      schedulePersistChartMemory();
      drawMarketChart();
    }

    function onChartWheel(evt) {
      const vp = state.chartViewport;
      if (!vp) return;
      evt.preventDefault();
      const pt = chartPointFromEvent(evt);
      if (pt && pt.axis) {
        const factor = evt.deltaY < 0 ? 1.08 : 0.92;
        state.chartYZoom = clampNumber(Number(state.chartYZoom || 1) * factor, 0.5, 6);
        drawMarketChart();
        return;
      }
      applyChartZoom(evt.deltaY < 0 ? 1 : -1, pt ? pt.x : null);
    }

    async function commitLiveTradeLevelEdit(draft) {
      if (!draft || !Number.isFinite(Number(draft.ticket)) || !Number.isFinite(Number(draft.currentPrice))) return;
      const ticket = Number(draft.ticket);
      const level = String(draft.level || "").toLowerCase();
      if (level !== "sl" && level !== "tp") return;
      const oldP = Number(draft.originalPrice || 0);
      const newP = Number(draft.currentPrice || 0);
      if (!(newP > 0)) {
        log(`Trade #${ticket} ${level.toUpperCase()} drag ignored: invalid price`);
        return;
      }
      if (Math.abs(newP - oldP) <= 0.0000001) return;
      const body = { ticket };
      body[level] = newP;
      try {
        const res = await api("/api/trades/modify", { method: "POST", body });
        const applied = res?.applied && typeof res.applied === "object" ? res.applied : {};
        const appliedPx = Number(applied[level] || newP);
        const note = Array.isArray(res?.notes) && res.notes.length ? ` (${res.notes.join("; ")})` : "";
        log(`Trade #${ticket} ${level.toUpperCase()} updated to ${appliedPx.toFixed(5)}${note}`);
        await pollBackend();
        await fetchMarketCandles(false);
      } catch (err) {
        log(`Error: ${err.message}`);
      }
    }

    function onChartPointerDown(evt) {
      const pt = chartPointFromEvent(evt);
      if (!pt || !state.selectedSymbol) return;
      state.chartHover = (pt.inside || pt.axis) ? { i: pt.i, p: pt.p } : null;
      trackPointer(evt, pt);

      if (state.chartTool === "none" && pt.inside && pt.vp) {
        const liveHit = findLiveTradeLevelAt(pt.x, pt.y, pt.vp, String(evt.pointerType || "mouse"));
        if (liveHit && Number(liveHit.ticket || 0) > 0) {
          const entryPx = Number((liveHit.trade || {}).entry || 0);
          state.liveTradeEditDraft = {
            ticket: Number(liveHit.ticket),
            level: String(liveHit.level || "").toLowerCase(),
            originalPrice: Number(liveHit.price || 0),
            currentPrice: Number(liveHit.price || 0),
            entry: entryPx,
            yOffset: Number(liveHit.yOffset || 0),
          };
          state.liveTradeDragX = Number(pt.x);
          state.liveTradeDragY = Number(pt.y);
          state.chartPointerId = evt.pointerId ?? null;
          if (evt.pointerId !== undefined && evt.pointerId !== null) {
            try { el.marketChart.setPointerCapture(evt.pointerId); } catch (_) {}
          }
          el.marketChart.style.cursor = "ns-resize";
          drawMarketChart();
          return;
        }
      }

      if (pt.inside && pt.vp) {
        const hit = findPositionHandleAt(pt.x, pt.y, pt.vp);
        if (hit) {
          state.selectedDrawingIndex = hit.index;
          // Free-move priority in normal mode; direct handle editing in Long/Short edit mode.
          if (state.chartTool === "long" || state.chartTool === "short") {
            state.chartPositionDraft = hit;
            state.chartPointerId = evt.pointerId ?? null;
            if (evt.pointerId !== undefined && evt.pointerId !== null) {
              try { el.marketChart.setPointerCapture(evt.pointerId); } catch (_) {}
            }
            drawMarketChart();
            return;
          }
        }
        const drawingHit = findDrawingAt(pt.x, pt.y, pt.vp);
        if (drawingHit >= 0) {
          state.selectedDrawingIndex = drawingHit;
        } else {
          state.selectedDrawingIndex = -1;
        }
      }

      if (state.chartTool === "none") {
        const freeMoveHit = state.chartFreeMove && (pt.inside || pt.axis);
        if (freeMoveHit && pt.vp && pointerSamples().length >= 2) {
          beginPinch(pt.vp);
        } else if (freeMoveHit) {
          state.chartPinchMode = false;
          state.chartScaleMode = false;
          state.chartPanMode = true;
          state.chartPanStartX = clampNumber(pt.x, pt.vp.left, pt.vp.left + pt.vp.plotW);
          state.chartPanStartY = clampNumber(pt.y, pt.vp.top, pt.vp.top + pt.vp.plotH);
          state.chartPanStartBars = Number(state.chartPanBars || 0);
          state.chartPanStartYShift = Number(state.chartYShift || 0);
        } else if (pt.axis) {
          state.chartScaleMode = true;
          state.chartScaleStartY = pt.y;
          state.chartScaleStartZoom = Number(state.chartYZoom || 1);
        }
        state.chartPointerId = evt.pointerId ?? null;
        if (evt.pointerId !== undefined && evt.pointerId !== null) {
          try { el.marketChart.setPointerCapture(evt.pointerId); } catch (_) {}
        }
        drawMarketChart();
        return;
      }

      if (!pt.inside) return;
      const drawings = drawingsForCurrentChart();
      if (state.chartTool === "hline") {
        drawings.push({ type: "hline", p: pt.p });
        state.selectedDrawingIndex = drawings.length - 1;
        drawMarketChart();
        return;
      }
      if (state.chartTool === "poly") {
        state.chartPendingPoints.push({ i: pt.i, p: pt.p });
        if (state.chartPendingPoints.length >= 3 || evt.detail >= 2) {
          drawings.push({ type: "poly", points: state.chartPendingPoints.slice() });
          state.selectedDrawingIndex = drawings.length - 1;
          state.chartPendingPoints = [];
        }
        drawMarketChart();
        return;
      }
      if (state.chartTool === "long" || state.chartTool === "short") {
        state.chartPendingPoints.push({ i: pt.i, p: pt.p });
        if (state.chartPendingPoints.length >= 3) {
          const draft = buildPositionDraft(state.chartTool, state.chartPendingPoints.slice(0, 3), pt.vp, null);
          if (draft) {
            drawings.push({ type: "position", ...draft });
            state.selectedDrawingIndex = drawings.length - 1;
          }
          state.chartPendingPoints = [];
          setChartTool("none");
          return;
        }
        drawMarketChart();
        return;
      }
      if (state.chartTool === "trend" || state.chartTool === "rect") {
        state.chartPointerDown = true;
        state.chartPointerId = evt.pointerId ?? null;
        state.chartDragStart = { i: pt.i, p: pt.p };
        state.chartDragCurrent = { i: pt.i, p: pt.p };
        if (evt.pointerId !== undefined && evt.pointerId !== null) {
          try { el.marketChart.setPointerCapture(evt.pointerId); } catch (_) {}
        }
        drawMarketChart();
      }
    }

    function onChartPointerMove(evt) {
      const pt = chartPointFromEvent(evt);
      if (!pt) return;
      state.chartHover = (pt.inside || pt.axis) ? { i: pt.i, p: pt.p } : null;
      trackPointer(evt, pt);

      if (state.liveTradeEditDraft && state.chartViewport) {
        const vp = state.chartViewport;
        const rect = el.marketChart.getBoundingClientRect();
        const x = evt.clientX - rect.left;
        const y = evt.clientY - rect.top;
        const cy = clampNumber(y, vp.top, vp.top + vp.plotH);
        state.liveTradeEditDraft.currentPrice = Number(priceFromY(cy, vp));
        state.liveTradeDragX = Number(clampNumber(x, vp.left, vp.left + vp.plotW));
        state.liveTradeDragY = Number(cy);
        el.marketChart.style.cursor = "ns-resize";
        drawMarketChart();
        return;
      }

      if (state.chartPositionDraft && state.chartViewport) {
        const rect = el.marketChart.getBoundingClientRect();
        const x = evt.clientX - rect.left;
        const y = evt.clientY - rect.top;
        const vp = state.chartViewport;
        const cx = clampNumber(x, vp.left, vp.left + vp.plotW);
        const cy = clampNumber(y, vp.top, vp.top + vp.plotH);
        const i = indexFromX(cx, vp);
        const p = priceFromY(cy, vp);
        if (applyPositionHandleDrag(state.chartPositionDraft, i, p, vp)) {
          drawMarketChart();
        }
        return;
      }

      if (state.chartPinchMode && state.chartViewport) {
        const vp = state.chartViewport;
        const pts = pointerSamples();
        if (pts.length < 2) {
          state.chartPinchMode = false;
          drawMarketChart();
          return;
        }
        const a = pts[0];
        const b = pts[1];
        const dist = Math.max(8, Math.hypot(a.x - b.x, a.y - b.y));
        const centerX = clampNumber((a.x + b.x) / 2, vp.left, vp.left + vp.plotW);
        const centerY = clampNumber((a.y + b.y) / 2, vp.top, vp.top + vp.plotH);
        const total = vp.totalCount || state.chartTotalCount || vp.count;
        const startVisible = Math.max(40, Number(state.chartPinchStartVisible || vp.count || 150));
        const nextVisible = clampNumber(Math.round(startVisible * (state.chartPinchStartDist / dist)), 40, total);
        state.chartVisibleCount = nextVisible;
        const barsPerPx = vp.count / Math.max(1, vp.plotW);
        const deltaBars = Math.round((centerX - state.chartPinchStartCenterX) * barsPerPx);
        const maxPan = Math.max(0, total - nextVisible);
        const minPan = state.chartFreeMove ? -Math.max(30, Math.floor(nextVisible * 2.0)) : 0;
        state.chartPanBars = clampNumber(state.chartPinchStartPanBars + deltaBars, minPan, maxPan);
        const yFactor = state.chartPinchStartDist / dist;
        state.chartYZoom = clampNumber(state.chartPinchStartYZoom * yFactor, 0.5, 6);
        const pricePerPx = (vp.hi - vp.lo) / Math.max(1, vp.plotH);
        const deltaPrice = (centerY - state.chartPinchStartCenterY) * pricePerPx;
        state.chartYShift = state.chartPinchStartYShift + deltaPrice;
        drawMarketChart();
        return;
      }

      if (state.chartPanMode && state.chartViewport) {
        const vp = state.chartViewport;
        const px = clampNumber(pt.x, vp.left, vp.left + vp.plotW);
        const py = clampNumber(pt.y, vp.top, vp.top + vp.plotH);
        const barsPerPx = vp.count / Math.max(1, vp.plotW);
        const deltaBars = Math.round((px - state.chartPanStartX) * barsPerPx);
        const maxPan = Math.max(0, (vp.totalCount || state.chartTotalCount) - state.chartVisibleCount);
        const minPan = state.chartFreeMove ? -Math.max(30, Math.floor(state.chartVisibleCount * 2.0)) : 0;
        state.chartPanBars = clampNumber(state.chartPanStartBars + deltaBars, minPan, maxPan);
        const pricePerPx = (vp.hi - vp.lo) / Math.max(1, vp.plotH);
        const deltaPrice = (py - state.chartPanStartY) * pricePerPx;
        state.chartYShift = state.chartPanStartYShift + deltaPrice;
        drawMarketChart();
        return;
      }
      if (state.chartScaleMode) {
        const dy = pt.y - state.chartScaleStartY;
        const factor = Math.exp(-dy * 0.01);
        state.chartYZoom = clampNumber(state.chartScaleStartZoom * factor, 0.5, 6);
        drawMarketChart();
        return;
      }
      if (state.chartPointerDown && pt.inside && (state.chartTool === "trend" || state.chartTool === "rect")) {
        state.chartDragCurrent = { i: pt.i, p: pt.p };
      }
      if (state.chartTool === "none" && pt.inside && pt.vp) {
        const h = findLiveTradeLevelAt(pt.x, pt.y, pt.vp, String(evt.pointerType || "mouse"));
        el.marketChart.style.cursor = h ? "ns-resize" : "default";
      } else {
        el.marketChart.style.cursor = "default";
      }
      drawMarketChart();
    }

    function onChartPointerUp(evt) {
      untrackPointer(evt.pointerId);
      if (state.liveTradeEditDraft) {
        const draft = { ...state.liveTradeEditDraft };
        state.liveTradeEditDraft = null;
        state.liveTradeDragX = null;
        state.liveTradeDragY = null;
        if (state.chartPointerId !== null) {
          try { el.marketChart.releasePointerCapture(state.chartPointerId); } catch (_) {}
        }
        state.chartPointerId = null;
        el.marketChart.style.cursor = "default";
        drawMarketChart();
        commitLiveTradeLevelEdit(draft);
        return;
      }
      if (state.chartPositionDraft) {
        state.chartPositionDraft = null;
        if (state.chartPointerId !== null) {
          try { el.marketChart.releasePointerCapture(state.chartPointerId); } catch (_) {}
        }
        state.chartPointerId = null;
        drawMarketChart();
        return;
      }
      if (state.chartPinchMode) {
        const pts = pointerSamples();
        if (pts.length >= 2) {
          drawMarketChart();
          return;
        }
        state.chartPinchMode = false;
        if (state.chartFreeMove && pts.length === 1 && state.chartViewport) {
          const vp = state.chartViewport;
          const rem = pts[0];
          state.chartPanMode = true;
          state.chartPanStartX = clampNumber(rem.x, vp.left, vp.left + vp.plotW);
          state.chartPanStartY = clampNumber(rem.y, vp.top, vp.top + vp.plotH);
          state.chartPanStartBars = Number(state.chartPanBars || 0);
          state.chartPanStartYShift = Number(state.chartYShift || 0);
          drawMarketChart();
          return;
        }
      }
      if (state.chartPanMode || state.chartScaleMode) {
        state.chartPanMode = false;
        state.chartScaleMode = false;
        const pts = pointerSamples();
        if (state.chartFreeMove && pts.length === 1 && state.chartViewport) {
          const vp = state.chartViewport;
          const rem = pts[0];
          state.chartPanMode = true;
          state.chartPanStartX = clampNumber(rem.x, vp.left, vp.left + vp.plotW);
          state.chartPanStartY = clampNumber(rem.y, vp.top, vp.top + vp.plotH);
          state.chartPanStartBars = Number(state.chartPanBars || 0);
          state.chartPanStartYShift = Number(state.chartYShift || 0);
          drawMarketChart();
          return;
        }
        if (state.chartPointerId !== null) {
          try { el.marketChart.releasePointerCapture(state.chartPointerId); } catch (_) {}
        }
        state.chartPointerId = null;
        drawMarketChart();
        return;
      }
      if (!state.chartPointerDown) return;
      const pt = chartPointFromEvent(evt);
      const endPoint = (pt && pt.inside) ? { i: pt.i, p: pt.p } : state.chartDragCurrent;
      const startPoint = state.chartDragStart;
      const drawings = drawingsForCurrentChart();
      if (startPoint && endPoint) {
        if (state.chartTool === "trend") drawings.push({ type: "trend", i1: startPoint.i, p1: startPoint.p, i2: endPoint.i, p2: endPoint.p });
        else if (state.chartTool === "rect") drawings.push({ type: "rect", i1: startPoint.i, p1: startPoint.p, i2: endPoint.i, p2: endPoint.p });
        state.selectedDrawingIndex = drawings.length - 1;
      }
      if (state.chartPointerId !== null) {
        try { el.marketChart.releasePointerCapture(state.chartPointerId); } catch (_) {}
      }
      state.chartPointerDown = false;
      state.chartPointerId = null;
      state.chartDragStart = null;
      state.chartDragCurrent = null;
      drawMarketChart();
    }

    function onChartPointerLeave() {
      state.chartPointerSamples = {};
      state.chartPinchMode = false;
      state.chartHover = null;
      if (!state.liveTradeEditDraft) el.marketChart.style.cursor = "default";
      if (!state.chartPointerDown && !state.chartPanMode && !state.chartScaleMode && !state.chartPinchMode) drawMarketChart();
    }

    async function closeTradeForSelectedSymbol() {
      const symbol = String(state.selectedSymbol || "").trim();
      if (!symbol) {
        log("Error: Select a symbol first");
        return;
      }
      const openBySymbol = (state.trades || []).filter(t =>
        String(t.symbol || "") === symbol && String(t.status || "Open").toLowerCase() === "open"
      );
      try {
        const res = await api("/api/trades/close", { method: "POST", body: { symbol } });
        log(`Closed ${res.closed || 0} trade(s) for ${symbol}`);
        await pollBackend();
        await fetchMarketCandles(true);
      } catch (err) {
        let closed = 0;
        const failed = [];
        for (const t of openBySymbol) {
          try {
            const r = await api("/api/trades/close", { method: "POST", body: { ticket: t.id } });
            closed += Number(r.closed || 0);
          } catch (e2) {
            failed.push(`${t.id}:${e2.message}`);
          }
        }
        if (closed > 0) {
          log(`Closed ${closed} trade(s) for ${symbol}${failed.length ? ` (some failed: ${failed.join(", ")})` : ""}`);
          await pollBackend();
          await fetchMarketCandles(true);
          return;
        }
        log(`Error: ${err.message}`);
      }
    }

    function focusMarketSymbol(symbol, switchPanel = true) {
      const sym = normalizeSymbol(symbol);
      if (!sym) return;
      if (state.allowedSymbols.length && !state.allowedSymbols.includes(sym)) {
        log(`Error: ${sym} is not in allowed markets`);
        return;
      }
      state.selectedSymbol = sym;
      state.chartPanBars = 0;
      state.chartYZoom = 1;
      state.chartYShift = 0;
      state.chartVisibleCount = Math.min(150, Math.max(60, state.chartTotalCount || 150));
      state.selectedDrawingIndex = -1;
      const exists = Array.from(el.chartSymbol.options).some(o => o.value === sym);
      if (!exists) {
        const opt = document.createElement("option");
        opt.value = sym;
        opt.textContent = sym;
        el.chartSymbol.appendChild(opt);
      }
      el.chartSymbol.value = sym;
      if (switchPanel) showPanel("marketPanel");
      syncMarketContext(false).catch(() => {});
      fetchMarketCandles(true).catch(() => {});
    }

    function setEngineState(running) {
      state.eaRunning = !!running;
      el.runStateChip.textContent = `Engine: ${running ? "Running" : "Idle"}`;
      el.runStateChip.style.borderColor = running ? "#1f6f50" : "var(--line)";
    }

    async function startEngine() {
      if (!state.connected) { log("Error: Broker not connected"); return; }
      if (!state.mq5Loaded) { log("Error: Upload EA .ex5 or .mq5 first"); return; }
      if (!applyAllowedSymbols(false)) return;
      const settings = normalizeKutMilzSignalSettings(collectSettings());
      const allowedSymbols = [...state.allowedSymbols];
      const primarySymbol = normalizeSymbol(state.selectedSymbol || allowedSymbols[0] || "");
      try {
        const res = await api("/api/ea/start", {
          method: "POST",
          body: {
            settings,
            allowed_symbols: allowedSymbols,
            primary_symbol: primarySymbol,
            chart_tf: normalizeTf(state.chartTf),
            trigger_flow_mode: state.triggerFlowMode,
            manual_trade_enabled: state.manualTradeEnabled
          }
        });
        if (Array.isArray(res.allowed_symbols) && res.allowed_symbols.length) {
          setAllowedSymbols(res.allowed_symbols, true);
        }
        setManualTradeEnabled(!!res.manual_trade_enabled, "backend");
        setTriggerFlowMode(res.trigger_flow_mode || state.triggerFlowMode, "backend");
        if (!state.selectedSymbol && res.primary_symbol) {
          focusMarketSymbol(res.primary_symbol, false);
        } else if (!state.selectedSymbol && primarySymbol) {
          focusMarketSymbol(primarySymbol, false);
        }
        setEngineState(true);
        await syncMarketContext(false);
        await fetchMarketCandles(true);
        showPanel("marketPanel");
        if (res.automation_command_written === false && res.automation_command_detail) {
          log(`Automation command warning: ${res.automation_command_detail}`);
        }
        log("EA execution started");
      } catch (err) {
        log(`Error: ${err.message}`);
      }
    }

    async function stopEngine() {
      try {
        await api("/api/ea/stop", { method: "POST" });
      } catch (_) {}
      setEngineState(false);
      await fetchMarketCandles(true).catch(() => {});
      log("EA execution stopped");
    }

    async function restartEngine() {
      if (!applyAllowedSymbols(false)) return;
      const settings = normalizeKutMilzSignalSettings(collectSettings());
      const allowedSymbols = [...state.allowedSymbols];
      const primarySymbol = normalizeSymbol(state.selectedSymbol || allowedSymbols[0] || "");
      try {
        const res = await api("/api/ea/restart", {
          method: "POST",
          body: {
            settings,
            allowed_symbols: allowedSymbols,
            primary_symbol: primarySymbol,
            chart_tf: normalizeTf(state.chartTf),
            trigger_flow_mode: state.triggerFlowMode,
            manual_trade_enabled: state.manualTradeEnabled
          }
        });
        if (Array.isArray(res.allowed_symbols) && res.allowed_symbols.length) {
          setAllowedSymbols(res.allowed_symbols, true);
        }
        setManualTradeEnabled(!!res.manual_trade_enabled, "backend");
        setTriggerFlowMode(res.trigger_flow_mode || state.triggerFlowMode, "backend");
        if (!state.selectedSymbol && res.primary_symbol) {
          focusMarketSymbol(res.primary_symbol, false);
        } else if (!state.selectedSymbol && primarySymbol) {
          focusMarketSymbol(primarySymbol, false);
        }
        setEngineState(true);
        await syncMarketContext(false);
        await fetchMarketCandles(true);
        if (res.automation_command_written === false && res.automation_command_detail) {
          log(`Automation command warning: ${res.automation_command_detail}`);
        }
        log("EA restart triggered");
      } catch (err) {
        log(`Error: ${err.message}`);
      }
    }

    async function pollBackend() {
      if (!state.authenticated) return;
      try {
        const nowMs = Date.now();
        const refreshAnalytics = (nowMs - Number(state.analyticsLastFetchMs || 0)) >= 5000;
        const refreshReportData = (nowMs - Number(state.reportLastFetchMs || 0)) >= 7000;
        const analyticsReq = refreshAnalytics
          ? api("/api/analytics/summary?days=7").catch(() => null)
          : Promise.resolve(state.analyticsSummary);
        const watchdogReq = refreshAnalytics
          ? api("/api/watchdog/status").catch(() => null)
          : Promise.resolve(state.watchdogStatus);
        const reportReq = refreshReportData
          ? api(`/api/reports/summary?days=${getReportDays()}`).catch(() => null)
          : Promise.resolve(state.reportSummary);
        const [broker, ea, live, hist, logs, insight, analyticsRes, watchdogRes, reportRes] = await Promise.all([
          api("/api/broker/status"),
          api("/api/ea/status"),
          api("/api/trades/live"),
          api("/api/trades/history"),
          api("/api/logs"),
          api("/api/ea/insight").catch(() => null),
          analyticsReq,
          watchdogReq,
          reportReq
        ]);
        setBackendApiState(true, "Connected");
        setBrokerStatus(broker.connected, broker.connected ? "Connected" : "Disconnected");
        state.connected = !!broker.connected;
        state.accountSnapshot = broker.account || {};
        renderAccount(state.accountSnapshot);
        state.mq5Loaded = !!ea.ea_loaded;
        setManualTradeEnabled(!!ea.manual_trade_enabled, "backend");
        setTriggerFlowMode(ea.trigger_flow_mode || state.triggerFlowMode, "backend");
        state.trades = live.trades || [];
        if (Number(state.quickModifyTicket || 0) > 0) {
          const exists = state.trades.some(t => Number(t.id || 0) === Number(state.quickModifyTicket));
          if (!exists) state.quickModifyTicket = 0;
        }
        state.history = hist.trades || [];
        setEngineState(!!ea.running);
        if (Array.isArray(ea.allowed_symbols) && ea.allowed_symbols.length) {
          setAllowedSymbols(ea.allowed_symbols, true);
        }
        if (!state.selectedSymbol && ea.market_symbol) {
          state.selectedSymbol = normalizeSymbol(ea.market_symbol);
        } else if (!state.selectedSymbol && ea.primary_symbol) {
          state.selectedSymbol = normalizeSymbol(ea.primary_symbol);
        }
        if (!state.chartTf && ea.market_tf) {
          state.chartTf = normalizeTf(ea.market_tf);
          el.chartTf.value = state.chartTf;
        }
        renderLive(state.trades);
        renderHistory(state.history);
        renderInsight(insight);
        if (analyticsRes && typeof analyticsRes === "object" && analyticsRes.ok !== false) {
          state.analyticsSummary = analyticsRes;
          state.analyticsLastFetchMs = nowMs;
        }
        if (watchdogRes && typeof watchdogRes === "object" && watchdogRes.ok !== false) {
          state.watchdogStatus = watchdogRes;
          state.analyticsLastFetchMs = nowMs;
        }
        if (reportRes && typeof reportRes === "object" && reportRes.ok !== false) {
          state.reportSummary = reportRes;
          state.reportLastFetchMs = nowMs;
        }
        renderAnalytics(state.analyticsSummary, state.watchdogStatus);
        renderReport(state.reportSummary);
        syncChartSymbolOptions();
        await fetchMarketCandles(false);
        (logs.logs || []).forEach(item => log(item.msg || "", true));
      } catch (err) {
        setBackendApiState(false, "Disconnected");
        setBrokerStatus(false, "Disconnected");
        renderAccount({});
        setEngineState(false);
        renderInsight(buildFallbackInsight());
        renderAnalytics(state.analyticsSummary || buildFallbackAnalytics(), state.watchdogStatus || buildFallbackWatchdog());
        renderReport(state.reportSummary || buildFallbackReport());
        if (!isFileMode()) log(`Backend poll error: ${err.message}`);
      }
    }

    function startPolling() {
      stopPolling();
      pollBackend();
      state.poller = setInterval(pollBackend, 1000);
    }

    function stopPolling() {
      if (state.poller) clearInterval(state.poller);
      state.poller = null;
    }

    function wire() {
      // Guard against unexpected submits from injected/browser forms.
      document.addEventListener("submit", (evt) => {
        if (evt.target !== el.loginForm) {
          evt.preventDefault();
          evt.stopPropagation();
        }
      }, true);
      el.loginForm.addEventListener("submit", handleLogin);
      el.logoutBtn.addEventListener("click", logout);
      el.backendApiBtn.addEventListener("click", toggleBackendApi);
      el.connectBtn.addEventListener("click", connectBroker);
      el.mq5File.addEventListener("change", handleFileUpload);
      el.setFile.addEventListener("change", handleSetUpload);
      el.startBtn.addEventListener("click", startEngine);
      el.stopBtn.addEventListener("click", stopEngine);
      el.restartBtn.addEventListener("click", restartEngine);
      el.liveBody.addEventListener("click", (evt) => {
        const btn = evt.target.closest(".symbol-jump");
        if (btn) {
          focusMarketSymbol(btn.dataset.symbol || "", true);
          return;
        }
        const rowEl = evt.target.closest("tr[data-live-ticket]");
        if (!rowEl) return;
        const ticket = Number(rowEl.getAttribute("data-live-ticket") || 0);
        if (!(ticket > 0)) return;
        const row = (state.trades || []).find(t => Number(t.id || 0) === ticket);
        if (!row) return;
        openTradeDetailModal(row, "live");
      });
      el.historyBody.addEventListener("click", (evt) => {
        const rowEl = evt.target.closest("tr[data-history-ticket]");
        if (!rowEl) return;
        const ticket = Number(rowEl.getAttribute("data-history-ticket") || 0);
        if (!(ticket > 0)) return;
        const row = (state.history || []).find(t => Number(t.id || 0) === ticket);
        if (!row) return;
        openTradeDetailModal(row, "history");
      });
      if (el.tradeDetailModifyBtn) {
        el.tradeDetailModifyBtn.addEventListener("click", () => {
          modifyTradeFromModal().catch(err => log(`Error: ${err.message}`));
        });
      }
      if (el.tradeDetailSetSlBtn) {
        el.tradeDetailSetSlBtn.addEventListener("click", () => {
          startTradeLevelEditFromModal("sl").catch(err => log(`Error: ${err.message}`));
        });
      }
      if (el.tradeDetailSetTpBtn) {
        el.tradeDetailSetTpBtn.addEventListener("click", () => {
          startTradeLevelEditFromModal("tp").catch(err => log(`Error: ${err.message}`));
        });
      }
      if (el.tradeDetailCloseTradeBtn) {
        el.tradeDetailCloseTradeBtn.addEventListener("click", () => {
          closeTradeFromModal().catch(err => log(`Error: ${err.message}`));
        });
      }
      if (el.tradeDetailCloseBtn) {
        el.tradeDetailCloseBtn.addEventListener("click", closeTradeDetailModal);
      }
      if (el.tradeDetailModal) {
        el.tradeDetailModal.addEventListener("click", (evt) => {
          if (evt.target === el.tradeDetailModal) closeTradeDetailModal();
        });
      }
      document.addEventListener("keydown", (evt) => {
        if (evt.key === "Escape" && state.tradeDetailModalOpen) closeTradeDetailModal();
      });
      el.chartSymbol.addEventListener("change", () => {
        state.selectedSymbol = normalizeSymbol(el.chartSymbol.value);
        state.chartPanBars = 0;
        state.chartYZoom = 1;
        state.chartYShift = 0;
        state.selectedDrawingIndex = -1;
        syncMarketContext(false).catch(() => {});
        fetchMarketCandles(true).catch(() => {});
        schedulePersistChartMemory();
      });
      el.applySymbolsBtn.addEventListener("click", () => {
        if (!applyAllowedSymbols(true)) return;
        if (state.selectedSymbol && !state.allowedSymbols.includes(state.selectedSymbol)) {
          state.selectedSymbol = state.allowedSymbols[0] || "";
        }
        if (state.selectedSymbol) {
          focusMarketSymbol(state.selectedSymbol, false);
        } else if (state.allowedSymbols[0]) {
          focusMarketSymbol(state.allowedSymbols[0], false);
        }
      });
      el.chartTf.addEventListener("change", () => {
        state.chartTf = normalizeTf(el.chartTf.value || "M1");
        state.chartDragStart = null;
        state.chartDragCurrent = null;
        state.chartPendingPoints = [];
        state.chartPositionDraft = null;
        state.selectedDrawingIndex = -1;
        state.chartPanBars = 0;
        state.chartYShift = 0;
        state.chartVisibleCount = Math.min(150, Math.max(60, state.chartTotalCount || 150));
        syncMarketContext(false).catch(() => {});
        fetchMarketCandles(true).catch(() => {});
        schedulePersistChartMemory();
      });
      el.toolTrend.addEventListener("click", () => setChartTool(state.chartTool === "trend" ? "none" : "trend"));
      el.toolPoly.addEventListener("click", () => setChartTool(state.chartTool === "poly" ? "none" : "poly"));
      el.toolHLine.addEventListener("click", () => setChartTool(state.chartTool === "hline" ? "none" : "hline"));
      el.toolRect.addEventListener("click", () => setChartTool(state.chartTool === "rect" ? "none" : "rect"));
      el.toolLong.addEventListener("click", () => setChartTool(state.chartTool === "long" ? "none" : "long"));
      el.toolShort.addEventListener("click", () => setChartTool(state.chartTool === "short" ? "none" : "short"));
      el.toolClear.addEventListener("click", () => {
        const key = drawingKey();
        if (key) {
          const rows = state.chartDrawings[key] || [];
          if (state.selectedDrawingIndex >= 0 && state.selectedDrawingIndex < rows.length) {
            rows.splice(state.selectedDrawingIndex, 1);
            state.chartDrawings[key] = rows;
          } else if (rows.length) {
            log("Select a drawing first, then click Clear Drawings.");
          }
        }
        state.selectedDrawingIndex = -1;
        state.chartPendingPoints = [];
        state.chartDragStart = null;
        state.chartDragCurrent = null;
        state.chartPositionDraft = null;
        state.chartPointerDown = false;
        state.chartPanMode = false;
        state.chartScaleMode = false;
        drawMarketChart();
      });
      el.zoomInBtn.addEventListener("click", () => applyChartZoom(1, null));
      el.zoomOutBtn.addEventListener("click", () => applyChartZoom(-1, null));
      el.resetViewBtn.addEventListener("click", resetChartView);
      el.autoScaleBtn.addEventListener("click", autoScaleToCurrentPrice);
      el.freeMoveBtn.addEventListener("click", () => setFreeMove(!state.chartFreeMove));
      el.closeTradeBtn.addEventListener("click", closeTradeForSelectedSymbol);
      if (el.dispatchAutomationBtn) {
        el.dispatchAutomationBtn.addEventListener("click", () => dispatchMt5AutomationCommand(true));
      }
      if (el.manualOrderType) {
        el.manualOrderType.addEventListener("change", updateManualOrderUi);
      }
      if (el.manualTradeMode) {
        el.manualTradeMode.addEventListener("change", () => {
          setManualTradeEnabled(el.manualTradeMode.value === "on");
          syncManualConfig(true);
        });
      }
      if (el.triggerFlowMode) {
        el.triggerFlowMode.addEventListener("change", () => {
          setTriggerFlowMode(el.triggerFlowMode.value);
          syncManualConfig(true);
        });
      }
      if (el.manualBuyBtn) {
        el.manualBuyBtn.addEventListener("click", () => placeManualOrder("BUY"));
      }
      if (el.manualSellBtn) {
        el.manualSellBtn.addEventListener("click", () => placeManualOrder("SELL"));
      }
      if (el.refreshReportBtn) {
        el.refreshReportBtn.addEventListener("click", () => refreshReport(true));
      }
      if (el.exportReportJsonBtn) {
        el.exportReportJsonBtn.addEventListener("click", exportReportJson);
      }
      if (el.exportReportCsvBtn) {
        el.exportReportCsvBtn.addEventListener("click", exportReportCsv);
      }
      if (el.reportDays) {
        el.reportDays.addEventListener("change", () => {
          const days = getReportDays();
          el.reportDays.value = String(days);
          refreshReport(true);
        });
      }
      if (el.reportTabButtons && el.reportTabButtons.length) {
        el.reportTabButtons.forEach(btn => {
          btn.addEventListener("click", () => {
            setReportTab(btn.dataset.reportTab || "summary", true);
          });
        });
      }
      if (el.clearTriggerFlowBtn) {
        el.clearTriggerFlowBtn.addEventListener("click", () => {
          resetTriggerFlowPanel();
          log("Trigger Flow panel cleared");
        });
      }
      el.marketChart.addEventListener("pointerdown", onChartPointerDown);
      el.marketChart.addEventListener("pointermove", onChartPointerMove);
      el.marketChart.addEventListener("pointerup", onChartPointerUp);
      el.marketChart.addEventListener("pointercancel", onChartPointerUp);
      el.marketChart.addEventListener("pointerleave", onChartPointerLeave);
      el.marketChart.addEventListener("wheel", onChartWheel, { passive: false });
      window.addEventListener("resize", drawMarketChart);
      el.brokerSelect.addEventListener("change", () => {
        const v = el.brokerSelect.value;
        if (v === "Deriv") el.compatibilityLabel.textContent = "Connected via MT5 bridge";
        else if (v === "MetaTrader5") el.compatibilityLabel.textContent = "Direct MT5 Execution Mode";
        else el.compatibilityLabel.textContent = "Broker accepted by MetaTrader5";
      });
      // Stop Enter in broker/API inputs from causing page submit/reload behavior.
      [el.apiBase, el.brokerLogin, el.brokerPassword, el.brokerServer, el.brokerTerminalPath].forEach(ctrl => {
        if (!ctrl) return;
        ctrl.addEventListener("keydown", (evt) => {
          if (evt.key === "Enter") {
            evt.preventDefault();
            evt.stopPropagation();
          }
        });
      });
      el.apiBase.addEventListener("change", () => {
        state.apiSessionToken = "";
        setBackendApiState(false, "Disconnected");
        setEngineState(false);
        setManualTradeEnabled(false, "backend");
        setTriggerFlowMode("BOTH", "backend");
        stopPolling();
        state.marketCandles = {};
        state.marketStructure = {};
        state.accountSnapshot = {};
        state.supervisorStatus = null;
        state.lastSupervisorSignature = "";
        state.analyticsSummary = null;
        state.watchdogStatus = null;
        state.analyticsLastFetchMs = 0;
        state.reportSummary = null;
        state.reportLastFetchMs = 0;
        resetTriggerFlowPanel();
        restoreCachedCandlesFor(state.selectedSymbol, state.chartTf);
        renderAccount({});
        renderInsight(buildFallbackInsight());
        renderAnalytics(buildFallbackAnalytics(), buildFallbackWatchdog());
        renderReport(buildFallbackReport());
        drawMarketChart();
        if (state.authenticated) log("Backend API URL changed. Click Connect Backend to retry.");
      });
      initPanels();
      if (isFileMode()) {
        log("Tip: open this page via local server and run backend on http://127.0.0.1:8787");
      }
    }

    wire();
    setBackendApiState(false, "Disconnected");
    setBrokerStatus(false, "Disconnected");
    restoreChartMemoryBootstrap();
    state.chartTf = normalizeTf(el.chartTf.value || state.chartTf || "M1");
    el.chartTf.value = state.chartTf;
    applyAllowedSymbols(false);
    if (state.preferredSymbol && state.allowedSymbols.includes(state.preferredSymbol)) {
      state.selectedSymbol = state.preferredSymbol;
    }
    setChartTool("none");
    setFreeMove(state.chartFreeMove);
    setReportTab(state.reportTab || "summary", false);
    setTriggerFlowMode(state.triggerFlowMode || "BOTH", "backend");
    setManualTradeEnabled(!!state.manualTradeEnabled, "backend");
    updateManualOrderUi();
    el.setFile.disabled = true;
    el.setFileName.textContent = "No .set loaded";
    loadSession();
    renderLive([]);
    renderHistory([]);
    renderAccount({});
    renderInsight(buildFallbackInsight());
    renderAnalytics(buildFallbackAnalytics(), buildFallbackWatchdog());
    renderReport(buildFallbackReport());
    updateTriggerFlowCount();
    if (state.selectedSymbol) restoreCachedCandlesFor(state.selectedSymbol, state.chartTf);
    drawMarketChart();
    if (memory) log(`Local memory active (${MAX_LOCAL_BARS} bars max per symbol/TF).`);
    log("Dashboard initialized");
  </script>
</body>
</html>
