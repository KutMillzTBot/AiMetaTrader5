<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>KutEA26 - EA Control Dashboard</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #111a2d;
      --panel-2: #16213a;
      --line: #27324b;
      --text: #dbe6ff;
      --muted: #8ea2cc;
      --brand: #35c6ff;
      --ok: #23d18b;
      --bad: #ff5f6d;
      --warn: #ffb454;
      --accent: #5aa8ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: radial-gradient(1200px 700px at 10% -10%, #132340 0%, var(--bg) 45%);
      color: var(--text);
    }
    .hidden { display: none !important; }
    .lock-screen {
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 24px;
      background:
        radial-gradient(860px 460px at 8% 10%, rgba(39, 127, 255, 0.14), transparent 62%),
        radial-gradient(880px 420px at 96% 88%, rgba(44, 192, 151, 0.12), transparent 66%),
        #070f1d;
    }
    .lock-shell {
      width: min(980px, 100%);
      display: grid;
      grid-template-columns: 1.05fr minmax(360px, 420px);
      gap: 18px;
      align-items: stretch;
    }
    .lock-brand {
      border: 1px solid #2b3958;
      border-radius: 18px;
      background: linear-gradient(165deg, rgba(18, 35, 66, 0.92) 0%, rgba(11, 23, 44, 0.92) 100%);
      box-shadow: inset 0 1px 0 rgba(170, 206, 255, 0.06);
      padding: 26px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 12px;
    }
    .lock-kicker {
      margin: 0;
      font-size: 0.75rem;
      letter-spacing: 0.15em;
      color: #7ca2db;
    }
    .lock-brand h2 {
      margin: 0;
      font-size: clamp(1.35rem, 2.2vw, 2rem);
      color: #e3eeff;
      line-height: 1.2;
    }
    .lock-brand p {
      margin: 0;
      color: #9eb5dc;
      line-height: 1.55;
      font-size: 0.95rem;
      max-width: 52ch;
    }
    .lock-pills {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }
    .lock-pills span {
      border: 1px solid #2b4169;
      background: #12233f;
      color: #b8d4ff;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.78rem;
    }
    .auth-card {
      width: 100%;
      background: linear-gradient(180deg, #13213b 0%, #0f192e 100%);
      border: 1px solid #2d3d5d;
      border-radius: 18px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.42);
      padding: 24px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .auth-mark {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #6bd3ff, #1f5cbf 65%);
      border: 1px solid #6caef7;
      box-shadow: 0 0 0 5px rgba(52, 135, 231, 0.16);
      margin-bottom: 12px;
    }
    .auth-title { margin: 0 0 8px; font-size: 1.55rem; color: #e5efff; }
    .auth-sub { margin: 0 0 18px; color: var(--muted); font-size: 0.95rem; line-height: 1.45; }
    .auth-note {
      margin-top: 10px;
      color: #83a4d6;
      font-size: 0.78rem;
      line-height: 1.35;
    }
    .field { margin-bottom: 14px; }
    .field label { display: block; margin-bottom: 6px; color: var(--muted); font-size: 0.86rem; }
    input, select, button {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: #0c1528;
      color: var(--text);
      padding: 10px 12px;
      outline: none;
    }
    input:focus, select:focus { border-color: var(--brand); box-shadow: 0 0 0 2px rgba(53, 198, 255, 0.16); }
    button { cursor: pointer; font-weight: 600; transition: 0.2s ease; }
    .btn-primary { background: linear-gradient(180deg, #4ec5ff, #1e99ff); color: #041022; border: none; }
    .btn-primary:hover { transform: translateY(-1px); }
    .error { color: var(--bad); min-height: 20px; font-size: 0.9rem; margin-top: 8px; }
    .app { display: grid; grid-template-columns: 240px 1fr; min-height: 100vh; }
    .sidebar {
      background: #0c1526;
      border-right: 1px solid var(--line);
      padding: 18px;
      position: sticky;
      top: 0;
      height: 100vh;
    }
    .brand { font-size: 1.1rem; font-weight: 700; margin-bottom: 18px; color: #b7d2ff; }
    .nav-link {
      display: block;
      color: var(--muted);
      text-decoration: none;
      padding: 10px 12px;
      border-radius: 8px;
      margin-bottom: 6px;
    }
    .nav-link:hover { background: #14213a; color: var(--text); }
    .nav-link.active {
      background: linear-gradient(180deg, #1a2f54, #152746);
      color: #dce9ff;
      border: 1px solid #27406a;
    }
    .contact-btn {
      margin-top: 10px;
      display: block;
      width: 100%;
      text-align: center;
      text-decoration: none;
      border-radius: 10px;
      border: 1px solid #2d5e4d;
      background: linear-gradient(180deg, #2c8f6c, #216b50);
      color: #eafff6;
      padding: 10px 12px;
      font-weight: 600;
    }
    .contact-btn:hover { filter: brightness(1.06); }
    .logout-btn { margin-top: 16px; background: #1a243b; color: #f0f5ff; }
    .content { padding: 20px; display: grid; gap: 14px; }
    .topbar { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; }
    .chip {
      border: 1px solid var(--line);
      padding: 6px 10px;
      border-radius: 999px;
      color: var(--muted);
      font-size: 0.85rem;
      background: #0f1a2f;
    }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 14px; }
    .card {
      grid-column: span 12;
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
    }
    .card h3 { margin: 0 0 10px; font-size: 1rem; }
    .section-panel {
      display: none;
      animation: panelFade 0.2s ease;
    }
    .section-panel.active { display: block; }
    .row { display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px; }
    .col-4 { grid-column: span 4; }
    .col-6 { grid-column: span 6; }
    .col-12 { grid-column: span 12; }
    .status {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: #0f1a2d;
      min-height: 42px;
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--bad);
      box-shadow: 0 0 10px rgba(255, 95, 109, 0.7);
    }
    .dot.ok { background: var(--ok); box-shadow: 0 0 10px rgba(35, 209, 139, 0.8); }
    .hint { color: var(--muted); font-size: 0.85rem; }
    .btn-row { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .btn-start { background: #0f8f60; border-color: #0f8f60; }
    .btn-stop { background: #a33a45; border-color: #a33a45; }
    .btn-restart { background: #2853b3; border-color: #2853b3; }
    .btn-disconnect { background: linear-gradient(180deg, #ba5061, #8b3343); border-color: #8b3343; color: #fff2f4; }
    .btn-backend-connect { background: #1c6bb7; border-color: #1c6bb7; margin-top: 8px; }
    .btn-backend-disconnect { background: #8a2f3f; border-color: #8a2f3f; margin-top: 8px; }
    .backend-state { margin-top: 8px; }
    table {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid var(--line);
      border-radius: 10px;
      overflow: hidden;
      font-size: 0.9rem;
    }
    th, td {
      border-bottom: 1px solid var(--line);
      padding: 10px;
      text-align: left;
      white-space: nowrap;
    }
    thead { background: #0f1a2f; }
    .pnl-pos { color: var(--ok); }
    .pnl-neg { color: var(--bad); }
    .log-box {
      background: #0a1324;
      border: 1px solid var(--line);
      border-radius: 10px;
      height: 220px;
      overflow: auto;
      padding: 10px;
      font-family: Consolas, monospace;
      font-size: 0.85rem;
    }
    .log-line { margin: 0 0 6px; color: #aecdff; }
    .log-line .t { color: #7aa8ff; }
    .chart-controls {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 10px;
      margin-bottom: 12px;
    }
    .market-allow-row {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 10px;
      margin-bottom: 12px;
    }
    .btn-apply-markets {
      background: #1c6bb7;
      border-color: #1c6bb7;
    }
    .chart-tool-row {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid #d7deec;
      background: linear-gradient(180deg, #f8faff, #edf2fb);
      margin-bottom: 10px;
    }
    .tool-btn {
      width: 34px;
      min-width: 34px;
      height: 30px;
      padding: 0;
      border-radius: 7px;
      border: 1px solid transparent;
      background: #ffffff;
      color: #2f3a4d;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .tool-btn:hover {
      border-color: #b7c6e2;
      background: #f7faff;
    }
    .tool-btn svg {
      width: 18px;
      height: 18px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.8;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    .tool-btn.active {
      border-color: #87a5db;
      background: #dfeafc;
      color: #20355f;
    }
    .tool-btn-clear {
      width: auto;
      min-width: 0;
      height: auto;
      padding: 7px 10px;
      margin-left: 10px;
      border: 1px solid #2f4b77;
      background: #142744;
      color: #cde2ff;
      font-size: 0.82rem;
      border-radius: 8px;
      vertical-align: top;
    }
    .view-btn-row {
      display: inline-flex;
      gap: 8px;
      margin-left: 8px;
      vertical-align: top;
    }
    .view-btn {
      width: auto;
      min-width: 36px;
      padding: 7px 10px;
      border-radius: 8px;
      border: 1px solid #2f4b77;
      background: #132341;
      color: #d2e7ff;
      font-size: 0.82rem;
    }
    .view-btn.active {
      border-color: #4b8bff;
      background: #1d3760;
      color: #f2f7ff;
    }
    .chart-wrap {
      border: 1px solid var(--line);
      background: #0a1324;
      border-radius: 10px;
      padding: 10px;
    }
    #marketChart {
      width: 100%;
      height: 300px;
      display: block;
      touch-action: none;
      cursor: crosshair;
      border-radius: 8px;
    }
    #chartMeta {
      margin-top: 8px;
      color: var(--muted);
      font-size: 0.88rem;
    }
    .chart-actions {
      margin-top: 12px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .insight-grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 10px;
      margin-top: 12px;
    }
    .insight-card {
      grid-column: span 6;
      border: 1px solid #2b3e60;
      border-radius: 10px;
      padding: 10px;
      background: #0e1a31;
    }
    .insight-title {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .insight-value {
      font-size: 1.2rem;
      font-weight: 700;
      line-height: 1.2;
      margin-bottom: 4px;
    }
    .insight-pos { color: var(--ok); }
    .insight-neg { color: var(--bad); }
    .insight-meta {
      font-size: 0.82rem;
      color: #b8cbef;
      line-height: 1.4;
      white-space: pre-line;
    }
    .btn-close-trade {
      width: auto;
      padding: 10px 14px;
      border: 1px solid #7f3240;
      background: linear-gradient(180deg, #b14656, #8b3343);
      color: #ffeef1;
      border-radius: 10px;
    }
    .symbol-jump {
      width: auto;
      padding: 2px 6px;
      border: 1px solid #2f4f83;
      background: #132341;
      color: #a9d4ff;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.84rem;
    }
    .symbol-jump:hover {
      background: #173159;
      color: #dcefff;
    }
    @keyframes panelFade {
      from { opacity: 0; transform: translateY(3px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @media (max-width: 980px) {
      .app { grid-template-columns: 1fr; }
      .sidebar { position: static; height: auto; }
      .col-4, .col-6 { grid-column: span 12; }
      .btn-row { grid-template-columns: 1fr; }
      .insight-card { grid-column: span 12; }
      .lock-shell { grid-template-columns: 1fr; max-width: 520px; }
      .lock-brand { order: 2; }
      .auth-card { order: 1; }
    }
  </style>
</head>
<body>
  <section id="lockScreen" class="lock-screen">
    <div class="lock-shell">
      <div class="lock-brand">
        <p class="lock-kicker">EA CONTROL TERMINAL</p>
        <h2>ForceX + KutEA26 Dashboard</h2>
        <p>Secure access for broker operations, live execution telemetry, market-structure overlays, and trade control from one panel.</p>
        <div class="lock-pills">
          <span>Live MT5 Bridge</span>
          <span>Session P/L Tracking</span>
          <span>Structure + FVG Feed</span>
        </div>
      </div>
      <div class="auth-card">
        <div class="auth-mark"></div>
        <h1 class="auth-title">KutEA26 Access</h1>
        <p class="auth-sub">Authenticate to open your EA control dashboard.</p>
        <form id="loginForm" autocomplete="off">
          <div class="field">
            <label for="username">Username</label>
            <input id="username" type="text" required />
          </div>
          <div class="field">
            <label for="password">Password</label>
            <input id="password" type="password" required />
          </div>
          <button class="btn-primary" type="submit">Login</button>
        </form>
        <div id="authError" class="error"></div>
        <div class="auth-note">Session stays local to your browser and expires automatically.</div>
      </div>
    </div>
  </section>

  <main id="app" class="app hidden">
    <aside class="sidebar">
      <div class="brand">KutEA26 Dashboard</div>
      <a class="nav-link" href="#brokerPanel" data-target="brokerPanel">Broker Connection</a>
      <a class="nav-link" href="#uploadPanel" data-target="uploadPanel">Upload & Settings</a>
      <a class="nav-link" href="#controlPanel" data-target="controlPanel">EA Control</a>
      <a class="nav-link" href="#marketPanel" data-target="marketPanel">Market Chart</a>
      <a class="nav-link" href="#livePanel" data-target="livePanel">Live Transactions</a>
      <a class="nav-link" href="#historyPanel" data-target="historyPanel">History</a>
      <a class="nav-link" href="#logPanel" data-target="logPanel">System Log</a>
      <a id="contactAdminBtn" class="contact-btn" href="https://t.me/KutMilz876" target="_blank" rel="noopener noreferrer">Contact Admin</a>
      <button id="logoutBtn" class="logout-btn">Logout</button>
    </aside>

    <section class="content">
      <div class="topbar">
        <div class="chip">EA: KutEA26</div>
        <div class="chip" id="sessionPnlChip">Session P/L: 0.00</div>
        <div class="chip" id="botModeChip">Bot: IDLE</div>
        <div class="chip" id="runStateChip">Engine: Idle</div>
      </div>

      <div class="grid">
        <article id="brokerPanel" class="card section-panel">
          <h3>Broker Connection Panel</h3>
          <div class="row">
            <div class="col-4">
              <label class="hint">Backend API URL</label>
              <input id="apiBase" type="text" value="http://127.0.0.1:8787" />
              <button id="backendApiBtn" class="btn-backend-connect" type="button">Connect Backend</button>
              <div id="backendApiStatus" class="hint backend-state">Backend: Disconnected</div>
            </div>
            <div class="col-4">
              <label class="hint">Select Broker</label>
              <select id="brokerSelect">
                <option value="">-- Select --</option>
                <option value="Deriv">Deriv</option>
                <option value="MetaTrader5">MetaTrader5</option>
              </select>
            </div>
            <div class="col-4">
              <label class="hint">Compatibility</label>
              <div id="compatibilityLabel" class="status">Broker accepted by MetaTrader5</div>
            </div>
            <div class="col-4">
              <label class="hint">Broker Account Login</label>
              <input id="brokerLogin" type="text" placeholder="e.g. 12345678" />
            </div>
            <div class="col-4">
              <label class="hint">Broker Password</label>
              <input id="brokerPassword" type="password" placeholder="Broker password" />
            </div>
            <div class="col-4">
              <label class="hint">Broker Server</label>
              <input id="brokerServer" type="text" placeholder="e.g. Deriv-Server" />
            </div>
            <div class="col-6">
              <label class="hint">MT5 Terminal Path (Optional)</label>
              <input id="brokerTerminalPath" type="text" placeholder="C:\\Program Files\\MetaTrader 5\\terminal64.exe" />
            </div>
            <div class="col-4">
              <label class="hint">Status</label>
              <div class="status"><span id="brokerDot" class="dot"></span><span id="brokerStatus">Disconnected</span></div>
            </div>
            <div class="col-4">
              <button id="connectBtn" class="btn-primary" type="button">Connect Broker</button>
            </div>
          </div>
        </article>

        <article id="uploadPanel" class="card section-panel">
          <h3>Upload EA (.mq5) + Dynamic Settings</h3>
          <div class="row">
            <div class="col-6">
              <label class="hint">Upload File</label>
              <input id="mq5File" type="file" accept=".mq5" />
            </div>
            <div class="col-6">
              <label class="hint">Loaded File</label>
              <div id="fileName" class="status">No file loaded</div>
            </div>
            <div class="col-6">
              <label class="hint">Upload .set (after .mq5)</label>
              <input id="setFile" type="file" accept=".set" disabled />
            </div>
            <div class="col-6">
              <label class="hint">Loaded .set</label>
              <div id="setFileName" class="status">No .set loaded</div>
            </div>
            <div class="col-12 hint">Only <code>.mq5</code> files are accepted. Inputs are parsed and rendered below.</div>
          </div>
          <hr style="border-color: var(--line); opacity: .5"/>
          <div id="settingsPanel" class="row"></div>
        </article>

        <article id="controlPanel" class="card section-panel">
          <h3>EA Control Panel</h3>
          <div class="btn-row">
            <button id="startBtn" class="btn-start" type="button">Start EA</button>
            <button id="stopBtn" class="btn-stop" type="button">Stop EA</button>
            <button id="restartBtn" class="btn-restart" type="button">Restart EA</button>
          </div>
          <div class="insight-grid">
            <div class="insight-card">
              <div class="insight-title">Session P/L</div>
              <div id="sessionPnlValue" class="insight-value">0.00</div>
              <div id="sessionPnlMeta" class="insight-meta">Realized: 0.00 | Floating: 0.00 | Trades: 0</div>
            </div>
            <div class="insight-card">
              <div class="insight-title">Bot Activity</div>
              <div id="botThinkingValue" class="insight-value">Idle</div>
              <div id="botActivityMeta" class="insight-meta">Active: None
Waiting: Connect broker and start EA
Mode: IDLE</div>
            </div>
          </div>
        </article>

        <article id="marketPanel" class="card section-panel">
          <h3>Market Chart</h3>
          <div class="chart-controls">
            <div class="col-6">
              <label class="hint">Selected Market Symbol</label>
              <select id="chartSymbol">
                <option value="">No symbols yet</option>
              </select>
            </div>
            <div class="col-3">
              <label class="hint">Timeframe</label>
              <select id="chartTf">
                <option value="M1">M1</option>
                <option value="M5">M5</option>
                <option value="M15">M15</option>
                <option value="M30">M30</option>
                <option value="H1">H1</option>
              </select>
            </div>
            <div class="col-3">
              <label class="hint">Data Source</label>
              <div class="status">MT5 candles since EA start</div>
            </div>
          </div>
          <div class="market-allow-row">
            <div class="col-4">
              <label class="hint">Allowed Market 1</label>
              <input id="allowedSymbol1" type="text" value="Volatility 75 Index" placeholder="e.g. Volatility 75 Index" />
            </div>
            <div class="col-4">
              <label class="hint">Allowed Market 2</label>
              <input id="allowedSymbol2" type="text" value="Volatility 75 (1s) Index" placeholder="e.g. Volatility 75 (1s) Index" />
            </div>
            <div class="col-4">
              <label class="hint">Apply Allowed Markets</label>
              <button id="applySymbolsBtn" class="btn-apply-markets" type="button">Apply Markets</button>
            </div>
          </div>
          <div class="chart-tool-row">
            <button id="toolRect" class="tool-btn" type="button" title="Rectangle">
              <svg viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16"/><circle cx="4" cy="4" r="1.5"/><circle cx="20" cy="4" r="1.5"/><circle cx="4" cy="20" r="1.5"/><circle cx="20" cy="20" r="1.5"/></svg>
            </button>
            <button id="toolTrend" class="tool-btn" type="button" title="Trend Line">
              <svg viewBox="0 0 24 24"><circle cx="5" cy="19" r="1.5"/><circle cx="19" cy="5" r="1.5"/><path d="M6.5 17.5L17.5 6.5"/></svg>
            </button>
            <button id="toolPoly" class="tool-btn" type="button" title="Polyline">
              <svg viewBox="0 0 24 24"><circle cx="4" cy="16" r="1.5"/><circle cx="11" cy="8" r="1.5"/><circle cx="20" cy="14" r="1.5"/><path d="M5.5 14.8L9.8 9.4L18.5 12.8"/></svg>
            </button>
            <button id="toolHLine" class="tool-btn" type="button" title="Horizontal Line">
              <svg viewBox="0 0 24 24"><path d="M4 12H20"/><circle cx="4" cy="12" r="1.5"/><circle cx="20" cy="12" r="1.5"/></svg>
            </button>
            <button id="toolLong" class="tool-btn" type="button" title="Long Position">
              <svg viewBox="0 0 24 24"><path d="M4 17H20M4 11H20M4 5H20"/><path d="M18 9l2 2-2 2"/><path d="M6 7l-2-2 2-2"/></svg>
            </button>
            <button id="toolShort" class="tool-btn" type="button" title="Short Position">
              <svg viewBox="0 0 24 24"><path d="M4 17H20M4 11H20M4 5H20"/><path d="M6 13l-2-2 2-2"/><path d="M18 15l2 2-2 2"/></svg>
            </button>
          </div>
          <button id="toolClear" class="tool-btn tool-btn-clear" type="button" title="Clear Drawings">Clear Drawings</button>
          <div class="view-btn-row">
            <button id="zoomInBtn" class="view-btn" type="button" title="Zoom In">+</button>
            <button id="zoomOutBtn" class="view-btn" type="button" title="Zoom Out">-</button>
            <button id="resetViewBtn" class="view-btn" type="button" title="Reset View">Reset</button>
            <button id="autoScaleBtn" class="view-btn" type="button" title="Auto-Scale to Current Price">Auto-Scale</button>
            <button id="freeMoveBtn" class="view-btn" type="button" title="Toggle Free Chart Movement">Free Move: Off</button>
          </div>
          <div class="chart-wrap">
            <canvas id="marketChart"></canvas>
            <div id="chartMeta">Waiting for market data...</div>
          </div>
          <div class="chart-actions">
            <button id="closeTradeBtn" class="btn-close-trade" type="button">Close Trade (Selected Symbol)</button>
          </div>
        </article>

        <article id="livePanel" class="card section-panel">
          <h3>Live Transactions</h3>
          <div style="overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th>Trade ID</th>
                  <th>Symbol</th>
                  <th>Lot Size</th>
                  <th>Entry Price</th>
                  <th>Current Price</th>
                  <th>Profit/Loss</th>
                  <th>Status</th>
                </tr>
              </thead>
              <tbody id="liveBody"></tbody>
            </table>
          </div>
        </article>

        <article id="historyPanel" class="card section-panel">
          <h3>Transaction History Log</h3>
          <div style="overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th>Trade ID</th>
                  <th>Symbol</th>
                  <th>Entry</th>
                  <th>Exit</th>
                  <th>Profit/Loss</th>
                  <th>Close Time</th>
                </tr>
              </thead>
              <tbody id="historyBody"></tbody>
            </table>
          </div>
        </article>

        <article id="logPanel" class="card section-panel">
          <h3>System Log Panel</h3>
          <div id="systemLog" class="log-box"></div>
        </article>
      </div>
    </section>
  </main>

  <script>
    // Real-mode dashboard with backend bridge.
    const bus = new EventTarget();
    const state = {
      authenticated: false,
      connected: false,
      mq5Loaded: false,
      eaRunning: false,
      backendApiOnline: false,
      apiSessionToken: "",
      settings: {},
      parameters: [],
      trades: [],
      history: [],
      marketCandles: {},
      marketStructure: {},
      chartTf: "M1",
      chartTool: "none",
      chartPendingPoint: null,
      chartPendingPoints: [],
      chartDrawings: {},
      chartViewport: null,
      chartDragStart: null,
      chartDragCurrent: null,
      chartHover: null,
      chartPointerDown: false,
      chartPointerId: null,
      chartVisibleCount: 150,
      chartPanBars: 0,
      chartYZoom: 1,
      chartYShift: 0,
      chartTotalCount: 0,
      chartPanMode: false,
      chartPanStartX: 0,
      chartPanStartY: 0,
      chartPanStartBars: 0,
      chartPanStartYShift: 0,
      chartScaleMode: false,
      chartScaleStartY: 0,
      chartScaleStartZoom: 1,
      chartPointerSamples: {},
      chartPinchMode: false,
      chartPinchStartDist: 0,
      chartPinchStartCenterX: 0,
      chartPinchStartCenterY: 0,
      chartPinchStartVisible: 150,
      chartPinchStartYZoom: 1,
      chartPinchStartPanBars: 0,
      chartPinchStartYShift: 0,
      chartPositionDraft: null,
      selectedDrawingIndex: -1,
      chartFreeMove: false,
      sessionInsight: {
        session: { realized: 0, floating: 0, total: 0, trades: 0, wins: 0, losses: 0 },
        bot_state: { mode: "IDLE", thinking: "Idle", waiting_for: "Connect broker and start EA", active: "None" },
      },
      selectedSymbol: "",
      allowedSymbols: [],
      activePanel: "brokerPanel",
      seenLogs: new Set(),
      poller: null
    };

    // Login logic.
    const USERNAME = "KutEA26";
    const PASS_HASH = "68a242c130a1c9254dbd2bb44ab18d787c40dc13eae775b103e086ccf17ce3a3"; // "$money"

    const el = {
      lockScreen: document.getElementById("lockScreen"),
      app: document.getElementById("app"),
      loginForm: document.getElementById("loginForm"),
      username: document.getElementById("username"),
      password: document.getElementById("password"),
      authError: document.getElementById("authError"),
      apiBase: document.getElementById("apiBase"),
      backendApiBtn: document.getElementById("backendApiBtn"),
      backendApiStatus: document.getElementById("backendApiStatus"),
      brokerSelect: document.getElementById("brokerSelect"),
      brokerLogin: document.getElementById("brokerLogin"),
      brokerPassword: document.getElementById("brokerPassword"),
      brokerServer: document.getElementById("brokerServer"),
      brokerTerminalPath: document.getElementById("brokerTerminalPath"),
      connectBtn: document.getElementById("connectBtn"),
      compatibilityLabel: document.getElementById("compatibilityLabel"),
      brokerDot: document.getElementById("brokerDot"),
      brokerStatus: document.getElementById("brokerStatus"),
      mq5File: document.getElementById("mq5File"),
      setFile: document.getElementById("setFile"),
      fileName: document.getElementById("fileName"),
      setFileName: document.getElementById("setFileName"),
      settingsPanel: document.getElementById("settingsPanel"),
      startBtn: document.getElementById("startBtn"),
      stopBtn: document.getElementById("stopBtn"),
      restartBtn: document.getElementById("restartBtn"),
      sessionPnlChip: document.getElementById("sessionPnlChip"),
      botModeChip: document.getElementById("botModeChip"),
      sessionPnlValue: document.getElementById("sessionPnlValue"),
      sessionPnlMeta: document.getElementById("sessionPnlMeta"),
      botThinkingValue: document.getElementById("botThinkingValue"),
      botActivityMeta: document.getElementById("botActivityMeta"),
      runStateChip: document.getElementById("runStateChip"),
      navLinks: Array.from(document.querySelectorAll(".nav-link[data-target]")),
      panels: Array.from(document.querySelectorAll(".section-panel")),
      chartSymbol: document.getElementById("chartSymbol"),
      chartTf: document.getElementById("chartTf"),
      allowedSymbol1: document.getElementById("allowedSymbol1"),
      allowedSymbol2: document.getElementById("allowedSymbol2"),
      applySymbolsBtn: document.getElementById("applySymbolsBtn"),
      toolTrend: document.getElementById("toolTrend"),
      toolPoly: document.getElementById("toolPoly"),
      toolHLine: document.getElementById("toolHLine"),
      toolRect: document.getElementById("toolRect"),
      toolLong: document.getElementById("toolLong"),
      toolShort: document.getElementById("toolShort"),
      toolClear: document.getElementById("toolClear"),
      zoomInBtn: document.getElementById("zoomInBtn"),
      zoomOutBtn: document.getElementById("zoomOutBtn"),
      resetViewBtn: document.getElementById("resetViewBtn"),
      autoScaleBtn: document.getElementById("autoScaleBtn"),
      freeMoveBtn: document.getElementById("freeMoveBtn"),
      closeTradeBtn: document.getElementById("closeTradeBtn"),
      marketChart: document.getElementById("marketChart"),
      chartMeta: document.getElementById("chartMeta"),
      liveBody: document.getElementById("liveBody"),
      historyBody: document.getElementById("historyBody"),
      systemLog: document.getElementById("systemLog"),
      logoutBtn: document.getElementById("logoutBtn")
    };

    function nowTime() { return new Date().toLocaleTimeString(); }
    function apiBase() { return (el.apiBase.value || "").trim().replace(/\/$/, ""); }
    function isFileMode() { return window.location.protocol === "file:"; }
    function normalizeSymbol(value) { return String(value || "").trim(); }
    function normalizeTf(value) { return String(value || "M1").trim().toUpperCase(); }

    function log(message, remote = false) {
      const key = remote ? `r:${message}` : `l:${message}`;
      if (state.seenLogs.has(key)) return;
      state.seenLogs.add(key);
      const p = document.createElement("p");
      p.className = "log-line";
      p.innerHTML = `<span class="t">[${nowTime()}]</span> ${message}`;
      el.systemLog.appendChild(p);
      el.systemLog.scrollTop = el.systemLog.scrollHeight;
      bus.dispatchEvent(new CustomEvent("log", { detail: message }));
    }

    async function sha256(text) {
      const bytes = new TextEncoder().encode(text);
      const hash = await crypto.subtle.digest("SHA-256", bytes);
      return [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, "0")).join("");
    }

    async function fetchApiSessionToken(force = false) {
      if (state.apiSessionToken && !force) return state.apiSessionToken;
      const base = apiBase();
      if (!base) throw new Error("Backend API URL is empty");
      const res = await fetch(`${base}/api/session`, { method: "GET" });
      const data = await res.json().catch(() => ({}));
      if (!res.ok || data.ok === false || !data.token) {
        throw new Error(data.error || `Session init failed (${res.status})`);
      }
      state.apiSessionToken = String(data.token);
      return state.apiSessionToken;
    }

    async function api(path, options = {}) {
      const base = apiBase();
      if (!base) throw new Error("Backend API URL is empty");
      const url = `${base}${path}`;
      let triedRefresh = false;

      while (true) {
        const headers = { ...(options.headers || {}) };
        if (path !== "/api/session") {
          const token = await fetchApiSessionToken(triedRefresh);
          headers["X-KutEA-Session"] = token;
        }

        const fetchOpts = { method: options.method || "GET", headers };
        if (options.formData) {
          fetchOpts.body = options.formData;
        } else if (options.body !== undefined) {
          fetchOpts.headers["Content-Type"] = "application/json";
          fetchOpts.body = JSON.stringify(options.body);
        }

        const res = await fetch(url, fetchOpts);
        const data = await res.json().catch(() => ({}));

        if (res.status === 401 && !triedRefresh && path !== "/api/session") {
          state.apiSessionToken = "";
          triedRefresh = true;
          continue;
        }

        if (!res.ok || data.ok === false) {
          throw new Error(data.error || `Request failed (${res.status})`);
        }
        return data;
      }
    }

    async function syncMarketContext(logErrors = false) {
      if (!state.backendApiOnline || !state.selectedSymbol) return false;
      try {
        await api("/api/market/select", {
          method: "POST",
          body: {
            symbol: state.selectedSymbol,
            tf: normalizeTf(state.chartTf)
          }
        });
        return true;
      } catch (err) {
        if (logErrors) log(`Market sync error: ${err.message}`);
        return false;
      }
    }

    async function handleLogin(evt) {
      evt.preventDefault();
      el.authError.textContent = "";
      const user = el.username.value.trim();
      const passHash = await sha256(el.password.value);
      if (user !== USERNAME || passHash !== PASS_HASH) {
        el.authError.textContent = "Invalid login credentials";
        return;
      }
      const session = { token: btoa(`${user}:${Date.now()}`), exp: Date.now() + 8 * 60 * 60 * 1000 };
      sessionStorage.setItem("kutea26_session", JSON.stringify(session));
      setAuthenticated(true);
      log("Authentication successful");
      log("Backend not connected. Set Backend API URL and click Connect Backend.");
    }

    function setAuthenticated(ok) {
      state.authenticated = ok;
      el.lockScreen.classList.toggle("hidden", ok);
      el.app.classList.toggle("hidden", !ok);
    }

    function loadSession() {
      try {
        const raw = sessionStorage.getItem("kutea26_session");
        if (!raw) return setAuthenticated(false);
        const sess = JSON.parse(raw);
        if (!sess?.exp || Date.now() > sess.exp) {
          sessionStorage.removeItem("kutea26_session");
          return setAuthenticated(false);
        }
        setAuthenticated(true);
        setBackendApiState(false, "Disconnected");
        stopPolling();
      } catch {
        setAuthenticated(false);
      }
    }

    function logout() {
      sessionStorage.removeItem("kutea26_session");
      disconnectBackendApi(false);
      setAuthenticated(false);
    }

    function setBackendApiState(online, text = "") {
      state.backendApiOnline = !!online;
      el.backendApiStatus.textContent = `Backend: ${text || (online ? "Connected" : "Disconnected")}`;
      el.backendApiBtn.textContent = online ? "Disconnect Backend" : "Connect Backend";
      el.backendApiBtn.classList.toggle("btn-backend-connect", !online);
      el.backendApiBtn.classList.toggle("btn-backend-disconnect", online);
    }

    function disconnectBackendApi(logMessage = true) {
      if (state.backendApiOnline) {
        api("/api/ea/stop", { method: "POST" }).catch(() => {});
      }
      setEngineState(false);
      stopPolling();
      state.apiSessionToken = "";
      setBackendApiState(false, "Disconnected");
      state.marketStructure = {};
      renderInsight(buildFallbackInsight());
      if (logMessage) log("Backend API disconnected");
    }

    async function connectBackendApi(manual = false) {
      try {
        await fetchApiSessionToken(true);
        await api("/api/health");
        setBackendApiState(true, "Connected");
        startPolling();
        if (manual) log("Backend API connected");
        return true;
      } catch (err) {
        disconnectBackendApi(false);
        if (manual || !isFileMode()) log(`Backend connect error: ${err.message}`);
        return false;
      }
    }

    async function toggleBackendApi() {
      if (state.backendApiOnline) {
        disconnectBackendApi(true);
        return;
      }
      await connectBackendApi(true);
    }

    function showPanel(panelId, updateHash = true) {
      const exists = el.panels.some(p => p.id === panelId);
      const target = exists ? panelId : "brokerPanel";
      state.activePanel = target;
      el.panels.forEach(p => p.classList.toggle("active", p.id === target));
      el.navLinks.forEach(link => link.classList.toggle("active", link.dataset.target === target));
      if (updateHash && window.location.hash !== `#${target}`) {
        history.replaceState(null, "", `#${target}`);
      }
      if (target === "marketPanel") {
        requestAnimationFrame(drawMarketChart);
      }
    }

    function initPanels() {
      el.navLinks.forEach(link => {
        link.addEventListener("click", (evt) => {
          evt.preventDefault();
          showPanel(link.dataset.target || "brokerPanel");
        });
      });
      const fromHash = (window.location.hash || "").replace("#", "").trim();
      showPanel(fromHash || "brokerPanel", false);
      window.addEventListener("hashchange", () => {
        const target = (window.location.hash || "").replace("#", "").trim();
        if (target) showPanel(target, false);
      });
    }

    function setBrokerStatus(connected, text) {
      state.connected = !!connected;
      el.brokerStatus.textContent = connected ? (text || "Connected") : (text || "Disconnected");
      el.brokerDot.classList.toggle("ok", connected);
      el.connectBtn.textContent = connected ? "Disconnect Broker" : "Connect Broker";
      el.connectBtn.classList.toggle("btn-disconnect", connected);
      el.connectBtn.classList.toggle("btn-primary", !connected);
    }

    function prettyName(raw) {
      return raw.replace(/^Inp/, "").replace(/([a-z0-9])([A-Z])/g, "$1 $2").trim();
    }

    function cleanDefault(v) { return String(v ?? "").replace(/^"|"$/g, ""); }

    function makeField(param) {
      const wrap = document.createElement("div");
      wrap.className = "col-4";
      const label = document.createElement("label");
      label.className = "hint";
      label.textContent = prettyName(param.name);
      const t = String(param.type || "").toLowerCase();
      const id = `set_${param.name}`;
      let ctrl;

      if (t === "bool") {
        ctrl = document.createElement("select");
        ctrl.innerHTML = `<option value="true">true</option><option value="false">false</option>`;
        const d = cleanDefault(param.defaultValue).toLowerCase();
        ctrl.value = (d === "true" || d === "1") ? "true" : "false";
      } else if (t.includes("timeframes") || t.includes("enum_timeframes")) {
        ctrl = document.createElement("select");
        ["PERIOD_M1","PERIOD_M5","PERIOD_M15","PERIOD_H1","PERIOD_H4","PERIOD_D1"].forEach(v => {
          const o = document.createElement("option");
          o.value = v;
          o.textContent = v;
          ctrl.appendChild(o);
        });
        ctrl.value = cleanDefault(param.defaultValue);
      } else {
        ctrl = document.createElement("input");
        ctrl.type = "text";
        ctrl.value = cleanDefault(param.defaultValue);
      }
      ctrl.id = id;
      ctrl.dataset.param = param.name;
      ctrl.dataset.type = param.type;
      wrap.appendChild(label);
      wrap.appendChild(ctrl);
      return wrap;
    }

    function buildSettingsPanel(params) {
      el.settingsPanel.innerHTML = "";
      if (!params?.length) {
        log("EA parameter parse returned empty list");
        el.setFile.disabled = true;
        el.setFileName.textContent = "No .set loaded";
        return;
      }
      params.forEach(p => el.settingsPanel.appendChild(makeField(p)));
      el.setFile.disabled = false;
      log(`EA Loaded Successfully - ${params.length} inputs parsed`);
    }

    function collectSettings() {
      const controls = el.settingsPanel.querySelectorAll("[data-param]");
      const out = {};
      controls.forEach(c => { out[c.dataset.param] = c.value; });
      state.settings = out;
      return out;
    }

    function parseSetContent(text) {
      const out = {};
      String(text || "").split(/\r?\n/).forEach(lineRaw => {
        const line = lineRaw.trim();
        if (!line) return;
        if (line.startsWith(";") || line.startsWith("#") || line.startsWith("//")) return;
        const eq = line.indexOf("=");
        if (eq <= 0) return;
        const key = line.slice(0, eq).trim();
        let val = line.slice(eq + 1).trim();
        if (!key) return;
        const sc = val.indexOf(";");
        if (sc > 0) val = val.slice(0, sc).trim();
        if ((val.startsWith("\"") && val.endsWith("\"")) || (val.startsWith("'") && val.endsWith("'"))) {
          val = val.slice(1, -1);
        }
        out[key] = val;
      });
      return out;
    }

    function applySetValues(values) {
      const controls = Array.from(el.settingsPanel.querySelectorAll("[data-param]"));
      const lowerMap = {};
      Object.keys(values || {}).forEach(k => { lowerMap[String(k).toLowerCase()] = values[k]; });
      let applied = 0;
      controls.forEach(ctrl => {
        const key = String(ctrl.dataset.param || "");
        if (!key) return;
        let val = values[key];
        if (val === undefined) val = lowerMap[key.toLowerCase()];
        if (val === undefined) return;
        const type = String(ctrl.dataset.type || "").toLowerCase();
        if (ctrl.tagName === "SELECT") {
          if (type === "bool") {
            const b = String(val).trim().toLowerCase();
            ctrl.value = (b === "true" || b === "1" || b === "yes" || b === "on") ? "true" : "false";
          } else {
            const v = String(val).trim();
            const has = Array.from(ctrl.options).some(o => o.value === v);
            if (has) ctrl.value = v;
          }
        } else {
          ctrl.value = String(val);
        }
        applied += 1;
      });
      collectSettings();
      return applied;
    }

    async function handleSetUpload(evt) {
      const file = evt.target.files?.[0];
      if (!file) return;
      if (!state.mq5Loaded) {
        log("Error: Load .mq5 first, then upload .set");
        el.setFile.value = "";
        return;
      }
      if (!file.name.toLowerCase().endsWith(".set")) {
        log("Error: Only .set upload is allowed here");
        el.setFile.value = "";
        return;
      }
      try {
        const text = await file.text();
        const values = parseSetContent(text);
        const applied = applySetValues(values);
        el.setFileName.textContent = `${file.name} (${applied} values applied)`;
        log(`.set loaded: ${applied} setting(s) applied`);
      } catch (err) {
        log(`Error: Failed to load .set (${err.message})`);
      }
    }

    async function disconnectBroker() {
      try {
        await api("/api/broker/disconnect", { method: "POST" });
      } catch (err) {
        log(`Error: ${err.message}`);
      }
      setBrokerStatus(false, "Disconnected");
      setEngineState(false);
      log("Broker Disconnected");
    }

    async function connectBroker() {
      if (state.connected) {
        await disconnectBroker();
        return;
      }
      const broker = el.brokerSelect.value;
      const login = el.brokerLogin.value.trim();
      const password = el.brokerPassword.value;
      const server = el.brokerServer.value.trim();
      const terminal_path = el.brokerTerminalPath.value.trim();

      if (!broker) { log("Error: Select a broker first"); return; }
      if (!login || !password || !server) {
        log("Error: Broker login, password, and server are required");
        return;
      }

      if (broker === "Deriv") el.compatibilityLabel.textContent = "Connected via MT5 bridge";
      else el.compatibilityLabel.textContent = "Direct MT5 Execution Mode";

      try {
        const res = await api("/api/broker/connect", {
          method: "POST",
          body: { broker, login, password, server, terminal_path }
        });
        setBrokerStatus(true, `Connected (${res.account?.login || login})`);
        el.brokerPassword.value = ""; // clear sensitive input from UI after connect
        log("Broker Connected");
      } catch (err) {
        setBrokerStatus(false, "Disconnected");
        setEngineState(false);
        log(`Error: ${err.message}`);
      }
    }

    async function handleFileUpload(evt) {
      const file = evt.target.files?.[0];
      if (!file) return;
      if (!file.name.toLowerCase().endsWith(".mq5")) {
        el.fileName.textContent = "Invalid file type";
        el.setFile.disabled = true;
        el.setFile.value = "";
        el.setFileName.textContent = "No .set loaded";
        log("Error: Only .mq5 upload is allowed");
        state.mq5Loaded = false;
        return;
      }
      const fd = new FormData();
      fd.append("file", file);
      try {
        const res = await api("/api/ea/upload", { method: "POST", formData: fd });
        el.fileName.textContent = file.name;
        state.parameters = res.params || [];
        buildSettingsPanel(state.parameters);
        state.mq5Loaded = true;
        el.setFileName.textContent = "No .set loaded";
      } catch (err) {
        state.mq5Loaded = false;
        el.setFile.disabled = true;
        el.setFile.value = "";
        el.setFileName.textContent = "No .set loaded";
        log(`Error: ${err.message}`);
      }
    }

    function renderLive(rows = []) {
      const html = rows.slice(0, 100).map(t => {
        const pnl = Number(t.pnl || 0);
        const pnlClass = pnl >= 0 ? "pnl-pos" : "pnl-neg";
        const symbol = String(t.symbol ?? "-");
        const symbolSafe = symbol.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
        const symbolBtn = symbol && symbol !== "-" ?
          `<button type="button" class="symbol-jump" data-symbol="${symbolSafe}">${symbolSafe}</button>` :
          "-";
        return `<tr>
          <td>${t.id ?? "-"}</td>
          <td>${symbolBtn}</td>
          <td>${Number(t.lot || 0).toFixed(2)}</td>
          <td>${Number(t.entry || 0).toFixed(2)}</td>
          <td>${Number(t.current || 0).toFixed(2)}</td>
          <td class="${pnlClass}">${pnl.toFixed(2)}</td>
          <td>${t.status || "Open"}</td>
        </tr>`;
      }).join("");
      el.liveBody.innerHTML = html || `<tr><td colspan="7" class="hint">No live transactions</td></tr>`;
    }

    function renderHistory(rows = []) {
      const html = rows.slice(0, 200).map(t => {
        const pnl = Number(t.pnl || 0);
        const pnlClass = pnl >= 0 ? "pnl-pos" : "pnl-neg";
        return `<tr>
          <td>${t.id ?? "-"}</td>
          <td>${t.symbol ?? "-"}</td>
          <td>${Number(t.entry || 0).toFixed(2)}</td>
          <td>${Number(t.exit || 0).toFixed(2)}</td>
          <td class="${pnlClass}">${pnl.toFixed(2)}</td>
          <td>${t.close_time || "-"}</td>
        </tr>`;
      }).join("");
      el.historyBody.innerHTML = html || `<tr><td colspan="6" class="hint">No completed trades</td></tr>`;
    }

    function chartKey(symbol, tf) {
      return `${symbol}|${tf}`;
    }

    function collectAllowedSymbolsFromInputs() {
      const raw = [normalizeSymbol(el.allowedSymbol1.value), normalizeSymbol(el.allowedSymbol2.value)];
      const out = [];
      raw.forEach(sym => {
        if (!sym) return;
        if (!out.includes(sym)) out.push(sym);
      });
      return out.slice(0, 2);
    }

    function syncAllowedSymbolInputs() {
      el.allowedSymbol1.value = state.allowedSymbols[0] || "";
      el.allowedSymbol2.value = state.allowedSymbols[1] || "";
    }

    function sameSymbolList(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i += 1) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }

    function setAllowedSymbols(symbols, syncInputs = true) {
      const out = [];
      (symbols || []).forEach(raw => {
        const sym = normalizeSymbol(raw);
        if (!sym) return;
        if (!out.includes(sym)) out.push(sym);
      });
      const next = out.slice(0, 2);
      if (sameSymbolList(state.allowedSymbols, next)) {
        if (syncInputs) syncAllowedSymbolInputs();
        return;
      }
      state.allowedSymbols = next;
      if (syncInputs) syncAllowedSymbolInputs();
      syncChartSymbolOptions();
    }

    function applyAllowedSymbols(logChange = true) {
      const symbols = collectAllowedSymbolsFromInputs();
      if (!symbols.length) {
        log("Error: Set at least one allowed market symbol");
        return false;
      }
      setAllowedSymbols(symbols, true);
      if (logChange) log(`Allowed markets set: ${symbols.join(", ")}`);
      return true;
    }

    function drawingKey() {
      if (!state.selectedSymbol) return "";
      return chartKey(state.selectedSymbol, state.chartTf);
    }

    function drawingsForCurrentChart() {
      const key = drawingKey();
      if (!key) return [];
      if (!state.chartDrawings[key]) state.chartDrawings[key] = [];
      return state.chartDrawings[key];
    }

    function setChartTool(tool) {
      state.chartTool = tool;
      state.chartPendingPoint = null;
      state.chartPendingPoints = [];
      state.chartDragStart = null;
      state.chartDragCurrent = null;
      state.chartPointerDown = false;
      state.chartPointerId = null;
      state.chartPanMode = false;
      state.chartScaleMode = false;
      state.chartPinchMode = false;
      state.chartPointerSamples = {};
      state.chartPositionDraft = null;
      if (tool !== "none") state.selectedDrawingIndex = -1;
      el.toolTrend.classList.toggle("active", tool === "trend");
      el.toolPoly.classList.toggle("active", tool === "poly");
      el.toolHLine.classList.toggle("active", tool === "hline");
      el.toolRect.classList.toggle("active", tool === "rect");
      el.toolLong.classList.toggle("active", tool === "long");
      el.toolShort.classList.toggle("active", tool === "short");
      drawMarketChart();
    }

    function syncChartSymbolOptions() {
      const observedSymbols = Array.from(new Set([
        ...state.trades.map(t => normalizeSymbol(t.symbol)).filter(Boolean),
        ...state.history.map(t => normalizeSymbol(t.symbol)).filter(Boolean),
      ])).sort();
      const symbols = state.allowedSymbols.length ? [...state.allowedSymbols] : observedSymbols;
      const prev = el.chartSymbol.value;
      el.chartSymbol.innerHTML = "";

      if (!symbols.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No symbols yet";
        el.chartSymbol.appendChild(opt);
        state.selectedSymbol = "";
        drawMarketChart();
        return;
      }

      symbols.forEach(sym => {
        const opt = document.createElement("option");
        opt.value = sym;
        opt.textContent = sym;
        el.chartSymbol.appendChild(opt);
      });

      const next = symbols.includes(prev) ? prev : (symbols.includes(state.selectedSymbol) ? state.selectedSymbol : symbols[0]);
      state.selectedSymbol = next;
      el.chartSymbol.value = next;
      fetchMarketCandles(false).catch(() => {});
    }

    async function fetchMarketCandles(force = false) {
      if (!state.selectedSymbol || !state.backendApiOnline) return;
      const tf = el.chartTf.value || "M1";
      if (!force && state.chartTf !== tf) state.chartTf = tf;
      const sym = state.selectedSymbol;
      const key = chartKey(sym, state.chartTf);
      try {
        const data = await api(`/api/market/candles?symbol=${encodeURIComponent(sym)}&tf=${encodeURIComponent(state.chartTf)}&count=320&since_running=0`);
        state.marketCandles[key] = data.candles || [];
        const structure = data.structure || {};
        const incomingPoints = Array.isArray(structure.points) ? structure.points : [];
        const incomingFvg = Array.isArray(structure.fvg) ? structure.fvg : [];
        const prevStructure = state.marketStructure[key] || { points: [], fvg: [], updated_at: null, source: "none" };
        const hasIncoming = incomingPoints.length > 0 || incomingFvg.length > 0;
        if (hasIncoming) {
          state.marketStructure[key] = {
            points: incomingPoints,
            fvg: incomingFvg,
            updated_at: structure.updated_at || null,
            source: structure.source || "none"
          };
        } else {
          state.marketStructure[key] = {
            points: Array.isArray(prevStructure.points) ? prevStructure.points : [],
            fvg: Array.isArray(prevStructure.fvg) ? prevStructure.fvg : [],
            updated_at: prevStructure.updated_at || null,
            source: prevStructure.source || "cache"
          };
        }
        drawMarketChart();
      } catch (err) {
        if (force) log(`Chart data error: ${err.message}`);
      }
    }

    function drawEmptyChart(ctx, w, h, message) {
      ctx.fillStyle = "#0b1528";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#8ea2cc";
      ctx.font = "14px Segoe UI";
      ctx.textAlign = "center";
      ctx.fillText(message, w / 2, h / 2);
      state.chartViewport = null;
    }

    function clampNumber(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function xForIndex(index, vp) {
      const rel = (Number(index) - vp.startIndex) + 0.5;
      return vp.left + (rel / Math.max(1, vp.count)) * vp.plotW;
    }

    function yForPrice(price, vp) {
      return vp.top + ((vp.hi - price) / Math.max(0.0000001, vp.hi - vp.lo)) * vp.plotH;
    }

    function indexFromX(x, vp) {
      const raw = ((x - vp.left) / Math.max(1, vp.plotW)) * vp.count - 0.5;
      return clampNumber(Math.round(vp.startIndex + raw), vp.startIndex, vp.endIndex - 1);
    }

    function priceFromY(y, vp) {
      const ratio = (y - vp.top) / Math.max(1, vp.plotH);
      return vp.hi - ratio * (vp.hi - vp.lo);
    }

    function inferPriceDigits(candles) {
      let digits = 2;
      candles.slice(-40).forEach(c => {
        const s = String(c.close ?? "");
        const idx = s.indexOf(".");
        if (idx >= 0) digits = Math.max(digits, s.length - idx - 1);
      });
      return Math.max(2, Math.min(6, digits));
    }

    function formatPrice(v, digits) {
      return Number(v || 0).toFixed(digits);
    }

    function formatSignedMoney(v, digits = 2) {
      const n = Number(v || 0);
      return `${n >= 0 ? "+" : ""}${n.toFixed(digits)}`;
    }

    function formatTimeLabel(unixTs) {
      return new Date(Number(unixTs) * 1000).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }

    function buildFallbackInsight() {
      const floating = (state.trades || [])
        .filter(t => String(t.status || "Open").toLowerCase() === "open")
        .reduce((acc, t) => acc + Number(t.pnl || 0), 0);
      let thinking = "Idle";
      let waiting = "Connect broker and start EA";
      let active = "None";
      let mode = "IDLE";
      if (state.connected && !state.eaRunning) {
        thinking = "Broker connected";
        waiting = "Start EA";
        active = "No open positions";
      } else if (state.connected && state.eaRunning && (state.trades || []).length === 0) {
        thinking = "Scanning markets";
        waiting = "Entry conditions";
        active = state.selectedSymbol || "Allowed symbols";
        mode = "RUNNING";
      } else if (state.connected && state.eaRunning && (state.trades || []).length > 0) {
        thinking = `Managing ${(state.trades || []).length} open trade(s)`;
        waiting = "SL/TP hit or close signal";
        active = Array.from(new Set((state.trades || []).map(t => String(t.symbol || "")).filter(Boolean))).join(", ") || "Open positions";
        mode = "RUNNING";
      }
      return {
        session: {
          realized: 0,
          floating,
          total: floating,
          trades: 0,
          wins: 0,
          losses: 0
        },
        bot_state: {
          mode,
          thinking,
          waiting_for: waiting,
          active
        }
      };
    }

    function renderInsight(insightRaw = null) {
      const insight = insightRaw && typeof insightRaw === "object" ? insightRaw : buildFallbackInsight();
      state.sessionInsight = insight;
      const session = insight.session || {};
      const bot = insight.bot_state || {};
      const realized = Number(session.realized || 0);
      const floating = Number(session.floating || 0);
      const total = Number(session.total || (realized + floating));
      const trades = Number(session.trades || 0);
      const wins = Number(session.wins || 0);
      const losses = Number(session.losses || 0);
      const totalText = formatSignedMoney(total, 2);
      el.sessionPnlChip.textContent = `Session P/L: ${totalText}`;
      el.sessionPnlValue.textContent = totalText;
      el.sessionPnlValue.classList.toggle("insight-pos", total >= 0);
      el.sessionPnlValue.classList.toggle("insight-neg", total < 0);
      el.sessionPnlMeta.textContent = `Realized: ${formatSignedMoney(realized, 2)} | Floating: ${formatSignedMoney(floating, 2)} | Trades: ${trades} (W:${wins} L:${losses})`;
      const thinking = String(bot.thinking || "Idle");
      const waiting = String(bot.waiting_for || "Waiting");
      const active = String(bot.active || "None");
      const mode = String(bot.mode || "IDLE").toUpperCase();
      el.botModeChip.textContent = `Bot: ${mode}`;
      el.botThinkingValue.textContent = thinking;
      el.botActivityMeta.textContent = `Active: ${active}\nWaiting: ${waiting}\nMode: ${mode}`;
    }

    function findClosestCandleIndexByTime(candles, unixTs) {
      if (!Array.isArray(candles) || candles.length === 0 || !Number.isFinite(unixTs)) return null;
      let lo = 0;
      let hi = candles.length - 1;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        const t = Number(candles[mid].time || 0);
        if (t < unixTs) lo = mid + 1;
        else if (t > unixTs) hi = mid - 1;
        else return mid;
      }
      const i1 = clampNumber(lo, 0, candles.length - 1);
      const i0 = clampNumber(i1 - 1, 0, candles.length - 1);
      const d0 = Math.abs(Number(candles[i0].time || 0) - unixTs);
      const d1 = Math.abs(Number(candles[i1].time || 0) - unixTs);
      return d0 <= d1 ? i0 : i1;
    }

    function drawEAStructureOverlay(ctx, vp, candles, structure) {
      if (!structure || typeof structure !== "object") return;
      const points = Array.isArray(structure.points) ? structure.points.slice(-120) : [];
      const fvgs = Array.isArray(structure.fvg) ? structure.fvg.slice(-80) : [];
      const colorMap = {
        HH: "#53d6ff",
        HL: "#2ad28a",
        LH: "#ffb85e",
        LL: "#ff6f82",
      };

      fvgs.forEach(z => {
        const low = Number(z.low);
        const high = Number(z.high);
        if (!Number.isFinite(low) || !Number.isFinite(high)) return;
        const t1 = Number(z.t1);
        const t2 = Number(z.t2);
        let i1 = Number.isFinite(t1) ? findClosestCandleIndexByTime(candles, t1) : null;
        let i2 = Number.isFinite(t2) ? findClosestCandleIndexByTime(candles, t2) : null;
        if (!Number.isFinite(i1)) i1 = Math.max(0, candles.length - 24);
        if (!Number.isFinite(i2)) i2 = candles.length - 1;
        const abs1 = vp.startIndex + clampNumber(Number(i1), 0, vp.count - 1);
        const abs2 = vp.startIndex + clampNumber(Number(i2), 0, vp.count - 1);
        const x1 = xForIndex(Math.min(abs1, abs2), vp);
        const x2 = xForIndex(Math.max(abs1, abs2), vp);
        const y1 = yForPrice(high, vp);
        const y2 = yForPrice(low, vp);
        const top = Math.min(y1, y2);
        const h = Math.max(1, Math.abs(y2 - y1));
        const side = String(z.side || "").toLowerCase();
        const fill = side === "bear" ? "rgba(239,83,92,0.16)" : "rgba(27,181,129,0.16)";
        const stroke = side === "bear" ? "rgba(239,83,92,0.58)" : "rgba(27,181,129,0.58)";
        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;
        ctx.lineWidth = 1;
        ctx.fillRect(x1, top, Math.max(2, x2 - x1), h);
        ctx.strokeRect(x1, top, Math.max(2, x2 - x1), h);
      });

      ctx.font = "11px Segoe UI";
      points.forEach(p => {
        const typ = String(p.type || "").toUpperCase();
        if (!colorMap[typ]) return;
        const price = Number(p.price);
        if (!Number.isFinite(price)) return;
        const ts = Number(p.time);
        const relIdx = Number.isFinite(ts) ? findClosestCandleIndexByTime(candles, ts) : (candles.length - 1);
        if (!Number.isFinite(relIdx)) return;
        const absIndex = vp.startIndex + clampNumber(Number(relIdx), 0, vp.count - 1);
        const x = xForIndex(absIndex, vp);
        const y = yForPrice(price, vp);
        ctx.fillStyle = colorMap[typ];
        ctx.strokeStyle = "#0b1220";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(x, y, 3.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        drawPriceTag(ctx, x + 6, y - 10, typ, "#1b2f4f", "#dff0ff", vp.top, vp.top + vp.plotH);
      });
    }

    function chartPointFromEvent(evt) {
      if (!state.chartViewport) return null;
      const rect = el.marketChart.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      const vp = state.chartViewport;
      const inside = x >= vp.left && x <= (vp.left + vp.plotW) && y >= vp.top && y <= (vp.top + vp.plotH);
      const axis = x > (vp.left + vp.plotW) && x <= (vp.left + vp.plotW + vp.right) && y >= vp.top && y <= (vp.top + vp.plotH);
      if (!inside && !axis) return { x, y, inside: false, axis: false, vp };
      const px = clampNumber(x, vp.left, vp.left + vp.plotW);
      return {
        x,
        y,
        inside,
        axis,
        vp,
        i: indexFromX(px, vp),
        p: priceFromY(y, vp),
      };
    }

    function trackPointer(evt, pt = null) {
      if (evt.pointerId === undefined || evt.pointerId === null) return;
      const point = pt || chartPointFromEvent(evt);
      if (!point) return;
      state.chartPointerSamples[String(evt.pointerId)] = { x: point.x, y: point.y };
    }

    function untrackPointer(pointerId) {
      if (pointerId === undefined || pointerId === null) return;
      delete state.chartPointerSamples[String(pointerId)];
    }

    function pointerSamples() {
      const rows = Object.values(state.chartPointerSamples || {});
      return rows.filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
    }

    function beginPinch(vp) {
      const pts = pointerSamples();
      if (pts.length < 2) return false;
      const a = pts[0];
      const b = pts[1];
      state.chartPinchMode = true;
      state.chartPanMode = false;
      state.chartScaleMode = false;
      state.chartPinchStartDist = Math.max(8, Math.hypot(a.x - b.x, a.y - b.y));
      state.chartPinchStartCenterX = (a.x + b.x) / 2;
      state.chartPinchStartCenterY = (a.y + b.y) / 2;
      state.chartPinchStartVisible = state.chartVisibleCount || vp.count || 150;
      state.chartPinchStartYZoom = Number(state.chartYZoom || 1);
      state.chartPinchStartPanBars = Number(state.chartPanBars || 0);
      state.chartPinchStartYShift = Number(state.chartYShift || 0);
      return true;
    }

    function drawPriceTag(ctx, x, y, text, bg, fg = "#f2f7ff", minY = null, maxY = null) {
      const padX = 6;
      const h = 18;
      const w = ctx.measureText(text).width + padX * 2;
      const cy = (minY !== null && maxY !== null) ? clampNumber(y, minY + Math.floor(h / 2), maxY - Math.floor(h / 2)) : y;
      ctx.fillStyle = bg;
      ctx.fillRect(x, cy - Math.floor(h / 2), w, h);
      ctx.fillStyle = fg;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText(text, x + padX, cy);
    }

    function drawPositionProjection(ctx, vp, pos, digits, includeHandles = false) {
      const side = String(pos.side || "").toUpperCase() === "SHORT" ? "SHORT" : "LONG";
      const entry = Number(pos.entry);
      const stop = Number(pos.stop);
      const target = Number(pos.target);
      const hasStop = Number.isFinite(stop);
      const hasTarget = Number.isFinite(target);
      if (!Number.isFinite(entry)) return;

      const defaultStart = vp.endIndex - Math.max(10, Math.floor(vp.count * 0.30));
      const defaultEnd = vp.endIndex - 2;
      const idx1 = Number.isFinite(pos.i1) ? Number(pos.i1) : defaultStart;
      const idx2 = Number.isFinite(pos.i2) ? Number(pos.i2) : defaultEnd;
      let x1 = xForIndex(Math.min(idx1, idx2), vp);
      let x2 = xForIndex(Math.max(idx1, idx2), vp);
      x1 = clampNumber(x1, vp.left + 2, vp.left + vp.plotW - 2);
      x2 = clampNumber(x2, vp.left + 2, vp.left + vp.plotW - 2);
      if (Math.abs(x2 - x1) < 18) x2 = Math.min(vp.left + vp.plotW - 2, x1 + 18);

      const yEntry = yForPrice(entry, vp);
      const yStop = hasStop ? yForPrice(stop, vp) : null;
      const yTarget = hasTarget ? yForPrice(target, vp) : null;
      const entryOnly = !hasStop && !hasTarget;

      const red = "rgba(239,83,92,0.28)";
      const green = "rgba(27,181,129,0.28)";

      if (entryOnly) {
        ctx.setLineDash([3, 4]);
        ctx.strokeStyle = side === "SHORT" ? "rgba(239,83,92,0.85)" : "rgba(27,181,129,0.85)";
        ctx.beginPath();
        ctx.moveTo(vp.left, yEntry);
        ctx.lineTo(vp.left + vp.plotW, yEntry);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.font = "11px Segoe UI";
        drawPriceTag(ctx, x1 + 6, yEntry, `Entry: ${formatPrice(entry, digits)}`, "#22456f", "#f2f7ff", vp.top, vp.top + vp.plotH);
        if (includeHandles) {
          ctx.fillStyle = "#f8fdff";
          ctx.strokeStyle = "#4f86ff";
          [[x1, yEntry], [x2, yEntry]].forEach(([hx, hy]) => {
            ctx.beginPath();
            ctx.rect(hx - 4, hy - 4, 8, 8);
            ctx.fill();
            ctx.stroke();
          });
        }
        return;
      }

      if (hasStop && yStop !== null) {
        const rTop = Math.min(yEntry, yStop);
        const rBot = Math.max(yEntry, yStop);
        ctx.fillStyle = red;
        ctx.fillRect(x1, rTop, x2 - x1, Math.max(1, rBot - rTop));
      }
      if (hasTarget && yTarget !== null) {
        const gTop = Math.min(yEntry, yTarget);
        const gBot = Math.max(yEntry, yTarget);
        ctx.fillStyle = green;
        ctx.fillRect(x1, gTop, x2 - x1, Math.max(1, gBot - gTop));
      }

      const yVals = [yEntry];
      if (hasStop && yStop !== null) yVals.push(yStop);
      if (hasTarget && yTarget !== null) yVals.push(yTarget);
      const boxTop = Math.min(...yVals);
      const boxBot = Math.max(...yVals);
      ctx.strokeStyle = "rgba(170,190,230,0.75)";
      ctx.lineWidth = 1;
      ctx.strokeRect(x1, boxTop, Math.max(1, x2 - x1), Math.max(1, boxBot - boxTop));

      ctx.setLineDash([3, 4]);
      ctx.strokeStyle = "rgba(160,180,220,0.55)";
      ctx.beginPath();
      ctx.moveTo(vp.left, yEntry);
      ctx.lineTo(vp.left + vp.plotW, yEntry);
      ctx.stroke();
      ctx.setLineDash([]);

      const risk = hasStop ? Math.abs(entry - stop) : 0;
      const reward = hasTarget ? Math.abs(target - entry) : 0;
      const rr = (hasStop && hasTarget && risk > 0) ? (reward / risk) : null;
      const qty = Number(pos.qty || 0);
      const centerY = Math.max(vp.top + 10, Math.min(vp.top + vp.plotH - 10, (boxTop + boxBot) / 2));

      ctx.font = "11px Segoe UI";
      if (hasStop && yStop !== null) drawPriceTag(ctx, x1 + 6, yStop, `Stop: ${formatPrice(stop, digits)}`, "#d24b5a", "#f2f7ff", vp.top, vp.top + vp.plotH);
      if (hasTarget && yTarget !== null) drawPriceTag(ctx, x1 + 6, yTarget, `Target: ${formatPrice(target, digits)}`, "#0e9b73", "#f2f7ff", vp.top, vp.top + vp.plotH);
      const rrText = rr === null ? "RR -" : `RR ${rr.toFixed(2)}`;
      drawPriceTag(ctx, x1 + 6, centerY, `${side} | ${rrText}${qty > 0 ? ` | Qty ${qty}` : ""}`, "#165f92", "#f2f7ff", vp.top, vp.top + vp.plotH);

      if (includeHandles) {
        ctx.fillStyle = "#f8fdff";
        ctx.strokeStyle = "#4f86ff";
        const hs = [ [x1, yEntry], [x2, yEntry] ];
        if (hasStop && yStop !== null) hs.push([x1, yStop], [x2, yStop]);
        if (hasTarget && yTarget !== null) hs.push([x1, yTarget], [x2, yTarget]);
        hs.forEach(([hx, hy]) => {
          ctx.beginPath();
          ctx.rect(hx - 4, hy - 4, 8, 8);
          ctx.fill();
          ctx.stroke();
        });
      }
    }

    function positionGeometry(pos, vp) {
      if (!pos) return null;
      const entry = Number(pos.entry);
      const stop = Number(pos.stop);
      const target = Number(pos.target);
      if (!Number.isFinite(entry)) return null;
      const i1Raw = Number.isFinite(pos.i1) ? Number(pos.i1) : (vp.endIndex - Math.floor(vp.count * 0.30));
      const i2Raw = Number.isFinite(pos.i2) ? Number(pos.i2) : (vp.endIndex - 2);
      const i1 = Math.min(i1Raw, i2Raw);
      const i2 = Math.max(i1Raw, i2Raw);
      const x1 = clampNumber(xForIndex(i1, vp), vp.left + 2, vp.left + vp.plotW - 2);
      const x2 = clampNumber(xForIndex(i2, vp), vp.left + 2, vp.left + vp.plotW - 2);
      const yEntry = yForPrice(entry, vp);
      const yStop = Number.isFinite(stop) ? yForPrice(stop, vp) : null;
      const yTarget = Number.isFinite(target) ? yForPrice(target, vp) : null;
      const yVals = [yEntry];
      if (yStop !== null) yVals.push(yStop);
      if (yTarget !== null) yVals.push(yTarget);
      return {
        i1,
        i2,
        x1,
        x2,
        midX: (x1 + x2) / 2,
        yEntry,
        yStop,
        yTarget,
        top: Math.min(...yVals),
        bottom: Math.max(...yVals),
      };
    }

    function findPositionHandleAt(x, y, vp) {
      const drawings = drawingsForCurrentChart();
      const maxDist = 10;
      for (let idx = drawings.length - 1; idx >= 0; idx -= 1) {
        const d = drawings[idx];
        if (d.type !== "position") continue;
        const g = positionGeometry(d, vp);
        if (!g) continue;
        const handles = [
          { name: "leftEntry", x: g.x1, y: g.yEntry },
          { name: "rightEntry", x: g.x2, y: g.yEntry },
          ...(g.yStop === null ? [] : [{ name: "leftStop", x: g.x1, y: g.yStop }, { name: "rightStop", x: g.x2, y: g.yStop }]),
          ...(g.yTarget === null ? [] : [{ name: "leftTarget", x: g.x1, y: g.yTarget }, { name: "rightTarget", x: g.x2, y: g.yTarget }]),
        ];
        for (const h of handles) {
          const dx = x - h.x;
          const dy = y - h.y;
          if ((dx * dx + dy * dy) <= (maxDist * maxDist)) {
            return { index: idx, handle: h.name };
          }
        }
      }
      return null;
    }

    function normalizePositionDrawing(d, vp) {
      if (!d) return;
      const total = vp.totalCount || state.chartTotalCount || vp.count || 320;
      d.i1 = clampNumber(Math.round(Number(d.i1 || 0)), 0, Math.max(0, total - 2));
      d.i2 = clampNumber(Math.round(Number(d.i2 || d.i1 + 1)), 1, Math.max(1, total - 1));
      if (d.i2 <= d.i1) d.i2 = Math.min(total - 1, d.i1 + 1);

      d.entry = Number(d.entry);
      const stopNum = Number(d.stop);
      const targetNum = Number(d.target);
      d.stop = Number.isFinite(stopNum) ? stopNum : null;
      d.target = Number.isFinite(targetNum) ? targetNum : null;
      const minGap = Math.max((vp.hi - vp.lo) * 0.001, 0.00001);
      const isShort = String(d.side || "").toUpperCase() === "SHORT";
      if (isShort) {
        if (d.stop !== null && d.stop <= d.entry + minGap) d.stop = d.entry + minGap;
        if (d.target !== null && d.target >= d.entry - minGap) d.target = d.entry - minGap;
      } else {
        if (d.stop !== null && d.stop >= d.entry - minGap) d.stop = d.entry - minGap;
        if (d.target !== null && d.target <= d.entry + minGap) d.target = d.entry + minGap;
      }
    }

    function applyPositionHandleDrag(edit, i, p, vp) {
      const drawings = drawingsForCurrentChart();
      if (!edit || !Number.isFinite(i) || !Number.isFinite(p)) return false;
      const d = drawings[edit.index];
      if (!d || d.type !== "position") return false;

      const h = String(edit.handle || "");
      if (h.startsWith("left")) d.i1 = i;
      if (h.startsWith("right")) d.i2 = i;
      if (h.endsWith("Stop")) d.stop = p;
      if (h.endsWith("Entry")) d.entry = p;
      if (h.endsWith("Target")) d.target = p;
      if (h === "midStop") d.stop = p;
      if (h === "midEntry") d.entry = p;
      if (h === "midTarget") d.target = p;

      normalizePositionDrawing(d, vp);
      return true;
    }

    function distanceToSegment(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      if (dx === 0 && dy === 0) return Math.hypot(px - x1, py - y1);
      const t = clampNumber(((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy), 0, 1);
      const cx = x1 + t * dx;
      const cy = y1 + t * dy;
      return Math.hypot(px - cx, py - cy);
    }

    function findDrawingAt(x, y, vp) {
      const drawings = drawingsForCurrentChart();
      const tol = 8;
      for (let idx = drawings.length - 1; idx >= 0; idx -= 1) {
        const d = drawings[idx];
        if (d.type === "hline") {
          const yy = yForPrice(d.p, vp);
          if (Math.abs(y - yy) <= tol) return idx;
        } else if (d.type === "trend") {
          const x1 = xForIndex(d.i1, vp);
          const y1 = yForPrice(d.p1, vp);
          const x2 = xForIndex(d.i2, vp);
          const y2 = yForPrice(d.p2, vp);
          if (distanceToSegment(x, y, x1, y1, x2, y2) <= tol) return idx;
        } else if (d.type === "rect") {
          const x1 = xForIndex(Math.min(d.i1, d.i2), vp);
          const x2 = xForIndex(Math.max(d.i1, d.i2), vp);
          const y1 = yForPrice(d.p1, vp);
          const y2 = yForPrice(d.p2, vp);
          const left = Math.min(x1, x2), right = Math.max(x1, x2);
          const top = Math.min(y1, y2), bottom = Math.max(y1, y2);
          if (x >= left - tol && x <= right + tol && y >= top - tol && y <= bottom + tol) return idx;
        } else if (d.type === "poly") {
          const pts = Array.isArray(d.points) ? d.points : [];
          for (let i = 1; i < pts.length; i += 1) {
            const x1 = xForIndex(pts[i - 1].i, vp);
            const y1 = yForPrice(pts[i - 1].p, vp);
            const x2 = xForIndex(pts[i].i, vp);
            const y2 = yForPrice(pts[i].p, vp);
            if (distanceToSegment(x, y, x1, y1, x2, y2) <= tol) return idx;
          }
        } else if (d.type === "position") {
          const g = positionGeometry(d, vp);
          if (!g) continue;
          if (x >= Math.min(g.x1, g.x2) - tol && x <= Math.max(g.x1, g.x2) + tol && y >= g.top - tol && y <= g.bottom + tol) {
            return idx;
          }
        }
      }
      return -1;
    }

    function drawLivePositionOverlays(ctx, vp, digits) {
      if (!Array.isArray(state.trades) || !state.selectedSymbol) return;
      const rows = state.trades
        .filter(t => String(t.symbol || "") === state.selectedSymbol)
        .filter(t => String(t.status || "Open").toLowerCase() === "open")
        .slice(0, 3);
      rows.forEach((t, idx) => {
        const entry = Number(t.entry);
        const sl = Number(t.sl);
        const tp = Number(t.tp);
        if (!Number.isFinite(entry)) return;
        const sideRaw = String(t.side || "").toUpperCase();
        const side = sideRaw === "SELL" ? "SHORT" : "LONG";
        const wBars = Math.max(16, Math.floor(vp.count * 0.26));
        const rightIndex = vp.endIndex - 2 - idx * Math.max(2, Math.floor(vp.count * 0.02));
        const leftIndex = rightIndex - wBars;
        const stop = (Number.isFinite(sl) && sl > 0) ? sl : null;
        const target = (Number.isFinite(tp) && tp > 0) ? tp : null;
        drawPositionProjection(ctx, vp, {
          side,
          entry,
          stop,
          target,
          i1: leftIndex,
          i2: rightIndex,
          qty: Number(t.lot || 0),
        }, digits, false);
      });
    }

    function buildPositionDraft(side, points, vp, fallbackPoint = null) {
      if (!points || points.length < 2) return null;
      const p1 = points[0];
      const p2 = points[1];
      const p3 = points[2] || fallbackPoint;
      if (!p1 || !p2 || !p3) return null;
      const entry = Number(p1.p);
      let stop = Number(p2.p);
      let target = Number(p3.p);
      const rng = Math.max((vp.hi - vp.lo) * 0.04, 0.00001);
      if (String(side).toLowerCase() === "short") {
        if (stop <= entry) stop = entry + Math.max(Math.abs(entry - stop), rng);
        if (target >= entry) target = entry - Math.max(Math.abs(target - entry), rng);
      } else {
        if (stop >= entry) stop = entry - Math.max(Math.abs(stop - entry), rng);
        if (target <= entry) target = entry + Math.max(Math.abs(target - entry), rng);
      }
      return { side: String(side).toUpperCase(), entry, stop, target, i1: p1.i, i2: p3.i };
    }

    function drawChartDrawings(ctx, vp) {
      const drawings = drawingsForCurrentChart();
      ctx.save();
      drawings.forEach((d, idx) => {
        const selected = idx === state.selectedDrawingIndex;
        if (d.type === "hline") {
          const y = yForPrice(d.p, vp);
          ctx.strokeStyle = selected ? "#ffd88f" : "#e8c27d";
          ctx.lineWidth = selected ? 1.8 : 1.2;
          ctx.beginPath();
          ctx.moveTo(vp.left, y);
          ctx.lineTo(vp.left + vp.plotW, y);
          ctx.stroke();
        } else if (d.type === "trend") {
          const x1 = xForIndex(d.i1, vp);
          const y1 = yForPrice(d.p1, vp);
          const x2 = xForIndex(d.i2, vp);
          const y2 = yForPrice(d.p2, vp);
          ctx.strokeStyle = selected ? "#9ac8ff" : "#7eb5ff";
          ctx.lineWidth = selected ? 2.0 : 1.5;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        } else if (d.type === "rect") {
          const x1 = xForIndex(Math.min(d.i1, d.i2), vp);
          const x2 = xForIndex(Math.max(d.i1, d.i2), vp);
          const y1 = yForPrice(d.p1, vp);
          const y2 = yForPrice(d.p2, vp);
          const left = Math.min(x1, x2);
          const top = Math.min(y1, y2);
          const w = Math.max(2, Math.abs(x2 - x1));
          const h = Math.max(2, Math.abs(y2 - y1));
          ctx.fillStyle = selected ? "rgba(118,169,255,0.16)" : "rgba(118,169,255,0.10)";
          ctx.strokeStyle = selected ? "rgba(160,205,255,0.95)" : "rgba(118,169,255,0.90)";
          ctx.lineWidth = selected ? 1.8 : 1.2;
          ctx.fillRect(left, top, w, h);
          ctx.strokeRect(left, top, w, h);
        } else if (d.type === "poly") {
          const pts = Array.isArray(d.points) ? d.points : [
            { i: d.i1, p: d.p1 },
            { i: d.i2, p: d.p2 },
            { i: d.i3, p: d.p3 }
          ].filter(p => Number.isFinite(p.i) && Number.isFinite(p.p));
          if (pts.length < 2) return;
          ctx.strokeStyle = selected ? "#afd1ff" : "#90b6ff";
          ctx.lineWidth = selected ? 1.9 : 1.4;
          ctx.beginPath();
          ctx.moveTo(xForIndex(pts[0].i, vp), yForPrice(pts[0].p, vp));
          for (let k = 1; k < pts.length; k += 1) {
            ctx.lineTo(xForIndex(pts[k].i, vp), yForPrice(pts[k].p, vp));
          }
          ctx.stroke();
        } else if (d.type === "position") {
          drawPositionProjection(ctx, vp, d, vp.priceDigits || 5, idx === state.selectedDrawingIndex);
        }
      });

      if (state.chartPointerDown && state.chartDragStart && state.chartDragCurrent) {
        const sx = xForIndex(state.chartDragStart.i, vp);
        const sy = yForPrice(state.chartDragStart.p, vp);
        const ex = xForIndex(state.chartDragCurrent.i, vp);
        const ey = yForPrice(state.chartDragCurrent.p, vp);
        ctx.setLineDash([6, 4]);
        ctx.strokeStyle = "#9ec5ff";
        ctx.fillStyle = "rgba(118,169,255,0.10)";
        if (state.chartTool === "trend") {
          ctx.lineWidth = 1.3;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();
        } else if (state.chartTool === "rect") {
          const left = Math.min(sx, ex);
          const top = Math.min(sy, ey);
          const w = Math.max(2, Math.abs(ex - sx));
          const h = Math.max(2, Math.abs(ey - sy));
          ctx.fillRect(left, top, w, h);
          ctx.strokeRect(left, top, w, h);
        }
        ctx.setLineDash([]);
      }

      if (state.chartTool === "poly" && state.chartPendingPoints.length > 0) {
        ctx.strokeStyle = "#9ec5ff";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(xForIndex(state.chartPendingPoints[0].i, vp), yForPrice(state.chartPendingPoints[0].p, vp));
        for (let k = 1; k < state.chartPendingPoints.length; k += 1) {
          const pp = state.chartPendingPoints[k];
          ctx.lineTo(xForIndex(pp.i, vp), yForPrice(pp.p, vp));
        }
        if (state.chartHover) ctx.lineTo(xForIndex(state.chartHover.i, vp), yForPrice(state.chartHover.p, vp));
        ctx.stroke();
      }

      if ((state.chartTool === "long" || state.chartTool === "short") && state.chartPendingPoints.length >= 1) {
        const side = state.chartTool === "short" ? "SHORT" : "LONG";
        const draft = buildPositionDraft(side, state.chartPendingPoints, vp, state.chartHover);
        if (draft) {
          drawPositionProjection(ctx, vp, {
            ...draft,
            i2: Number.isFinite(draft.i2) ? draft.i2 : (draft.i1 + Math.floor(vp.count * 0.24)),
          }, vp.priceDigits || 5, true);
        }
      }
      ctx.restore();
    }

    function drawMarketChart() {
      const canvas = el.marketChart;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;

      const width = canvas.clientWidth || 760;
      const height = canvas.clientHeight || 320;
      const ratio = window.devicePixelRatio || 1;
      canvas.width = Math.floor(width * ratio);
      canvas.height = Math.floor(height * ratio);
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      ctx.clearRect(0, 0, width, height);

      const symbol = state.selectedSymbol || "";
      if (!symbol) {
        el.chartMeta.textContent = "Waiting for market data...";
        drawEmptyChart(ctx, width, height, "No symbol selected");
        return;
      }

      const key = chartKey(symbol, state.chartTf);
      const fullCandles = (state.marketCandles[key] || []).slice(-320);
      if (fullCandles.length < 2) {
        el.chartMeta.textContent = `${symbol} ${state.chartTf} - waiting for candles`;
        drawEmptyChart(ctx, width, height, "Not enough candle data");
        return;
      }

      state.chartTotalCount = fullCandles.length;
      const visible = clampNumber(
        Math.round(state.chartVisibleCount || Math.min(150, fullCandles.length)),
        40,
        fullCandles.length
      );
      state.chartVisibleCount = visible;
      const maxPan = Math.max(0, fullCandles.length - visible);
      state.chartPanBars = clampNumber(Math.round(state.chartPanBars || 0), 0, maxPan);
      const endIndex = fullCandles.length - state.chartPanBars;
      const startIndex = Math.max(0, endIndex - visible);
      const candles = fullCandles.slice(startIndex, endIndex);

      const digits = inferPriceDigits(candles);
      const highs = candles.map(c => Number(c.high));
      const lows = candles.map(c => Number(c.low));
      const hiRaw = Math.max(...highs);
      const loRaw = Math.min(...lows);
      const midRaw = (hiRaw + loRaw) / 2;
      const spanRaw = Math.max(hiRaw - loRaw, 0.00001);
      const yZoom = clampNumber(Number(state.chartYZoom || 1), 0.5, 6);
      state.chartYZoom = yZoom;
      const yShift = Number(state.chartYShift || 0);
      const mid = midRaw + yShift;
      const half = (spanRaw / 2) / yZoom;
      const pad = Math.max(half * 0.10, spanRaw * 0.02, 0.00001);
      const hi = mid + half + pad;
      const lo = mid - half - pad;

      const left = 14;
      const right = 92;
      const top = 12;
      const bottom = 30;
      const plotW = width - left - right;
      const plotH = height - top - bottom;
      const vp = {
        left, right, top, bottom, plotW, plotH, hi, lo,
        count: candles.length,
        startIndex,
        endIndex,
        totalCount: fullCandles.length,
        priceDigits: digits
      };
      state.chartViewport = vp;

      ctx.fillStyle = "#0a1222";
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = "#0b1528";
      ctx.fillRect(left, top, plotW, plotH);

      ctx.strokeStyle = "rgba(130,149,186,0.20)";
      ctx.lineWidth = 1;
      for (let i = 0; i <= 6; i += 1) {
        const y = top + (i / 6) * plotH;
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(left + plotW, y);
        ctx.stroke();
      }
      for (let i = 0; i <= 8; i += 1) {
        const x = left + (i / 8) * plotW;
        ctx.beginPath();
        ctx.moveTo(x, top);
        ctx.lineTo(x, top + plotH);
        ctx.stroke();
      }

      ctx.save();
      ctx.beginPath();
      ctx.rect(left, top, plotW, plotH);
      ctx.clip();

      const bodyW = Math.max(2, Math.floor((plotW / candles.length) * 0.62));
      candles.forEach((c, i) => {
        const absIndex = startIndex + i;
        const open = Number(c.open);
        const high = Number(c.high);
        const low = Number(c.low);
        const close = Number(c.close);
        const x = xForIndex(absIndex, vp);
        const yHigh = yForPrice(high, vp);
        const yLow = yForPrice(low, vp);
        const yOpen = yForPrice(open, vp);
        const yClose = yForPrice(close, vp);
        const bullish = close >= open;
        ctx.strokeStyle = bullish ? "#1cc688" : "#ea5d73";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, yHigh);
        ctx.lineTo(x, yLow);
        ctx.stroke();

        const topBody = Math.min(yOpen, yClose);
        const bodyH = Math.max(1, Math.abs(yClose - yOpen));
        ctx.fillStyle = bullish ? "#23d18b" : "#ff5f6d";
        ctx.fillRect(x - Math.floor(bodyW / 2), topBody, bodyW, bodyH);
      });

      const structure = state.marketStructure[key] || { points: [], fvg: [] };
      drawEAStructureOverlay(ctx, vp, candles, structure);
      drawLivePositionOverlays(ctx, vp, digits);
      drawChartDrawings(ctx, vp);
      ctx.restore();

      const axisX = left + plotW;
      ctx.fillStyle = "#0c162c";
      ctx.fillRect(axisX, top, right, plotH);
      ctx.strokeStyle = "rgba(130,149,186,0.25)";
      ctx.beginPath();
      ctx.moveTo(axisX, top);
      ctx.lineTo(axisX, top + plotH);
      ctx.stroke();

      ctx.fillStyle = "#9db5dd";
      ctx.font = "11px Segoe UI";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      for (let i = 0; i <= 6; i += 1) {
        const y = top + (i / 6) * plotH;
        const price = hi - (i / 6) * (hi - lo);
        ctx.fillText(formatPrice(price, digits), axisX + 8, y);
      }

      const tickStep = Math.max(1, Math.floor(candles.length / 6));
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      for (let i = 0; i < candles.length; i += tickStep) {
        const x = xForIndex(startIndex + i, vp);
        ctx.fillStyle = "#8ea2cc";
        ctx.fillText(formatTimeLabel(candles[i].time), x, top + plotH + 6);
      }

      const last = candles[candles.length - 1];
      const lastP = Number(last.close);
      const lastY = yForPrice(lastP, vp);
      const bullish = Number(last.close) >= Number(last.open);
      ctx.strokeStyle = bullish ? "rgba(35,209,139,0.85)" : "rgba(255,95,109,0.85)";
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(left, lastY);
      ctx.lineTo(left + plotW, lastY);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.font = "11px Segoe UI";
      drawPriceTag(ctx, axisX + 6, lastY, formatPrice(lastP, digits), bullish ? "#23d18b" : "#ff5f6d", "#07111f", top, top + plotH);

      if (state.chartHover && state.chartHover.i >= vp.startIndex && state.chartHover.i < vp.endIndex) {
        const hx = xForIndex(state.chartHover.i, vp);
        const hy = yForPrice(state.chartHover.p, vp);
        ctx.strokeStyle = "rgba(173,197,241,0.48)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(left, hy);
        ctx.lineTo(left + plotW, hy);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(hx, top);
        ctx.lineTo(hx, top + plotH);
        ctx.stroke();

        drawPriceTag(ctx, axisX + 6, hy, formatPrice(state.chartHover.p, digits), "#193258", "#f2f7ff", top, top + plotH);
      }

      const first = candles[0];
      const delta = Number(last.close) - Number(first.open);
      const sign = delta >= 0 ? "+" : "";
      const t0 = formatTimeLabel(candles[0].time);
      const t1 = formatTimeLabel(last.time);
      const structCount = Array.isArray(structure.points) ? structure.points.length : 0;
      const fvgCount = Array.isArray(structure.fvg) ? structure.fvg.length : 0;
      el.chartMeta.textContent = `${symbol} ${state.chartTf} | O ${formatPrice(last.open, digits)} H ${formatPrice(last.high, digits)} L ${formatPrice(last.low, digits)} C ${formatPrice(last.close, digits)} | ${sign}${formatPrice(delta, digits)} | ${t0} - ${t1} | ${candles.length}/${fullCandles.length} bars | HH/HL/LH/LL: ${structCount} | FVG: ${fvgCount} | Yx${state.chartYZoom.toFixed(2)}`;
    }

    function applyChartZoom(direction, anchorX = null) {
      const vp = state.chartViewport;
      if (!vp) return;
      const total = vp.totalCount || state.chartTotalCount || vp.count;
      const curr = state.chartVisibleCount || vp.count;
      const factor = direction > 0 ? 0.88 : 1.12;
      const next = clampNumber(Math.round(curr * factor), 40, total);
      const ratio = anchorX === null ? 1 : clampNumber((anchorX - vp.left) / Math.max(1, vp.plotW), 0, 1);
      const focus = anchorX === null ? (vp.endIndex - 1) : indexFromX(anchorX, vp);
      const nextStart = clampNumber(Math.round(focus - ratio * next), 0, Math.max(0, total - next));
      state.chartVisibleCount = next;
      state.chartPanBars = total - (nextStart + next);
      drawMarketChart();
    }

    function resetChartView() {
      state.chartVisibleCount = Math.min(150, Math.max(60, state.chartTotalCount || 150));
      state.chartPanBars = 0;
      state.chartYZoom = 1;
      state.chartYShift = 0;
      state.chartPanMode = false;
      state.chartScaleMode = false;
      state.chartPinchMode = false;
      state.chartPointerSamples = {};
      drawMarketChart();
    }

    function autoScaleToCurrentPrice() {
      state.chartPanBars = 0;
      state.chartYZoom = 1;
      state.chartYShift = 0;
      state.chartScaleMode = false;
      state.chartPinchMode = false;
      state.chartPointerSamples = {};
      drawMarketChart();
    }

    function setFreeMove(enabled) {
      state.chartFreeMove = !!enabled;
      el.freeMoveBtn.textContent = `Free Move: ${state.chartFreeMove ? "On" : "Off"}`;
      el.freeMoveBtn.classList.toggle("active", state.chartFreeMove);
      if (!state.chartFreeMove) {
        state.chartPanMode = false;
        state.chartPinchMode = false;
        state.chartPointerSamples = {};
      }
    }

    function onChartWheel(evt) {
      const vp = state.chartViewport;
      if (!vp) return;
      evt.preventDefault();
      const pt = chartPointFromEvent(evt);
      if (pt && pt.axis) {
        const factor = evt.deltaY < 0 ? 1.08 : 0.92;
        state.chartYZoom = clampNumber(Number(state.chartYZoom || 1) * factor, 0.5, 6);
        drawMarketChart();
        return;
      }
      applyChartZoom(evt.deltaY < 0 ? 1 : -1, pt ? pt.x : null);
    }

    function onChartPointerDown(evt) {
      const pt = chartPointFromEvent(evt);
      if (!pt || !state.selectedSymbol) return;
      state.chartHover = (pt.inside || pt.axis) ? { i: pt.i, p: pt.p } : null;
      trackPointer(evt, pt);

      if (pt.inside && pt.vp) {
        const hit = findPositionHandleAt(pt.x, pt.y, pt.vp);
        if (hit) {
          state.selectedDrawingIndex = hit.index;
          // Free-move priority in normal mode; direct handle editing in Long/Short edit mode.
          if (state.chartTool === "long" || state.chartTool === "short") {
            state.chartPositionDraft = hit;
            state.chartPointerId = evt.pointerId ?? null;
            if (evt.pointerId !== undefined && evt.pointerId !== null) {
              try { el.marketChart.setPointerCapture(evt.pointerId); } catch (_) {}
            }
            drawMarketChart();
            return;
          }
        }
        const drawingHit = findDrawingAt(pt.x, pt.y, pt.vp);
        if (drawingHit >= 0) {
          state.selectedDrawingIndex = drawingHit;
        } else {
          state.selectedDrawingIndex = -1;
        }
      }

      if (state.chartTool === "none") {
        const freeMoveHit = state.chartFreeMove && (pt.inside || pt.axis);
        if (freeMoveHit && pt.vp && pointerSamples().length >= 2) {
          beginPinch(pt.vp);
        } else if (freeMoveHit) {
          state.chartPinchMode = false;
          state.chartScaleMode = false;
          state.chartPanMode = true;
          state.chartPanStartX = clampNumber(pt.x, pt.vp.left, pt.vp.left + pt.vp.plotW);
          state.chartPanStartY = clampNumber(pt.y, pt.vp.top, pt.vp.top + pt.vp.plotH);
          state.chartPanStartBars = Number(state.chartPanBars || 0);
          state.chartPanStartYShift = Number(state.chartYShift || 0);
        } else if (pt.axis) {
          state.chartScaleMode = true;
          state.chartScaleStartY = pt.y;
          state.chartScaleStartZoom = Number(state.chartYZoom || 1);
        }
        state.chartPointerId = evt.pointerId ?? null;
        if (evt.pointerId !== undefined && evt.pointerId !== null) {
          try { el.marketChart.setPointerCapture(evt.pointerId); } catch (_) {}
        }
        drawMarketChart();
        return;
      }

      if (!pt.inside) return;
      const drawings = drawingsForCurrentChart();
      if (state.chartTool === "hline") {
        drawings.push({ type: "hline", p: pt.p });
        state.selectedDrawingIndex = drawings.length - 1;
        drawMarketChart();
        return;
      }
      if (state.chartTool === "poly") {
        state.chartPendingPoints.push({ i: pt.i, p: pt.p });
        if (state.chartPendingPoints.length >= 3 || evt.detail >= 2) {
          drawings.push({ type: "poly", points: state.chartPendingPoints.slice() });
          state.selectedDrawingIndex = drawings.length - 1;
          state.chartPendingPoints = [];
        }
        drawMarketChart();
        return;
      }
      if (state.chartTool === "long" || state.chartTool === "short") {
        state.chartPendingPoints.push({ i: pt.i, p: pt.p });
        if (state.chartPendingPoints.length >= 3) {
          const draft = buildPositionDraft(state.chartTool, state.chartPendingPoints.slice(0, 3), pt.vp, null);
          if (draft) {
            drawings.push({ type: "position", ...draft });
            state.selectedDrawingIndex = drawings.length - 1;
          }
          state.chartPendingPoints = [];
          setChartTool("none");
          return;
        }
        drawMarketChart();
        return;
      }
      if (state.chartTool === "trend" || state.chartTool === "rect") {
        state.chartPointerDown = true;
        state.chartPointerId = evt.pointerId ?? null;
        state.chartDragStart = { i: pt.i, p: pt.p };
        state.chartDragCurrent = { i: pt.i, p: pt.p };
        if (evt.pointerId !== undefined && evt.pointerId !== null) {
          try { el.marketChart.setPointerCapture(evt.pointerId); } catch (_) {}
        }
        drawMarketChart();
      }
    }

    function onChartPointerMove(evt) {
      const pt = chartPointFromEvent(evt);
      if (!pt) return;
      state.chartHover = (pt.inside || pt.axis) ? { i: pt.i, p: pt.p } : null;
      trackPointer(evt, pt);

      if (state.chartPositionDraft && state.chartViewport) {
        const rect = el.marketChart.getBoundingClientRect();
        const x = evt.clientX - rect.left;
        const y = evt.clientY - rect.top;
        const vp = state.chartViewport;
        const cx = clampNumber(x, vp.left, vp.left + vp.plotW);
        const cy = clampNumber(y, vp.top, vp.top + vp.plotH);
        const i = indexFromX(cx, vp);
        const p = priceFromY(cy, vp);
        if (applyPositionHandleDrag(state.chartPositionDraft, i, p, vp)) {
          drawMarketChart();
        }
        return;
      }

      if (state.chartPinchMode && state.chartViewport) {
        const vp = state.chartViewport;
        const pts = pointerSamples();
        if (pts.length < 2) {
          state.chartPinchMode = false;
          drawMarketChart();
          return;
        }
        const a = pts[0];
        const b = pts[1];
        const dist = Math.max(8, Math.hypot(a.x - b.x, a.y - b.y));
        const centerX = clampNumber((a.x + b.x) / 2, vp.left, vp.left + vp.plotW);
        const centerY = clampNumber((a.y + b.y) / 2, vp.top, vp.top + vp.plotH);
        const total = vp.totalCount || state.chartTotalCount || vp.count;
        const startVisible = Math.max(40, Number(state.chartPinchStartVisible || vp.count || 150));
        const nextVisible = clampNumber(Math.round(startVisible * (state.chartPinchStartDist / dist)), 40, total);
        state.chartVisibleCount = nextVisible;
        const barsPerPx = vp.count / Math.max(1, vp.plotW);
        const deltaBars = Math.round((centerX - state.chartPinchStartCenterX) * barsPerPx);
        const maxPan = Math.max(0, total - nextVisible);
        state.chartPanBars = clampNumber(state.chartPinchStartPanBars + deltaBars, 0, maxPan);
        const yFactor = state.chartPinchStartDist / dist;
        state.chartYZoom = clampNumber(state.chartPinchStartYZoom * yFactor, 0.5, 6);
        const pricePerPx = (vp.hi - vp.lo) / Math.max(1, vp.plotH);
        const deltaPrice = (centerY - state.chartPinchStartCenterY) * pricePerPx;
        state.chartYShift = state.chartPinchStartYShift + deltaPrice;
        drawMarketChart();
        return;
      }

      if (state.chartPanMode && state.chartViewport) {
        const vp = state.chartViewport;
        const px = clampNumber(pt.x, vp.left, vp.left + vp.plotW);
        const py = clampNumber(pt.y, vp.top, vp.top + vp.plotH);
        const barsPerPx = vp.count / Math.max(1, vp.plotW);
        const deltaBars = Math.round((px - state.chartPanStartX) * barsPerPx);
        const maxPan = Math.max(0, (vp.totalCount || state.chartTotalCount) - state.chartVisibleCount);
        state.chartPanBars = clampNumber(state.chartPanStartBars + deltaBars, 0, maxPan);
        const pricePerPx = (vp.hi - vp.lo) / Math.max(1, vp.plotH);
        const deltaPrice = (py - state.chartPanStartY) * pricePerPx;
        state.chartYShift = state.chartPanStartYShift + deltaPrice;
        drawMarketChart();
        return;
      }
      if (state.chartScaleMode) {
        const dy = pt.y - state.chartScaleStartY;
        const factor = Math.exp(-dy * 0.01);
        state.chartYZoom = clampNumber(state.chartScaleStartZoom * factor, 0.5, 6);
        drawMarketChart();
        return;
      }
      if (state.chartPointerDown && pt.inside && (state.chartTool === "trend" || state.chartTool === "rect")) {
        state.chartDragCurrent = { i: pt.i, p: pt.p };
      }
      drawMarketChart();
    }

    function onChartPointerUp(evt) {
      untrackPointer(evt.pointerId);
      if (state.chartPositionDraft) {
        state.chartPositionDraft = null;
        if (state.chartPointerId !== null) {
          try { el.marketChart.releasePointerCapture(state.chartPointerId); } catch (_) {}
        }
        state.chartPointerId = null;
        drawMarketChart();
        return;
      }
      if (state.chartPinchMode) {
        const pts = pointerSamples();
        if (pts.length >= 2) {
          drawMarketChart();
          return;
        }
        state.chartPinchMode = false;
        if (state.chartFreeMove && pts.length === 1 && state.chartViewport) {
          const vp = state.chartViewport;
          const rem = pts[0];
          state.chartPanMode = true;
          state.chartPanStartX = clampNumber(rem.x, vp.left, vp.left + vp.plotW);
          state.chartPanStartY = clampNumber(rem.y, vp.top, vp.top + vp.plotH);
          state.chartPanStartBars = Number(state.chartPanBars || 0);
          state.chartPanStartYShift = Number(state.chartYShift || 0);
          drawMarketChart();
          return;
        }
      }
      if (state.chartPanMode || state.chartScaleMode) {
        state.chartPanMode = false;
        state.chartScaleMode = false;
        const pts = pointerSamples();
        if (state.chartFreeMove && pts.length === 1 && state.chartViewport) {
          const vp = state.chartViewport;
          const rem = pts[0];
          state.chartPanMode = true;
          state.chartPanStartX = clampNumber(rem.x, vp.left, vp.left + vp.plotW);
          state.chartPanStartY = clampNumber(rem.y, vp.top, vp.top + vp.plotH);
          state.chartPanStartBars = Number(state.chartPanBars || 0);
          state.chartPanStartYShift = Number(state.chartYShift || 0);
          drawMarketChart();
          return;
        }
        if (state.chartPointerId !== null) {
          try { el.marketChart.releasePointerCapture(state.chartPointerId); } catch (_) {}
        }
        state.chartPointerId = null;
        drawMarketChart();
        return;
      }
      if (!state.chartPointerDown) return;
      const pt = chartPointFromEvent(evt);
      const endPoint = (pt && pt.inside) ? { i: pt.i, p: pt.p } : state.chartDragCurrent;
      const startPoint = state.chartDragStart;
      const drawings = drawingsForCurrentChart();
      if (startPoint && endPoint) {
        if (state.chartTool === "trend") drawings.push({ type: "trend", i1: startPoint.i, p1: startPoint.p, i2: endPoint.i, p2: endPoint.p });
        else if (state.chartTool === "rect") drawings.push({ type: "rect", i1: startPoint.i, p1: startPoint.p, i2: endPoint.i, p2: endPoint.p });
        state.selectedDrawingIndex = drawings.length - 1;
      }
      if (state.chartPointerId !== null) {
        try { el.marketChart.releasePointerCapture(state.chartPointerId); } catch (_) {}
      }
      state.chartPointerDown = false;
      state.chartPointerId = null;
      state.chartDragStart = null;
      state.chartDragCurrent = null;
      drawMarketChart();
    }

    function onChartPointerLeave() {
      state.chartPointerSamples = {};
      state.chartPinchMode = false;
      state.chartHover = null;
      if (!state.chartPointerDown && !state.chartPanMode && !state.chartScaleMode && !state.chartPinchMode) drawMarketChart();
    }

    async function closeTradeForSelectedSymbol() {
      const symbol = String(state.selectedSymbol || "").trim();
      if (!symbol) {
        log("Error: Select a symbol first");
        return;
      }
      const openBySymbol = (state.trades || []).filter(t =>
        String(t.symbol || "") === symbol && String(t.status || "Open").toLowerCase() === "open"
      );
      try {
        const res = await api("/api/trades/close", { method: "POST", body: { symbol } });
        log(`Closed ${res.closed || 0} trade(s) for ${symbol}`);
        await pollBackend();
        await fetchMarketCandles(true);
      } catch (err) {
        let closed = 0;
        const failed = [];
        for (const t of openBySymbol) {
          try {
            const r = await api("/api/trades/close", { method: "POST", body: { ticket: t.id } });
            closed += Number(r.closed || 0);
          } catch (e2) {
            failed.push(`${t.id}:${e2.message}`);
          }
        }
        if (closed > 0) {
          log(`Closed ${closed} trade(s) for ${symbol}${failed.length ? ` (some failed: ${failed.join(", ")})` : ""}`);
          await pollBackend();
          await fetchMarketCandles(true);
          return;
        }
        log(`Error: ${err.message}`);
      }
    }

    function focusMarketSymbol(symbol, switchPanel = true) {
      const sym = normalizeSymbol(symbol);
      if (!sym) return;
      if (state.allowedSymbols.length && !state.allowedSymbols.includes(sym)) {
        log(`Error: ${sym} is not in allowed markets`);
        return;
      }
      state.selectedSymbol = sym;
      state.chartPanBars = 0;
      state.chartYZoom = 1;
      state.chartYShift = 0;
      state.chartVisibleCount = Math.min(150, Math.max(60, state.chartTotalCount || 150));
      state.selectedDrawingIndex = -1;
      const exists = Array.from(el.chartSymbol.options).some(o => o.value === sym);
      if (!exists) {
        const opt = document.createElement("option");
        opt.value = sym;
        opt.textContent = sym;
        el.chartSymbol.appendChild(opt);
      }
      el.chartSymbol.value = sym;
      if (switchPanel) showPanel("marketPanel");
      syncMarketContext(false).catch(() => {});
      fetchMarketCandles(true).catch(() => {});
    }

    function setEngineState(running) {
      state.eaRunning = !!running;
      el.runStateChip.textContent = `Engine: ${running ? "Running" : "Idle"}`;
      el.runStateChip.style.borderColor = running ? "#1f6f50" : "var(--line)";
    }

    async function startEngine() {
      if (!state.connected) { log("Error: Broker not connected"); return; }
      if (!state.mq5Loaded) { log("Error: Upload EA .mq5 first"); return; }
      if (!applyAllowedSymbols(false)) return;
      const settings = collectSettings();
      const allowedSymbols = [...state.allowedSymbols];
      const primarySymbol = normalizeSymbol(state.selectedSymbol || allowedSymbols[0] || "");
      try {
        const res = await api("/api/ea/start", {
          method: "POST",
          body: {
            settings,
            allowed_symbols: allowedSymbols,
            primary_symbol: primarySymbol,
            chart_tf: normalizeTf(state.chartTf)
          }
        });
        if (Array.isArray(res.allowed_symbols) && res.allowed_symbols.length) {
          setAllowedSymbols(res.allowed_symbols, true);
        }
        if (!state.selectedSymbol && res.primary_symbol) {
          focusMarketSymbol(res.primary_symbol, false);
        } else if (!state.selectedSymbol && primarySymbol) {
          focusMarketSymbol(primarySymbol, false);
        }
        setEngineState(true);
        await syncMarketContext(false);
        await fetchMarketCandles(true);
        showPanel("marketPanel");
        log("EA execution started");
      } catch (err) {
        log(`Error: ${err.message}`);
      }
    }

    async function stopEngine() {
      try {
        await api("/api/ea/stop", { method: "POST" });
      } catch (_) {}
      setEngineState(false);
      await fetchMarketCandles(true).catch(() => {});
      log("EA execution stopped");
    }

    async function restartEngine() {
      if (!applyAllowedSymbols(false)) return;
      const settings = collectSettings();
      const allowedSymbols = [...state.allowedSymbols];
      const primarySymbol = normalizeSymbol(state.selectedSymbol || allowedSymbols[0] || "");
      try {
        const res = await api("/api/ea/restart", {
          method: "POST",
          body: {
            settings,
            allowed_symbols: allowedSymbols,
            primary_symbol: primarySymbol,
            chart_tf: normalizeTf(state.chartTf)
          }
        });
        if (Array.isArray(res.allowed_symbols) && res.allowed_symbols.length) {
          setAllowedSymbols(res.allowed_symbols, true);
        }
        if (!state.selectedSymbol && res.primary_symbol) {
          focusMarketSymbol(res.primary_symbol, false);
        } else if (!state.selectedSymbol && primarySymbol) {
          focusMarketSymbol(primarySymbol, false);
        }
        setEngineState(true);
        await syncMarketContext(false);
        await fetchMarketCandles(true);
        log("EA restart triggered");
      } catch (err) {
        log(`Error: ${err.message}`);
      }
    }

    async function pollBackend() {
      if (!state.authenticated) return;
      try {
        const [broker, ea, live, hist, logs, insight] = await Promise.all([
          api("/api/broker/status"),
          api("/api/ea/status"),
          api("/api/trades/live"),
          api("/api/trades/history"),
          api("/api/logs"),
          api("/api/ea/insight").catch(() => null)
        ]);
        setBackendApiState(true, "Connected");
        setBrokerStatus(broker.connected, broker.connected ? "Connected" : "Disconnected");
        state.connected = !!broker.connected;
        state.mq5Loaded = !!ea.ea_loaded;
        state.trades = live.trades || [];
        state.history = hist.trades || [];
        setEngineState(!!ea.running);
        if (Array.isArray(ea.allowed_symbols) && ea.allowed_symbols.length) {
          setAllowedSymbols(ea.allowed_symbols, true);
        }
        if (!state.selectedSymbol && ea.market_symbol) {
          state.selectedSymbol = normalizeSymbol(ea.market_symbol);
        } else if (!state.selectedSymbol && ea.primary_symbol) {
          state.selectedSymbol = normalizeSymbol(ea.primary_symbol);
        }
        if (!state.chartTf && ea.market_tf) {
          state.chartTf = normalizeTf(ea.market_tf);
          el.chartTf.value = state.chartTf;
        }
        renderLive(state.trades);
        renderHistory(state.history);
        renderInsight(insight);
        syncChartSymbolOptions();
        await fetchMarketCandles(false);
        (logs.logs || []).forEach(item => log(item.msg || "", true));
      } catch (err) {
        setBackendApiState(false, "Disconnected");
        setBrokerStatus(false, "Disconnected");
        setEngineState(false);
        renderInsight(buildFallbackInsight());
        if (!isFileMode()) log(`Backend poll error: ${err.message}`);
      }
    }

    function startPolling() {
      stopPolling();
      pollBackend();
      state.poller = setInterval(pollBackend, 1000);
    }

    function stopPolling() {
      if (state.poller) clearInterval(state.poller);
      state.poller = null;
    }

    function wire() {
      el.loginForm.addEventListener("submit", handleLogin);
      el.logoutBtn.addEventListener("click", logout);
      el.backendApiBtn.addEventListener("click", toggleBackendApi);
      el.connectBtn.addEventListener("click", connectBroker);
      el.mq5File.addEventListener("change", handleFileUpload);
      el.setFile.addEventListener("change", handleSetUpload);
      el.startBtn.addEventListener("click", startEngine);
      el.stopBtn.addEventListener("click", stopEngine);
      el.restartBtn.addEventListener("click", restartEngine);
      el.liveBody.addEventListener("click", (evt) => {
        const btn = evt.target.closest(".symbol-jump");
        if (!btn) return;
        focusMarketSymbol(btn.dataset.symbol || "", true);
      });
      el.chartSymbol.addEventListener("change", () => {
        state.selectedSymbol = normalizeSymbol(el.chartSymbol.value);
        state.chartPanBars = 0;
        state.chartYZoom = 1;
        state.chartYShift = 0;
        state.selectedDrawingIndex = -1;
        syncMarketContext(false).catch(() => {});
        fetchMarketCandles(true).catch(() => {});
      });
      el.applySymbolsBtn.addEventListener("click", () => {
        if (!applyAllowedSymbols(true)) return;
        if (state.selectedSymbol && !state.allowedSymbols.includes(state.selectedSymbol)) {
          state.selectedSymbol = state.allowedSymbols[0] || "";
        }
        if (state.selectedSymbol) {
          focusMarketSymbol(state.selectedSymbol, false);
        } else if (state.allowedSymbols[0]) {
          focusMarketSymbol(state.allowedSymbols[0], false);
        }
      });
      el.chartTf.addEventListener("change", () => {
        state.chartTf = normalizeTf(el.chartTf.value || "M1");
        state.chartDragStart = null;
        state.chartDragCurrent = null;
        state.chartPendingPoints = [];
        state.chartPositionDraft = null;
        state.selectedDrawingIndex = -1;
        state.chartPanBars = 0;
        state.chartYShift = 0;
        state.chartVisibleCount = Math.min(150, Math.max(60, state.chartTotalCount || 150));
        syncMarketContext(false).catch(() => {});
        fetchMarketCandles(true).catch(() => {});
      });
      el.toolTrend.addEventListener("click", () => setChartTool(state.chartTool === "trend" ? "none" : "trend"));
      el.toolPoly.addEventListener("click", () => setChartTool(state.chartTool === "poly" ? "none" : "poly"));
      el.toolHLine.addEventListener("click", () => setChartTool(state.chartTool === "hline" ? "none" : "hline"));
      el.toolRect.addEventListener("click", () => setChartTool(state.chartTool === "rect" ? "none" : "rect"));
      el.toolLong.addEventListener("click", () => setChartTool(state.chartTool === "long" ? "none" : "long"));
      el.toolShort.addEventListener("click", () => setChartTool(state.chartTool === "short" ? "none" : "short"));
      el.toolClear.addEventListener("click", () => {
        const key = drawingKey();
        if (key) {
          const rows = state.chartDrawings[key] || [];
          if (state.selectedDrawingIndex >= 0 && state.selectedDrawingIndex < rows.length) {
            rows.splice(state.selectedDrawingIndex, 1);
            state.chartDrawings[key] = rows;
          } else if (rows.length) {
            log("Select a drawing first, then click Clear Drawings.");
          }
        }
        state.selectedDrawingIndex = -1;
        state.chartPendingPoints = [];
        state.chartDragStart = null;
        state.chartDragCurrent = null;
        state.chartPositionDraft = null;
        state.chartPointerDown = false;
        state.chartPanMode = false;
        state.chartScaleMode = false;
        drawMarketChart();
      });
      el.zoomInBtn.addEventListener("click", () => applyChartZoom(1, null));
      el.zoomOutBtn.addEventListener("click", () => applyChartZoom(-1, null));
      el.resetViewBtn.addEventListener("click", resetChartView);
      el.autoScaleBtn.addEventListener("click", autoScaleToCurrentPrice);
      el.freeMoveBtn.addEventListener("click", () => setFreeMove(!state.chartFreeMove));
      el.closeTradeBtn.addEventListener("click", closeTradeForSelectedSymbol);
      el.marketChart.addEventListener("pointerdown", onChartPointerDown);
      el.marketChart.addEventListener("pointermove", onChartPointerMove);
      el.marketChart.addEventListener("pointerup", onChartPointerUp);
      el.marketChart.addEventListener("pointercancel", onChartPointerUp);
      el.marketChart.addEventListener("pointerleave", onChartPointerLeave);
      el.marketChart.addEventListener("wheel", onChartWheel, { passive: false });
      window.addEventListener("resize", drawMarketChart);
      el.brokerSelect.addEventListener("change", () => {
        const v = el.brokerSelect.value;
        if (v === "Deriv") el.compatibilityLabel.textContent = "Connected via MT5 bridge";
        else if (v === "MetaTrader5") el.compatibilityLabel.textContent = "Direct MT5 Execution Mode";
        else el.compatibilityLabel.textContent = "Broker accepted by MetaTrader5";
      });
      el.apiBase.addEventListener("change", () => {
        state.apiSessionToken = "";
        setBackendApiState(false, "Disconnected");
        setEngineState(false);
        stopPolling();
        state.marketCandles = {};
        state.marketStructure = {};
        renderInsight(buildFallbackInsight());
        if (state.authenticated) log("Backend API URL changed. Click Connect Backend to retry.");
      });
      initPanels();
      if (isFileMode()) {
        log("Tip: open this page via local server and run backend on http://127.0.0.1:8787");
      }
    }

    wire();
    setBackendApiState(false, "Disconnected");
    setBrokerStatus(false, "Disconnected");
    state.chartTf = el.chartTf.value || "M1";
    applyAllowedSymbols(false);
    setChartTool("none");
    setFreeMove(false);
    el.setFile.disabled = true;
    el.setFileName.textContent = "No .set loaded";
    loadSession();
    renderLive([]);
    renderHistory([]);
    renderInsight(buildFallbackInsight());
    drawMarketChart();
    log("Dashboard initialized");
  </script>
</body>
</html>
